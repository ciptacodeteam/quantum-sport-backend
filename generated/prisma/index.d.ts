
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model PhoneVerification
 * 
 */
export type PhoneVerification = $Result.DefaultSelection<Prisma.$PhoneVerificationPayload>
/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model AuthToken
 * 
 */
export type AuthToken = $Result.DefaultSelection<Prisma.$AuthTokenPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model Court
 * 
 */
export type Court = $Result.DefaultSelection<Prisma.$CourtPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model Slot
 * 
 */
export type Slot = $Result.DefaultSelection<Prisma.$SlotPayload>
/**
 * Model CourtCostSchedule
 * 
 */
export type CourtCostSchedule = $Result.DefaultSelection<Prisma.$CourtCostSchedulePayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model BookingDetail
 * 
 */
export type BookingDetail = $Result.DefaultSelection<Prisma.$BookingDetailPayload>
/**
 * Model BookingInventory
 * 
 */
export type BookingInventory = $Result.DefaultSelection<Prisma.$BookingInventoryPayload>
/**
 * Model BookingBallboy
 * 
 */
export type BookingBallboy = $Result.DefaultSelection<Prisma.$BookingBallboyPayload>
/**
 * Model BookingCoachType
 * 
 */
export type BookingCoachType = $Result.DefaultSelection<Prisma.$BookingCoachTypePayload>
/**
 * Model CoachTypeStaffPrice
 * 
 */
export type CoachTypeStaffPrice = $Result.DefaultSelection<Prisma.$CoachTypeStaffPricePayload>
/**
 * Model BookingCoach
 * 
 */
export type BookingCoach = $Result.DefaultSelection<Prisma.$BookingCoachPayload>
/**
 * Model Membership
 * 
 */
export type Membership = $Result.DefaultSelection<Prisma.$MembershipPayload>
/**
 * Model MembershipBenefit
 * 
 */
export type MembershipBenefit = $Result.DefaultSelection<Prisma.$MembershipBenefitPayload>
/**
 * Model MembershipUser
 * 
 */
export type MembershipUser = $Result.DefaultSelection<Prisma.$MembershipUserPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model ClassBooking
 * 
 */
export type ClassBooking = $Result.DefaultSelection<Prisma.$ClassBookingPayload>
/**
 * Model ClassBookingDetail
 * 
 */
export type ClassBookingDetail = $Result.DefaultSelection<Prisma.$ClassBookingDetailPayload>
/**
 * Model Club
 * 
 */
export type Club = $Result.DefaultSelection<Prisma.$ClubPayload>
/**
 * Model ClubMember
 * 
 */
export type ClubMember = $Result.DefaultSelection<Prisma.$ClubMemberPayload>
/**
 * Model Tournament
 * 
 */
export type Tournament = $Result.DefaultSelection<Prisma.$TournamentPayload>
/**
 * Model TournamentRegistration
 * 
 */
export type TournamentRegistration = $Result.DefaultSelection<Prisma.$TournamentRegistrationPayload>
/**
 * Model TournamentRegistrationMember
 * 
 */
export type TournamentRegistrationMember = $Result.DefaultSelection<Prisma.$TournamentRegistrationMemberPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  BALLBOY: 'BALLBOY',
  COACH: 'COACH'
};

export type Role = (typeof Role)[keyof typeof Role]


export const PhoneVerificationType: {
  LOGIN: 'LOGIN',
  REGISTER: 'REGISTER',
  FORGOT_PASSWORD: 'FORGOT_PASSWORD',
  VERIFY_PHONE: 'VERIFY_PHONE',
  CHANGE_PHONE: 'CHANGE_PHONE'
};

export type PhoneVerificationType = (typeof PhoneVerificationType)[keyof typeof PhoneVerificationType]


export const AuthTokenType: {
  STAFF: 'STAFF',
  USER: 'USER'
};

export type AuthTokenType = (typeof AuthTokenType)[keyof typeof AuthTokenType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  AWAITING_CONFIRMATION: 'AWAITING_CONFIRMATION',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const BookingStatus: {
  DRAFT: 'DRAFT',
  HOLD: 'HOLD',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const SlotType: {
  COURT: 'COURT',
  COACH: 'COACH',
  BALLBOY: 'BALLBOY'
};

export type SlotType = (typeof SlotType)[keyof typeof SlotType]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  ALL: 'ALL'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ClubVisibility: {
  PRIVATE: 'PRIVATE',
  PUBLIC: 'PUBLIC'
};

export type ClubVisibility = (typeof ClubVisibility)[keyof typeof ClubVisibility]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type PhoneVerificationType = $Enums.PhoneVerificationType

export const PhoneVerificationType: typeof $Enums.PhoneVerificationType

export type AuthTokenType = $Enums.AuthTokenType

export const AuthTokenType: typeof $Enums.AuthTokenType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type SlotType = $Enums.SlotType

export const SlotType: typeof $Enums.SlotType

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ClubVisibility = $Enums.ClubVisibility

export const ClubVisibility: typeof $Enums.ClubVisibility

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phoneVerification`: Exposes CRUD operations for the **PhoneVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhoneVerifications
    * const phoneVerifications = await prisma.phoneVerification.findMany()
    * ```
    */
  get phoneVerification(): Prisma.PhoneVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authToken`: Exposes CRUD operations for the **AuthToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthTokens
    * const authTokens = await prisma.authToken.findMany()
    * ```
    */
  get authToken(): Prisma.AuthTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court`: Exposes CRUD operations for the **Court** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courts
    * const courts = await prisma.court.findMany()
    * ```
    */
  get court(): Prisma.CourtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slot`: Exposes CRUD operations for the **Slot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Slots
    * const slots = await prisma.slot.findMany()
    * ```
    */
  get slot(): Prisma.SlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courtCostSchedule`: Exposes CRUD operations for the **CourtCostSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourtCostSchedules
    * const courtCostSchedules = await prisma.courtCostSchedule.findMany()
    * ```
    */
  get courtCostSchedule(): Prisma.CourtCostScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingDetail`: Exposes CRUD operations for the **BookingDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingDetails
    * const bookingDetails = await prisma.bookingDetail.findMany()
    * ```
    */
  get bookingDetail(): Prisma.BookingDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingInventory`: Exposes CRUD operations for the **BookingInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingInventories
    * const bookingInventories = await prisma.bookingInventory.findMany()
    * ```
    */
  get bookingInventory(): Prisma.BookingInventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingBallboy`: Exposes CRUD operations for the **BookingBallboy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingBallboys
    * const bookingBallboys = await prisma.bookingBallboy.findMany()
    * ```
    */
  get bookingBallboy(): Prisma.BookingBallboyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingCoachType`: Exposes CRUD operations for the **BookingCoachType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingCoachTypes
    * const bookingCoachTypes = await prisma.bookingCoachType.findMany()
    * ```
    */
  get bookingCoachType(): Prisma.BookingCoachTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coachTypeStaffPrice`: Exposes CRUD operations for the **CoachTypeStaffPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachTypeStaffPrices
    * const coachTypeStaffPrices = await prisma.coachTypeStaffPrice.findMany()
    * ```
    */
  get coachTypeStaffPrice(): Prisma.CoachTypeStaffPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingCoach`: Exposes CRUD operations for the **BookingCoach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingCoaches
    * const bookingCoaches = await prisma.bookingCoach.findMany()
    * ```
    */
  get bookingCoach(): Prisma.BookingCoachDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **Membership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memberships
    * const memberships = await prisma.membership.findMany()
    * ```
    */
  get membership(): Prisma.MembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membershipBenefit`: Exposes CRUD operations for the **MembershipBenefit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembershipBenefits
    * const membershipBenefits = await prisma.membershipBenefit.findMany()
    * ```
    */
  get membershipBenefit(): Prisma.MembershipBenefitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membershipUser`: Exposes CRUD operations for the **MembershipUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembershipUsers
    * const membershipUsers = await prisma.membershipUser.findMany()
    * ```
    */
  get membershipUser(): Prisma.MembershipUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classBooking`: Exposes CRUD operations for the **ClassBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassBookings
    * const classBookings = await prisma.classBooking.findMany()
    * ```
    */
  get classBooking(): Prisma.ClassBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classBookingDetail`: Exposes CRUD operations for the **ClassBookingDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassBookingDetails
    * const classBookingDetails = await prisma.classBookingDetail.findMany()
    * ```
    */
  get classBookingDetail(): Prisma.ClassBookingDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.club`: Exposes CRUD operations for the **Club** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clubs
    * const clubs = await prisma.club.findMany()
    * ```
    */
  get club(): Prisma.ClubDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clubMember`: Exposes CRUD operations for the **ClubMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClubMembers
    * const clubMembers = await prisma.clubMember.findMany()
    * ```
    */
  get clubMember(): Prisma.ClubMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournament`: Exposes CRUD operations for the **Tournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournament.findMany()
    * ```
    */
  get tournament(): Prisma.TournamentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournamentRegistration`: Exposes CRUD operations for the **TournamentRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentRegistrations
    * const tournamentRegistrations = await prisma.tournamentRegistration.findMany()
    * ```
    */
  get tournamentRegistration(): Prisma.TournamentRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournamentRegistrationMember`: Exposes CRUD operations for the **TournamentRegistrationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentRegistrationMembers
    * const tournamentRegistrationMembers = await prisma.tournamentRegistrationMember.findMany()
    * ```
    */
  get tournamentRegistrationMember(): Prisma.TournamentRegistrationMemberDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    PhoneVerification: 'PhoneVerification',
    Staff: 'Staff',
    AuthToken: 'AuthToken',
    Banner: 'Banner',
    Court: 'Court',
    Inventory: 'Inventory',
    Slot: 'Slot',
    CourtCostSchedule: 'CourtCostSchedule',
    PaymentMethod: 'PaymentMethod',
    Payment: 'Payment',
    Invoice: 'Invoice',
    Booking: 'Booking',
    BookingDetail: 'BookingDetail',
    BookingInventory: 'BookingInventory',
    BookingBallboy: 'BookingBallboy',
    BookingCoachType: 'BookingCoachType',
    CoachTypeStaffPrice: 'CoachTypeStaffPrice',
    BookingCoach: 'BookingCoach',
    Membership: 'Membership',
    MembershipBenefit: 'MembershipBenefit',
    MembershipUser: 'MembershipUser',
    Class: 'Class',
    ClassBooking: 'ClassBooking',
    ClassBookingDetail: 'ClassBookingDetail',
    Club: 'Club',
    ClubMember: 'ClubMember',
    Tournament: 'Tournament',
    TournamentRegistration: 'TournamentRegistration',
    TournamentRegistrationMember: 'TournamentRegistrationMember'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "phoneVerification" | "staff" | "authToken" | "banner" | "court" | "inventory" | "slot" | "courtCostSchedule" | "paymentMethod" | "payment" | "invoice" | "booking" | "bookingDetail" | "bookingInventory" | "bookingBallboy" | "bookingCoachType" | "coachTypeStaffPrice" | "bookingCoach" | "membership" | "membershipBenefit" | "membershipUser" | "class" | "classBooking" | "classBookingDetail" | "club" | "clubMember" | "tournament" | "tournamentRegistration" | "tournamentRegistrationMember"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      PhoneVerification: {
        payload: Prisma.$PhoneVerificationPayload<ExtArgs>
        fields: Prisma.PhoneVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhoneVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhoneVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload>
          }
          findFirst: {
            args: Prisma.PhoneVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhoneVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload>
          }
          findMany: {
            args: Prisma.PhoneVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload>[]
          }
          create: {
            args: Prisma.PhoneVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload>
          }
          createMany: {
            args: Prisma.PhoneVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhoneVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload>[]
          }
          delete: {
            args: Prisma.PhoneVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload>
          }
          update: {
            args: Prisma.PhoneVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload>
          }
          deleteMany: {
            args: Prisma.PhoneVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhoneVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhoneVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload>[]
          }
          upsert: {
            args: Prisma.PhoneVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationPayload>
          }
          aggregate: {
            args: Prisma.PhoneVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhoneVerification>
          }
          groupBy: {
            args: Prisma.PhoneVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhoneVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhoneVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<PhoneVerificationCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      AuthToken: {
        payload: Prisma.$AuthTokenPayload<ExtArgs>
        fields: Prisma.AuthTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload>
          }
          findFirst: {
            args: Prisma.AuthTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload>
          }
          findMany: {
            args: Prisma.AuthTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload>[]
          }
          create: {
            args: Prisma.AuthTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload>
          }
          createMany: {
            args: Prisma.AuthTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload>[]
          }
          delete: {
            args: Prisma.AuthTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload>
          }
          update: {
            args: Prisma.AuthTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload>
          }
          deleteMany: {
            args: Prisma.AuthTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload>[]
          }
          upsert: {
            args: Prisma.AuthTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthTokenPayload>
          }
          aggregate: {
            args: Prisma.AuthTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthToken>
          }
          groupBy: {
            args: Prisma.AuthTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthTokenCountArgs<ExtArgs>
            result: $Utils.Optional<AuthTokenCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BannerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      Court: {
        payload: Prisma.$CourtPayload<ExtArgs>
        fields: Prisma.CourtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          findFirst: {
            args: Prisma.CourtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          findMany: {
            args: Prisma.CourtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>[]
          }
          create: {
            args: Prisma.CourtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          createMany: {
            args: Prisma.CourtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourtCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>[]
          }
          delete: {
            args: Prisma.CourtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          update: {
            args: Prisma.CourtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          deleteMany: {
            args: Prisma.CourtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourtUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>[]
          }
          upsert: {
            args: Prisma.CourtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          aggregate: {
            args: Prisma.CourtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt>
          }
          groupBy: {
            args: Prisma.CourtGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourtGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourtCountArgs<ExtArgs>
            result: $Utils.Optional<CourtCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      Slot: {
        payload: Prisma.$SlotPayload<ExtArgs>
        fields: Prisma.SlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          findFirst: {
            args: Prisma.SlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          findMany: {
            args: Prisma.SlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>[]
          }
          create: {
            args: Prisma.SlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          createMany: {
            args: Prisma.SlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>[]
          }
          delete: {
            args: Prisma.SlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          update: {
            args: Prisma.SlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          deleteMany: {
            args: Prisma.SlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>[]
          }
          upsert: {
            args: Prisma.SlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlotPayload>
          }
          aggregate: {
            args: Prisma.SlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlot>
          }
          groupBy: {
            args: Prisma.SlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<SlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.SlotCountArgs<ExtArgs>
            result: $Utils.Optional<SlotCountAggregateOutputType> | number
          }
        }
      }
      CourtCostSchedule: {
        payload: Prisma.$CourtCostSchedulePayload<ExtArgs>
        fields: Prisma.CourtCostScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourtCostScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourtCostScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload>
          }
          findFirst: {
            args: Prisma.CourtCostScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourtCostScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload>
          }
          findMany: {
            args: Prisma.CourtCostScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload>[]
          }
          create: {
            args: Prisma.CourtCostScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload>
          }
          createMany: {
            args: Prisma.CourtCostScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourtCostScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload>[]
          }
          delete: {
            args: Prisma.CourtCostScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload>
          }
          update: {
            args: Prisma.CourtCostScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload>
          }
          deleteMany: {
            args: Prisma.CourtCostScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourtCostScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourtCostScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload>[]
          }
          upsert: {
            args: Prisma.CourtCostScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCostSchedulePayload>
          }
          aggregate: {
            args: Prisma.CourtCostScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourtCostSchedule>
          }
          groupBy: {
            args: Prisma.CourtCostScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourtCostScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourtCostScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<CourtCostScheduleCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      BookingDetail: {
        payload: Prisma.$BookingDetailPayload<ExtArgs>
        fields: Prisma.BookingDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload>
          }
          findFirst: {
            args: Prisma.BookingDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload>
          }
          findMany: {
            args: Prisma.BookingDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload>[]
          }
          create: {
            args: Prisma.BookingDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload>
          }
          createMany: {
            args: Prisma.BookingDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload>[]
          }
          delete: {
            args: Prisma.BookingDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload>
          }
          update: {
            args: Prisma.BookingDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload>
          }
          deleteMany: {
            args: Prisma.BookingDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload>[]
          }
          upsert: {
            args: Prisma.BookingDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingDetailPayload>
          }
          aggregate: {
            args: Prisma.BookingDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingDetail>
          }
          groupBy: {
            args: Prisma.BookingDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingDetailCountArgs<ExtArgs>
            result: $Utils.Optional<BookingDetailCountAggregateOutputType> | number
          }
        }
      }
      BookingInventory: {
        payload: Prisma.$BookingInventoryPayload<ExtArgs>
        fields: Prisma.BookingInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingInventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingInventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload>
          }
          findFirst: {
            args: Prisma.BookingInventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingInventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload>
          }
          findMany: {
            args: Prisma.BookingInventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload>[]
          }
          create: {
            args: Prisma.BookingInventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload>
          }
          createMany: {
            args: Prisma.BookingInventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingInventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload>[]
          }
          delete: {
            args: Prisma.BookingInventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload>
          }
          update: {
            args: Prisma.BookingInventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload>
          }
          deleteMany: {
            args: Prisma.BookingInventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingInventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingInventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload>[]
          }
          upsert: {
            args: Prisma.BookingInventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInventoryPayload>
          }
          aggregate: {
            args: Prisma.BookingInventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingInventory>
          }
          groupBy: {
            args: Prisma.BookingInventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingInventoryCountArgs<ExtArgs>
            result: $Utils.Optional<BookingInventoryCountAggregateOutputType> | number
          }
        }
      }
      BookingBallboy: {
        payload: Prisma.$BookingBallboyPayload<ExtArgs>
        fields: Prisma.BookingBallboyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingBallboyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingBallboyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload>
          }
          findFirst: {
            args: Prisma.BookingBallboyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingBallboyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload>
          }
          findMany: {
            args: Prisma.BookingBallboyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload>[]
          }
          create: {
            args: Prisma.BookingBallboyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload>
          }
          createMany: {
            args: Prisma.BookingBallboyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingBallboyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload>[]
          }
          delete: {
            args: Prisma.BookingBallboyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload>
          }
          update: {
            args: Prisma.BookingBallboyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload>
          }
          deleteMany: {
            args: Prisma.BookingBallboyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingBallboyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingBallboyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload>[]
          }
          upsert: {
            args: Prisma.BookingBallboyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingBallboyPayload>
          }
          aggregate: {
            args: Prisma.BookingBallboyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingBallboy>
          }
          groupBy: {
            args: Prisma.BookingBallboyGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingBallboyGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingBallboyCountArgs<ExtArgs>
            result: $Utils.Optional<BookingBallboyCountAggregateOutputType> | number
          }
        }
      }
      BookingCoachType: {
        payload: Prisma.$BookingCoachTypePayload<ExtArgs>
        fields: Prisma.BookingCoachTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingCoachTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingCoachTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload>
          }
          findFirst: {
            args: Prisma.BookingCoachTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingCoachTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload>
          }
          findMany: {
            args: Prisma.BookingCoachTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload>[]
          }
          create: {
            args: Prisma.BookingCoachTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload>
          }
          createMany: {
            args: Prisma.BookingCoachTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCoachTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload>[]
          }
          delete: {
            args: Prisma.BookingCoachTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload>
          }
          update: {
            args: Prisma.BookingCoachTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload>
          }
          deleteMany: {
            args: Prisma.BookingCoachTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingCoachTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingCoachTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload>[]
          }
          upsert: {
            args: Prisma.BookingCoachTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachTypePayload>
          }
          aggregate: {
            args: Prisma.BookingCoachTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingCoachType>
          }
          groupBy: {
            args: Prisma.BookingCoachTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingCoachTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCoachTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCoachTypeCountAggregateOutputType> | number
          }
        }
      }
      CoachTypeStaffPrice: {
        payload: Prisma.$CoachTypeStaffPricePayload<ExtArgs>
        fields: Prisma.CoachTypeStaffPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachTypeStaffPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachTypeStaffPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload>
          }
          findFirst: {
            args: Prisma.CoachTypeStaffPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachTypeStaffPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload>
          }
          findMany: {
            args: Prisma.CoachTypeStaffPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload>[]
          }
          create: {
            args: Prisma.CoachTypeStaffPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload>
          }
          createMany: {
            args: Prisma.CoachTypeStaffPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachTypeStaffPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload>[]
          }
          delete: {
            args: Prisma.CoachTypeStaffPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload>
          }
          update: {
            args: Prisma.CoachTypeStaffPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload>
          }
          deleteMany: {
            args: Prisma.CoachTypeStaffPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachTypeStaffPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoachTypeStaffPriceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload>[]
          }
          upsert: {
            args: Prisma.CoachTypeStaffPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachTypeStaffPricePayload>
          }
          aggregate: {
            args: Prisma.CoachTypeStaffPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachTypeStaffPrice>
          }
          groupBy: {
            args: Prisma.CoachTypeStaffPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachTypeStaffPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachTypeStaffPriceCountArgs<ExtArgs>
            result: $Utils.Optional<CoachTypeStaffPriceCountAggregateOutputType> | number
          }
        }
      }
      BookingCoach: {
        payload: Prisma.$BookingCoachPayload<ExtArgs>
        fields: Prisma.BookingCoachFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingCoachFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingCoachFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload>
          }
          findFirst: {
            args: Prisma.BookingCoachFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingCoachFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload>
          }
          findMany: {
            args: Prisma.BookingCoachFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload>[]
          }
          create: {
            args: Prisma.BookingCoachCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload>
          }
          createMany: {
            args: Prisma.BookingCoachCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCoachCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload>[]
          }
          delete: {
            args: Prisma.BookingCoachDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload>
          }
          update: {
            args: Prisma.BookingCoachUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload>
          }
          deleteMany: {
            args: Prisma.BookingCoachDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingCoachUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingCoachUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload>[]
          }
          upsert: {
            args: Prisma.BookingCoachUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingCoachPayload>
          }
          aggregate: {
            args: Prisma.BookingCoachAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingCoach>
          }
          groupBy: {
            args: Prisma.BookingCoachGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingCoachGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCoachCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCoachCountAggregateOutputType> | number
          }
        }
      }
      Membership: {
        payload: Prisma.$MembershipPayload<ExtArgs>
        fields: Prisma.MembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findFirst: {
            args: Prisma.MembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findMany: {
            args: Prisma.MembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          create: {
            args: Prisma.MembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          createMany: {
            args: Prisma.MembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          delete: {
            args: Prisma.MembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          update: {
            args: Prisma.MembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          deleteMany: {
            args: Prisma.MembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          upsert: {
            args: Prisma.MembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          aggregate: {
            args: Prisma.MembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembership>
          }
          groupBy: {
            args: Prisma.MembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipCountAggregateOutputType> | number
          }
        }
      }
      MembershipBenefit: {
        payload: Prisma.$MembershipBenefitPayload<ExtArgs>
        fields: Prisma.MembershipBenefitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipBenefitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipBenefitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload>
          }
          findFirst: {
            args: Prisma.MembershipBenefitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipBenefitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload>
          }
          findMany: {
            args: Prisma.MembershipBenefitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload>[]
          }
          create: {
            args: Prisma.MembershipBenefitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload>
          }
          createMany: {
            args: Prisma.MembershipBenefitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipBenefitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload>[]
          }
          delete: {
            args: Prisma.MembershipBenefitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload>
          }
          update: {
            args: Prisma.MembershipBenefitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload>
          }
          deleteMany: {
            args: Prisma.MembershipBenefitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipBenefitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipBenefitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload>[]
          }
          upsert: {
            args: Prisma.MembershipBenefitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipBenefitPayload>
          }
          aggregate: {
            args: Prisma.MembershipBenefitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembershipBenefit>
          }
          groupBy: {
            args: Prisma.MembershipBenefitGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipBenefitGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipBenefitCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipBenefitCountAggregateOutputType> | number
          }
        }
      }
      MembershipUser: {
        payload: Prisma.$MembershipUserPayload<ExtArgs>
        fields: Prisma.MembershipUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload>
          }
          findFirst: {
            args: Prisma.MembershipUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload>
          }
          findMany: {
            args: Prisma.MembershipUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload>[]
          }
          create: {
            args: Prisma.MembershipUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload>
          }
          createMany: {
            args: Prisma.MembershipUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload>[]
          }
          delete: {
            args: Prisma.MembershipUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload>
          }
          update: {
            args: Prisma.MembershipUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload>
          }
          deleteMany: {
            args: Prisma.MembershipUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload>[]
          }
          upsert: {
            args: Prisma.MembershipUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipUserPayload>
          }
          aggregate: {
            args: Prisma.MembershipUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembershipUser>
          }
          groupBy: {
            args: Prisma.MembershipUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipUserCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipUserCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      ClassBooking: {
        payload: Prisma.$ClassBookingPayload<ExtArgs>
        fields: Prisma.ClassBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          findFirst: {
            args: Prisma.ClassBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          findMany: {
            args: Prisma.ClassBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>[]
          }
          create: {
            args: Prisma.ClassBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          createMany: {
            args: Prisma.ClassBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>[]
          }
          delete: {
            args: Prisma.ClassBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          update: {
            args: Prisma.ClassBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          deleteMany: {
            args: Prisma.ClassBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>[]
          }
          upsert: {
            args: Prisma.ClassBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingPayload>
          }
          aggregate: {
            args: Prisma.ClassBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassBooking>
          }
          groupBy: {
            args: Prisma.ClassBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassBookingCountArgs<ExtArgs>
            result: $Utils.Optional<ClassBookingCountAggregateOutputType> | number
          }
        }
      }
      ClassBookingDetail: {
        payload: Prisma.$ClassBookingDetailPayload<ExtArgs>
        fields: Prisma.ClassBookingDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassBookingDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassBookingDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload>
          }
          findFirst: {
            args: Prisma.ClassBookingDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassBookingDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload>
          }
          findMany: {
            args: Prisma.ClassBookingDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload>[]
          }
          create: {
            args: Prisma.ClassBookingDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload>
          }
          createMany: {
            args: Prisma.ClassBookingDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassBookingDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload>[]
          }
          delete: {
            args: Prisma.ClassBookingDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload>
          }
          update: {
            args: Prisma.ClassBookingDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload>
          }
          deleteMany: {
            args: Prisma.ClassBookingDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassBookingDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassBookingDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload>[]
          }
          upsert: {
            args: Prisma.ClassBookingDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassBookingDetailPayload>
          }
          aggregate: {
            args: Prisma.ClassBookingDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassBookingDetail>
          }
          groupBy: {
            args: Prisma.ClassBookingDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassBookingDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassBookingDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ClassBookingDetailCountAggregateOutputType> | number
          }
        }
      }
      Club: {
        payload: Prisma.$ClubPayload<ExtArgs>
        fields: Prisma.ClubFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          findFirst: {
            args: Prisma.ClubFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          findMany: {
            args: Prisma.ClubFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>[]
          }
          create: {
            args: Prisma.ClubCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          createMany: {
            args: Prisma.ClubCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>[]
          }
          delete: {
            args: Prisma.ClubDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          update: {
            args: Prisma.ClubUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          deleteMany: {
            args: Prisma.ClubDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>[]
          }
          upsert: {
            args: Prisma.ClubUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubPayload>
          }
          aggregate: {
            args: Prisma.ClubAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClub>
          }
          groupBy: {
            args: Prisma.ClubGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubCountArgs<ExtArgs>
            result: $Utils.Optional<ClubCountAggregateOutputType> | number
          }
        }
      }
      ClubMember: {
        payload: Prisma.$ClubMemberPayload<ExtArgs>
        fields: Prisma.ClubMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClubMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClubMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload>
          }
          findFirst: {
            args: Prisma.ClubMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClubMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload>
          }
          findMany: {
            args: Prisma.ClubMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload>[]
          }
          create: {
            args: Prisma.ClubMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload>
          }
          createMany: {
            args: Prisma.ClubMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClubMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload>[]
          }
          delete: {
            args: Prisma.ClubMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload>
          }
          update: {
            args: Prisma.ClubMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload>
          }
          deleteMany: {
            args: Prisma.ClubMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClubMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClubMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload>[]
          }
          upsert: {
            args: Prisma.ClubMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClubMemberPayload>
          }
          aggregate: {
            args: Prisma.ClubMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClubMember>
          }
          groupBy: {
            args: Prisma.ClubMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClubMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClubMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ClubMemberCountAggregateOutputType> | number
          }
        }
      }
      Tournament: {
        payload: Prisma.$TournamentPayload<ExtArgs>
        fields: Prisma.TournamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findFirst: {
            args: Prisma.TournamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findMany: {
            args: Prisma.TournamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          create: {
            args: Prisma.TournamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          createMany: {
            args: Prisma.TournamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          delete: {
            args: Prisma.TournamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          update: {
            args: Prisma.TournamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          deleteMany: {
            args: Prisma.TournamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TournamentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          upsert: {
            args: Prisma.TournamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          aggregate: {
            args: Prisma.TournamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament>
          }
          groupBy: {
            args: Prisma.TournamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentCountAggregateOutputType> | number
          }
        }
      }
      TournamentRegistration: {
        payload: Prisma.$TournamentRegistrationPayload<ExtArgs>
        fields: Prisma.TournamentRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload>
          }
          findFirst: {
            args: Prisma.TournamentRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload>
          }
          findMany: {
            args: Prisma.TournamentRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload>[]
          }
          create: {
            args: Prisma.TournamentRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload>
          }
          createMany: {
            args: Prisma.TournamentRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload>[]
          }
          delete: {
            args: Prisma.TournamentRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload>
          }
          update: {
            args: Prisma.TournamentRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.TournamentRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TournamentRegistrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload>[]
          }
          upsert: {
            args: Prisma.TournamentRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationPayload>
          }
          aggregate: {
            args: Prisma.TournamentRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamentRegistration>
          }
          groupBy: {
            args: Prisma.TournamentRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentRegistrationCountAggregateOutputType> | number
          }
        }
      }
      TournamentRegistrationMember: {
        payload: Prisma.$TournamentRegistrationMemberPayload<ExtArgs>
        fields: Prisma.TournamentRegistrationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentRegistrationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentRegistrationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload>
          }
          findFirst: {
            args: Prisma.TournamentRegistrationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentRegistrationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload>
          }
          findMany: {
            args: Prisma.TournamentRegistrationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload>[]
          }
          create: {
            args: Prisma.TournamentRegistrationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload>
          }
          createMany: {
            args: Prisma.TournamentRegistrationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentRegistrationMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload>[]
          }
          delete: {
            args: Prisma.TournamentRegistrationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload>
          }
          update: {
            args: Prisma.TournamentRegistrationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload>
          }
          deleteMany: {
            args: Prisma.TournamentRegistrationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentRegistrationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TournamentRegistrationMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload>[]
          }
          upsert: {
            args: Prisma.TournamentRegistrationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentRegistrationMemberPayload>
          }
          aggregate: {
            args: Prisma.TournamentRegistrationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamentRegistrationMember>
          }
          groupBy: {
            args: Prisma.TournamentRegistrationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentRegistrationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentRegistrationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentRegistrationMemberCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    phoneVerification?: PhoneVerificationOmit
    staff?: StaffOmit
    authToken?: AuthTokenOmit
    banner?: BannerOmit
    court?: CourtOmit
    inventory?: InventoryOmit
    slot?: SlotOmit
    courtCostSchedule?: CourtCostScheduleOmit
    paymentMethod?: PaymentMethodOmit
    payment?: PaymentOmit
    invoice?: InvoiceOmit
    booking?: BookingOmit
    bookingDetail?: BookingDetailOmit
    bookingInventory?: BookingInventoryOmit
    bookingBallboy?: BookingBallboyOmit
    bookingCoachType?: BookingCoachTypeOmit
    coachTypeStaffPrice?: CoachTypeStaffPriceOmit
    bookingCoach?: BookingCoachOmit
    membership?: MembershipOmit
    membershipBenefit?: MembershipBenefitOmit
    membershipUser?: MembershipUserOmit
    class?: ClassOmit
    classBooking?: ClassBookingOmit
    classBookingDetail?: ClassBookingDetailOmit
    club?: ClubOmit
    clubMember?: ClubMemberOmit
    tournament?: TournamentOmit
    tournamentRegistration?: TournamentRegistrationOmit
    tournamentRegistrationMember?: TournamentRegistrationMemberOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    authTokens: number
    bookings: number
    membershipUser: number
    classBookings: number
    clubsLed: number
    clubMember: number
    tournamentRegistrationMember: number
    invoice: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authTokens?: boolean | UserCountOutputTypeCountAuthTokensArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    membershipUser?: boolean | UserCountOutputTypeCountMembershipUserArgs
    classBookings?: boolean | UserCountOutputTypeCountClassBookingsArgs
    clubsLed?: boolean | UserCountOutputTypeCountClubsLedArgs
    clubMember?: boolean | UserCountOutputTypeCountClubMemberArgs
    tournamentRegistrationMember?: boolean | UserCountOutputTypeCountTournamentRegistrationMemberArgs
    invoice?: boolean | UserCountOutputTypeCountInvoiceArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClubsLedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClubMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTournamentRegistrationMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentRegistrationMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type StaffCountOutputType
   */

  export type StaffCountOutputType = {
    authTokens: number
    slot: number
    coachTypeStaffPrice: number
  }

  export type StaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authTokens?: boolean | StaffCountOutputTypeCountAuthTokensArgs
    slot?: boolean | StaffCountOutputTypeCountSlotArgs
    coachTypeStaffPrice?: boolean | StaffCountOutputTypeCountCoachTypeStaffPriceArgs
  }

  // Custom InputTypes
  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffCountOutputType
     */
    select?: StaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountAuthTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthTokenWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlotWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountCoachTypeStaffPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachTypeStaffPriceWhereInput
  }


  /**
   * Count Type CourtCountOutputType
   */

  export type CourtCountOutputType = {
    costSchedules: number
    bookingDetail: number
    slot: number
  }

  export type CourtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costSchedules?: boolean | CourtCountOutputTypeCountCostSchedulesArgs
    bookingDetail?: boolean | CourtCountOutputTypeCountBookingDetailArgs
    slot?: boolean | CourtCountOutputTypeCountSlotArgs
  }

  // Custom InputTypes
  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCountOutputType
     */
    select?: CourtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeCountCostSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtCostScheduleWhereInput
  }

  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeCountBookingDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingDetailWhereInput
  }

  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeCountSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlotWhereInput
  }


  /**
   * Count Type InventoryCountOutputType
   */

  export type InventoryCountOutputType = {
    bookingInventory: number
  }

  export type InventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingInventory?: boolean | InventoryCountOutputTypeCountBookingInventoryArgs
  }

  // Custom InputTypes
  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     */
    select?: InventoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountBookingInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingInventoryWhereInput
  }


  /**
   * Count Type SlotCountOutputType
   */

  export type SlotCountOutputType = {
    bookingDetails: number
    bookingCoaches: number
    bookingBallboys: number
  }

  export type SlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingDetails?: boolean | SlotCountOutputTypeCountBookingDetailsArgs
    bookingCoaches?: boolean | SlotCountOutputTypeCountBookingCoachesArgs
    bookingBallboys?: boolean | SlotCountOutputTypeCountBookingBallboysArgs
  }

  // Custom InputTypes
  /**
   * SlotCountOutputType without action
   */
  export type SlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlotCountOutputType
     */
    select?: SlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SlotCountOutputType without action
   */
  export type SlotCountOutputTypeCountBookingDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingDetailWhereInput
  }

  /**
   * SlotCountOutputType without action
   */
  export type SlotCountOutputTypeCountBookingCoachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingCoachWhereInput
  }

  /**
   * SlotCountOutputType without action
   */
  export type SlotCountOutputTypeCountBookingBallboysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingBallboyWhereInput
  }


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    payments: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentMethodCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    details: number
    inventories: number
    ballboys: number
    coaches: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | BookingCountOutputTypeCountDetailsArgs
    inventories?: boolean | BookingCountOutputTypeCountInventoriesArgs
    ballboys?: boolean | BookingCountOutputTypeCountBallboysArgs
    coaches?: boolean | BookingCountOutputTypeCountCoachesArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingDetailWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountInventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingInventoryWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountBallboysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingBallboyWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountCoachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingCoachWhereInput
  }


  /**
   * Count Type BookingCoachTypeCountOutputType
   */

  export type BookingCoachTypeCountOutputType = {
    bookingCoach: number
    coachTypeStaffPrice: number
  }

  export type BookingCoachTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingCoach?: boolean | BookingCoachTypeCountOutputTypeCountBookingCoachArgs
    coachTypeStaffPrice?: boolean | BookingCoachTypeCountOutputTypeCountCoachTypeStaffPriceArgs
  }

  // Custom InputTypes
  /**
   * BookingCoachTypeCountOutputType without action
   */
  export type BookingCoachTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachTypeCountOutputType
     */
    select?: BookingCoachTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCoachTypeCountOutputType without action
   */
  export type BookingCoachTypeCountOutputTypeCountBookingCoachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingCoachWhereInput
  }

  /**
   * BookingCoachTypeCountOutputType without action
   */
  export type BookingCoachTypeCountOutputTypeCountCoachTypeStaffPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachTypeStaffPriceWhereInput
  }


  /**
   * Count Type MembershipCountOutputType
   */

  export type MembershipCountOutputType = {
    benefits: number
    membershipUser: number
  }

  export type MembershipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benefits?: boolean | MembershipCountOutputTypeCountBenefitsArgs
    membershipUser?: boolean | MembershipCountOutputTypeCountMembershipUserArgs
  }

  // Custom InputTypes
  /**
   * MembershipCountOutputType without action
   */
  export type MembershipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipCountOutputType
     */
    select?: MembershipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MembershipCountOutputType without action
   */
  export type MembershipCountOutputTypeCountBenefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipBenefitWhereInput
  }

  /**
   * MembershipCountOutputType without action
   */
  export type MembershipCountOutputTypeCountMembershipUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipUserWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    classBookings: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classBookings?: boolean | ClassCountOutputTypeCountClassBookingsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountClassBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassBookingWhereInput
  }


  /**
   * Count Type ClassBookingCountOutputType
   */

  export type ClassBookingCountOutputType = {
    details: number
  }

  export type ClassBookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | ClassBookingCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes
  /**
   * ClassBookingCountOutputType without action
   */
  export type ClassBookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingCountOutputType
     */
    select?: ClassBookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassBookingCountOutputType without action
   */
  export type ClassBookingCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassBookingDetailWhereInput
  }


  /**
   * Count Type ClubCountOutputType
   */

  export type ClubCountOutputType = {
    clubMember: number
    tournamentRegistration: number
  }

  export type ClubCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clubMember?: boolean | ClubCountOutputTypeCountClubMemberArgs
    tournamentRegistration?: boolean | ClubCountOutputTypeCountTournamentRegistrationArgs
  }

  // Custom InputTypes
  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubCountOutputType
     */
    select?: ClubCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountClubMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubMemberWhereInput
  }

  /**
   * ClubCountOutputType without action
   */
  export type ClubCountOutputTypeCountTournamentRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentRegistrationWhereInput
  }


  /**
   * Count Type TournamentCountOutputType
   */

  export type TournamentCountOutputType = {
    tournamentRegistration: number
  }

  export type TournamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournamentRegistration?: boolean | TournamentCountOutputTypeCountTournamentRegistrationArgs
  }

  // Custom InputTypes
  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentCountOutputType
     */
    select?: TournamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountTournamentRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentRegistrationWhereInput
  }


  /**
   * Count Type TournamentRegistrationCountOutputType
   */

  export type TournamentRegistrationCountOutputType = {
    membersRef: number
  }

  export type TournamentRegistrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membersRef?: boolean | TournamentRegistrationCountOutputTypeCountMembersRefArgs
  }

  // Custom InputTypes
  /**
   * TournamentRegistrationCountOutputType without action
   */
  export type TournamentRegistrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationCountOutputType
     */
    select?: TournamentRegistrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentRegistrationCountOutputType without action
   */
  export type TournamentRegistrationCountOutputTypeCountMembersRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentRegistrationMemberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    password: string | null
    image: string | null
    googleId: string | null
    phone: string | null
    phoneVerified: boolean | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    password: string | null
    image: string | null
    googleId: string | null
    phone: string | null
    phoneVerified: boolean | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    password: number
    image: number
    googleId: number
    phone: number
    phoneVerified: number
    banned: number
    banReason: number
    banExpires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    googleId?: true
    phone?: true
    phoneVerified?: true
    banned?: true
    banReason?: true
    banExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    googleId?: true
    phone?: true
    phoneVerified?: true
    banned?: true
    banReason?: true
    banExpires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    googleId?: true
    phone?: true
    phoneVerified?: true
    banned?: true
    banReason?: true
    banExpires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string | null
    emailVerified: boolean
    password: string | null
    image: string | null
    googleId: string | null
    phone: string
    phoneVerified: boolean
    banned: boolean
    banReason: string | null
    banExpires: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    googleId?: boolean
    phone?: boolean
    phoneVerified?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authTokens?: boolean | User$authTokensArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    membershipUser?: boolean | User$membershipUserArgs<ExtArgs>
    classBookings?: boolean | User$classBookingsArgs<ExtArgs>
    clubsLed?: boolean | User$clubsLedArgs<ExtArgs>
    clubMember?: boolean | User$clubMemberArgs<ExtArgs>
    tournamentRegistrationMember?: boolean | User$tournamentRegistrationMemberArgs<ExtArgs>
    invoice?: boolean | User$invoiceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    googleId?: boolean
    phone?: boolean
    phoneVerified?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    googleId?: boolean
    phone?: boolean
    phoneVerified?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    googleId?: boolean
    phone?: boolean
    phoneVerified?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "password" | "image" | "googleId" | "phone" | "phoneVerified" | "banned" | "banReason" | "banExpires" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authTokens?: boolean | User$authTokensArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    membershipUser?: boolean | User$membershipUserArgs<ExtArgs>
    classBookings?: boolean | User$classBookingsArgs<ExtArgs>
    clubsLed?: boolean | User$clubsLedArgs<ExtArgs>
    clubMember?: boolean | User$clubMemberArgs<ExtArgs>
    tournamentRegistrationMember?: boolean | User$tournamentRegistrationMemberArgs<ExtArgs>
    invoice?: boolean | User$invoiceArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      authTokens: Prisma.$AuthTokenPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      membershipUser: Prisma.$MembershipUserPayload<ExtArgs>[]
      classBookings: Prisma.$ClassBookingPayload<ExtArgs>[]
      clubsLed: Prisma.$ClubPayload<ExtArgs>[]
      clubMember: Prisma.$ClubMemberPayload<ExtArgs>[]
      tournamentRegistrationMember: Prisma.$TournamentRegistrationMemberPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      emailVerified: boolean
      password: string | null
      image: string | null
      googleId: string | null
      phone: string
      phoneVerified: boolean
      banned: boolean
      banReason: string | null
      banExpires: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    authTokens<T extends User$authTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$authTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    membershipUser<T extends User$membershipUserArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classBookings<T extends User$classBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$classBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clubsLed<T extends User$clubsLedArgs<ExtArgs> = {}>(args?: Subset<T, User$clubsLedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clubMember<T extends User$clubMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$clubMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournamentRegistrationMember<T extends User$tournamentRegistrationMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$tournamentRegistrationMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends User$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, User$invoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly banned: FieldRef<"User", 'Boolean'>
    readonly banReason: FieldRef<"User", 'String'>
    readonly banExpires: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.authTokens
   */
  export type User$authTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    where?: AuthTokenWhereInput
    orderBy?: AuthTokenOrderByWithRelationInput | AuthTokenOrderByWithRelationInput[]
    cursor?: AuthTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthTokenScalarFieldEnum | AuthTokenScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.membershipUser
   */
  export type User$membershipUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    where?: MembershipUserWhereInput
    orderBy?: MembershipUserOrderByWithRelationInput | MembershipUserOrderByWithRelationInput[]
    cursor?: MembershipUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipUserScalarFieldEnum | MembershipUserScalarFieldEnum[]
  }

  /**
   * User.classBookings
   */
  export type User$classBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    where?: ClassBookingWhereInput
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    cursor?: ClassBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassBookingScalarFieldEnum | ClassBookingScalarFieldEnum[]
  }

  /**
   * User.clubsLed
   */
  export type User$clubsLedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    where?: ClubWhereInput
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    cursor?: ClubWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * User.clubMember
   */
  export type User$clubMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    where?: ClubMemberWhereInput
    orderBy?: ClubMemberOrderByWithRelationInput | ClubMemberOrderByWithRelationInput[]
    cursor?: ClubMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubMemberScalarFieldEnum | ClubMemberScalarFieldEnum[]
  }

  /**
   * User.tournamentRegistrationMember
   */
  export type User$tournamentRegistrationMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    where?: TournamentRegistrationMemberWhereInput
    orderBy?: TournamentRegistrationMemberOrderByWithRelationInput | TournamentRegistrationMemberOrderByWithRelationInput[]
    cursor?: TournamentRegistrationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentRegistrationMemberScalarFieldEnum | TournamentRegistrationMemberScalarFieldEnum[]
  }

  /**
   * User.invoice
   */
  export type User$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model PhoneVerification
   */

  export type AggregatePhoneVerification = {
    _count: PhoneVerificationCountAggregateOutputType | null
    _min: PhoneVerificationMinAggregateOutputType | null
    _max: PhoneVerificationMaxAggregateOutputType | null
  }

  export type PhoneVerificationMinAggregateOutputType = {
    id: string | null
    phone: string | null
    type: $Enums.PhoneVerificationType | null
    code: string | null
    expiresAt: Date | null
    requestId: string | null
    isUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhoneVerificationMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    type: $Enums.PhoneVerificationType | null
    code: string | null
    expiresAt: Date | null
    requestId: string | null
    isUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhoneVerificationCountAggregateOutputType = {
    id: number
    phone: number
    type: number
    code: number
    expiresAt: number
    requestId: number
    isUsed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhoneVerificationMinAggregateInputType = {
    id?: true
    phone?: true
    type?: true
    code?: true
    expiresAt?: true
    requestId?: true
    isUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhoneVerificationMaxAggregateInputType = {
    id?: true
    phone?: true
    type?: true
    code?: true
    expiresAt?: true
    requestId?: true
    isUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhoneVerificationCountAggregateInputType = {
    id?: true
    phone?: true
    type?: true
    code?: true
    expiresAt?: true
    requestId?: true
    isUsed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhoneVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneVerification to aggregate.
     */
    where?: PhoneVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerifications to fetch.
     */
    orderBy?: PhoneVerificationOrderByWithRelationInput | PhoneVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhoneVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhoneVerifications
    **/
    _count?: true | PhoneVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneVerificationMaxAggregateInputType
  }

  export type GetPhoneVerificationAggregateType<T extends PhoneVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoneVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoneVerification[P]>
      : GetScalarType<T[P], AggregatePhoneVerification[P]>
  }




  export type PhoneVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhoneVerificationWhereInput
    orderBy?: PhoneVerificationOrderByWithAggregationInput | PhoneVerificationOrderByWithAggregationInput[]
    by: PhoneVerificationScalarFieldEnum[] | PhoneVerificationScalarFieldEnum
    having?: PhoneVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneVerificationCountAggregateInputType | true
    _min?: PhoneVerificationMinAggregateInputType
    _max?: PhoneVerificationMaxAggregateInputType
  }

  export type PhoneVerificationGroupByOutputType = {
    id: string
    phone: string
    type: $Enums.PhoneVerificationType | null
    code: string
    expiresAt: Date
    requestId: string
    isUsed: boolean
    createdAt: Date
    updatedAt: Date
    _count: PhoneVerificationCountAggregateOutputType | null
    _min: PhoneVerificationMinAggregateOutputType | null
    _max: PhoneVerificationMaxAggregateOutputType | null
  }

  type GetPhoneVerificationGroupByPayload<T extends PhoneVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhoneVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneVerificationGroupByOutputType[P]>
        }
      >
    >


  export type PhoneVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    type?: boolean
    code?: boolean
    expiresAt?: boolean
    requestId?: boolean
    isUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["phoneVerification"]>

  export type PhoneVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    type?: boolean
    code?: boolean
    expiresAt?: boolean
    requestId?: boolean
    isUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["phoneVerification"]>

  export type PhoneVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    type?: boolean
    code?: boolean
    expiresAt?: boolean
    requestId?: boolean
    isUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["phoneVerification"]>

  export type PhoneVerificationSelectScalar = {
    id?: boolean
    phone?: boolean
    type?: boolean
    code?: boolean
    expiresAt?: boolean
    requestId?: boolean
    isUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PhoneVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone" | "type" | "code" | "expiresAt" | "requestId" | "isUsed" | "createdAt" | "updatedAt", ExtArgs["result"]["phoneVerification"]>

  export type $PhoneVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhoneVerification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone: string
      type: $Enums.PhoneVerificationType | null
      code: string
      expiresAt: Date
      requestId: string
      isUsed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["phoneVerification"]>
    composites: {}
  }

  type PhoneVerificationGetPayload<S extends boolean | null | undefined | PhoneVerificationDefaultArgs> = $Result.GetResult<Prisma.$PhoneVerificationPayload, S>

  type PhoneVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhoneVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhoneVerificationCountAggregateInputType | true
    }

  export interface PhoneVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhoneVerification'], meta: { name: 'PhoneVerification' } }
    /**
     * Find zero or one PhoneVerification that matches the filter.
     * @param {PhoneVerificationFindUniqueArgs} args - Arguments to find a PhoneVerification
     * @example
     * // Get one PhoneVerification
     * const phoneVerification = await prisma.phoneVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhoneVerificationFindUniqueArgs>(args: SelectSubset<T, PhoneVerificationFindUniqueArgs<ExtArgs>>): Prisma__PhoneVerificationClient<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhoneVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhoneVerificationFindUniqueOrThrowArgs} args - Arguments to find a PhoneVerification
     * @example
     * // Get one PhoneVerification
     * const phoneVerification = await prisma.phoneVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhoneVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, PhoneVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhoneVerificationClient<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhoneVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationFindFirstArgs} args - Arguments to find a PhoneVerification
     * @example
     * // Get one PhoneVerification
     * const phoneVerification = await prisma.phoneVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhoneVerificationFindFirstArgs>(args?: SelectSubset<T, PhoneVerificationFindFirstArgs<ExtArgs>>): Prisma__PhoneVerificationClient<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhoneVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationFindFirstOrThrowArgs} args - Arguments to find a PhoneVerification
     * @example
     * // Get one PhoneVerification
     * const phoneVerification = await prisma.phoneVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhoneVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, PhoneVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhoneVerificationClient<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhoneVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhoneVerifications
     * const phoneVerifications = await prisma.phoneVerification.findMany()
     * 
     * // Get first 10 PhoneVerifications
     * const phoneVerifications = await prisma.phoneVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phoneVerificationWithIdOnly = await prisma.phoneVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhoneVerificationFindManyArgs>(args?: SelectSubset<T, PhoneVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhoneVerification.
     * @param {PhoneVerificationCreateArgs} args - Arguments to create a PhoneVerification.
     * @example
     * // Create one PhoneVerification
     * const PhoneVerification = await prisma.phoneVerification.create({
     *   data: {
     *     // ... data to create a PhoneVerification
     *   }
     * })
     * 
     */
    create<T extends PhoneVerificationCreateArgs>(args: SelectSubset<T, PhoneVerificationCreateArgs<ExtArgs>>): Prisma__PhoneVerificationClient<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhoneVerifications.
     * @param {PhoneVerificationCreateManyArgs} args - Arguments to create many PhoneVerifications.
     * @example
     * // Create many PhoneVerifications
     * const phoneVerification = await prisma.phoneVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhoneVerificationCreateManyArgs>(args?: SelectSubset<T, PhoneVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhoneVerifications and returns the data saved in the database.
     * @param {PhoneVerificationCreateManyAndReturnArgs} args - Arguments to create many PhoneVerifications.
     * @example
     * // Create many PhoneVerifications
     * const phoneVerification = await prisma.phoneVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhoneVerifications and only return the `id`
     * const phoneVerificationWithIdOnly = await prisma.phoneVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhoneVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, PhoneVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhoneVerification.
     * @param {PhoneVerificationDeleteArgs} args - Arguments to delete one PhoneVerification.
     * @example
     * // Delete one PhoneVerification
     * const PhoneVerification = await prisma.phoneVerification.delete({
     *   where: {
     *     // ... filter to delete one PhoneVerification
     *   }
     * })
     * 
     */
    delete<T extends PhoneVerificationDeleteArgs>(args: SelectSubset<T, PhoneVerificationDeleteArgs<ExtArgs>>): Prisma__PhoneVerificationClient<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhoneVerification.
     * @param {PhoneVerificationUpdateArgs} args - Arguments to update one PhoneVerification.
     * @example
     * // Update one PhoneVerification
     * const phoneVerification = await prisma.phoneVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhoneVerificationUpdateArgs>(args: SelectSubset<T, PhoneVerificationUpdateArgs<ExtArgs>>): Prisma__PhoneVerificationClient<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhoneVerifications.
     * @param {PhoneVerificationDeleteManyArgs} args - Arguments to filter PhoneVerifications to delete.
     * @example
     * // Delete a few PhoneVerifications
     * const { count } = await prisma.phoneVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhoneVerificationDeleteManyArgs>(args?: SelectSubset<T, PhoneVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhoneVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhoneVerifications
     * const phoneVerification = await prisma.phoneVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhoneVerificationUpdateManyArgs>(args: SelectSubset<T, PhoneVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhoneVerifications and returns the data updated in the database.
     * @param {PhoneVerificationUpdateManyAndReturnArgs} args - Arguments to update many PhoneVerifications.
     * @example
     * // Update many PhoneVerifications
     * const phoneVerification = await prisma.phoneVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PhoneVerifications and only return the `id`
     * const phoneVerificationWithIdOnly = await prisma.phoneVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhoneVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, PhoneVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PhoneVerification.
     * @param {PhoneVerificationUpsertArgs} args - Arguments to update or create a PhoneVerification.
     * @example
     * // Update or create a PhoneVerification
     * const phoneVerification = await prisma.phoneVerification.upsert({
     *   create: {
     *     // ... data to create a PhoneVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhoneVerification we want to update
     *   }
     * })
     */
    upsert<T extends PhoneVerificationUpsertArgs>(args: SelectSubset<T, PhoneVerificationUpsertArgs<ExtArgs>>): Prisma__PhoneVerificationClient<$Result.GetResult<Prisma.$PhoneVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhoneVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationCountArgs} args - Arguments to filter PhoneVerifications to count.
     * @example
     * // Count the number of PhoneVerifications
     * const count = await prisma.phoneVerification.count({
     *   where: {
     *     // ... the filter for the PhoneVerifications we want to count
     *   }
     * })
    **/
    count<T extends PhoneVerificationCountArgs>(
      args?: Subset<T, PhoneVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhoneVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneVerificationAggregateArgs>(args: Subset<T, PhoneVerificationAggregateArgs>): Prisma.PrismaPromise<GetPhoneVerificationAggregateType<T>>

    /**
     * Group by PhoneVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneVerificationGroupByArgs['orderBy'] }
        : { orderBy?: PhoneVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhoneVerification model
   */
  readonly fields: PhoneVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhoneVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhoneVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhoneVerification model
   */
  interface PhoneVerificationFieldRefs {
    readonly id: FieldRef<"PhoneVerification", 'String'>
    readonly phone: FieldRef<"PhoneVerification", 'String'>
    readonly type: FieldRef<"PhoneVerification", 'PhoneVerificationType'>
    readonly code: FieldRef<"PhoneVerification", 'String'>
    readonly expiresAt: FieldRef<"PhoneVerification", 'DateTime'>
    readonly requestId: FieldRef<"PhoneVerification", 'String'>
    readonly isUsed: FieldRef<"PhoneVerification", 'Boolean'>
    readonly createdAt: FieldRef<"PhoneVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"PhoneVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PhoneVerification findUnique
   */
  export type PhoneVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * Filter, which PhoneVerification to fetch.
     */
    where: PhoneVerificationWhereUniqueInput
  }

  /**
   * PhoneVerification findUniqueOrThrow
   */
  export type PhoneVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * Filter, which PhoneVerification to fetch.
     */
    where: PhoneVerificationWhereUniqueInput
  }

  /**
   * PhoneVerification findFirst
   */
  export type PhoneVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * Filter, which PhoneVerification to fetch.
     */
    where?: PhoneVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerifications to fetch.
     */
    orderBy?: PhoneVerificationOrderByWithRelationInput | PhoneVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneVerifications.
     */
    cursor?: PhoneVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneVerifications.
     */
    distinct?: PhoneVerificationScalarFieldEnum | PhoneVerificationScalarFieldEnum[]
  }

  /**
   * PhoneVerification findFirstOrThrow
   */
  export type PhoneVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * Filter, which PhoneVerification to fetch.
     */
    where?: PhoneVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerifications to fetch.
     */
    orderBy?: PhoneVerificationOrderByWithRelationInput | PhoneVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneVerifications.
     */
    cursor?: PhoneVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneVerifications.
     */
    distinct?: PhoneVerificationScalarFieldEnum | PhoneVerificationScalarFieldEnum[]
  }

  /**
   * PhoneVerification findMany
   */
  export type PhoneVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * Filter, which PhoneVerifications to fetch.
     */
    where?: PhoneVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerifications to fetch.
     */
    orderBy?: PhoneVerificationOrderByWithRelationInput | PhoneVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhoneVerifications.
     */
    cursor?: PhoneVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerifications.
     */
    skip?: number
    distinct?: PhoneVerificationScalarFieldEnum | PhoneVerificationScalarFieldEnum[]
  }

  /**
   * PhoneVerification create
   */
  export type PhoneVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a PhoneVerification.
     */
    data: XOR<PhoneVerificationCreateInput, PhoneVerificationUncheckedCreateInput>
  }

  /**
   * PhoneVerification createMany
   */
  export type PhoneVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhoneVerifications.
     */
    data: PhoneVerificationCreateManyInput | PhoneVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhoneVerification createManyAndReturn
   */
  export type PhoneVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many PhoneVerifications.
     */
    data: PhoneVerificationCreateManyInput | PhoneVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhoneVerification update
   */
  export type PhoneVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a PhoneVerification.
     */
    data: XOR<PhoneVerificationUpdateInput, PhoneVerificationUncheckedUpdateInput>
    /**
     * Choose, which PhoneVerification to update.
     */
    where: PhoneVerificationWhereUniqueInput
  }

  /**
   * PhoneVerification updateMany
   */
  export type PhoneVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhoneVerifications.
     */
    data: XOR<PhoneVerificationUpdateManyMutationInput, PhoneVerificationUncheckedUpdateManyInput>
    /**
     * Filter which PhoneVerifications to update
     */
    where?: PhoneVerificationWhereInput
    /**
     * Limit how many PhoneVerifications to update.
     */
    limit?: number
  }

  /**
   * PhoneVerification updateManyAndReturn
   */
  export type PhoneVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * The data used to update PhoneVerifications.
     */
    data: XOR<PhoneVerificationUpdateManyMutationInput, PhoneVerificationUncheckedUpdateManyInput>
    /**
     * Filter which PhoneVerifications to update
     */
    where?: PhoneVerificationWhereInput
    /**
     * Limit how many PhoneVerifications to update.
     */
    limit?: number
  }

  /**
   * PhoneVerification upsert
   */
  export type PhoneVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the PhoneVerification to update in case it exists.
     */
    where: PhoneVerificationWhereUniqueInput
    /**
     * In case the PhoneVerification found by the `where` argument doesn't exist, create a new PhoneVerification with this data.
     */
    create: XOR<PhoneVerificationCreateInput, PhoneVerificationUncheckedCreateInput>
    /**
     * In case the PhoneVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhoneVerificationUpdateInput, PhoneVerificationUncheckedUpdateInput>
  }

  /**
   * PhoneVerification delete
   */
  export type PhoneVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
    /**
     * Filter which PhoneVerification to delete.
     */
    where: PhoneVerificationWhereUniqueInput
  }

  /**
   * PhoneVerification deleteMany
   */
  export type PhoneVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneVerifications to delete
     */
    where?: PhoneVerificationWhereInput
    /**
     * Limit how many PhoneVerifications to delete.
     */
    limit?: number
  }

  /**
   * PhoneVerification without action
   */
  export type PhoneVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerification
     */
    select?: PhoneVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhoneVerification
     */
    omit?: PhoneVerificationOmit<ExtArgs> | null
  }


  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    image: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    isActive: boolean | null
    joinedAt: Date | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    image: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    isActive: boolean | null
    joinedAt: Date | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    image: number
    name: number
    email: number
    phone: number
    password: number
    isActive: number
    joinedAt: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    image?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    isActive?: true
    joinedAt?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    image?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    isActive?: true
    joinedAt?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    image?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    isActive?: true
    joinedAt?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: string
    image: string | null
    name: string
    email: string
    phone: string | null
    password: string
    isActive: boolean
    joinedAt: Date
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    isActive?: boolean
    joinedAt?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authTokens?: boolean | Staff$authTokensArgs<ExtArgs>
    slot?: boolean | Staff$slotArgs<ExtArgs>
    coachTypeStaffPrice?: boolean | Staff$coachTypeStaffPriceArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    isActive?: boolean
    joinedAt?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    isActive?: boolean
    joinedAt?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    image?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    isActive?: boolean
    joinedAt?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "name" | "email" | "phone" | "password" | "isActive" | "joinedAt" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["staff"]>
  export type StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authTokens?: boolean | Staff$authTokensArgs<ExtArgs>
    slot?: boolean | Staff$slotArgs<ExtArgs>
    coachTypeStaffPrice?: boolean | Staff$coachTypeStaffPriceArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {
      authTokens: Prisma.$AuthTokenPayload<ExtArgs>[]
      slot: Prisma.$SlotPayload<ExtArgs>[]
      coachTypeStaffPrice: Prisma.$CoachTypeStaffPricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string | null
      name: string
      email: string
      phone: string | null
      password: string
      isActive: boolean
      joinedAt: Date
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff and returns the data updated in the database.
     * @param {StaffUpdateManyAndReturnArgs} args - Arguments to update many Staff.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    authTokens<T extends Staff$authTokensArgs<ExtArgs> = {}>(args?: Subset<T, Staff$authTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slot<T extends Staff$slotArgs<ExtArgs> = {}>(args?: Subset<T, Staff$slotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coachTypeStaffPrice<T extends Staff$coachTypeStaffPriceArgs<ExtArgs> = {}>(args?: Subset<T, Staff$coachTypeStaffPriceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'String'>
    readonly image: FieldRef<"Staff", 'String'>
    readonly name: FieldRef<"Staff", 'String'>
    readonly email: FieldRef<"Staff", 'String'>
    readonly phone: FieldRef<"Staff", 'String'>
    readonly password: FieldRef<"Staff", 'String'>
    readonly isActive: FieldRef<"Staff", 'Boolean'>
    readonly joinedAt: FieldRef<"Staff", 'DateTime'>
    readonly role: FieldRef<"Staff", 'Role'>
    readonly createdAt: FieldRef<"Staff", 'DateTime'>
    readonly updatedAt: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff updateManyAndReturn
   */
  export type StaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to delete.
     */
    limit?: number
  }

  /**
   * Staff.authTokens
   */
  export type Staff$authTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    where?: AuthTokenWhereInput
    orderBy?: AuthTokenOrderByWithRelationInput | AuthTokenOrderByWithRelationInput[]
    cursor?: AuthTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthTokenScalarFieldEnum | AuthTokenScalarFieldEnum[]
  }

  /**
   * Staff.slot
   */
  export type Staff$slotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    where?: SlotWhereInput
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    cursor?: SlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * Staff.coachTypeStaffPrice
   */
  export type Staff$coachTypeStaffPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    where?: CoachTypeStaffPriceWhereInput
    orderBy?: CoachTypeStaffPriceOrderByWithRelationInput | CoachTypeStaffPriceOrderByWithRelationInput[]
    cursor?: CoachTypeStaffPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachTypeStaffPriceScalarFieldEnum | CoachTypeStaffPriceScalarFieldEnum[]
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
  }


  /**
   * Model AuthToken
   */

  export type AggregateAuthToken = {
    _count: AuthTokenCountAggregateOutputType | null
    _min: AuthTokenMinAggregateOutputType | null
    _max: AuthTokenMaxAggregateOutputType | null
  }

  export type AuthTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    staffId: string | null
    type: $Enums.AuthTokenType | null
    refreshToken: string | null
    refreshExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    staffId: string | null
    type: $Enums.AuthTokenType | null
    refreshToken: string | null
    refreshExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthTokenCountAggregateOutputType = {
    id: number
    userId: number
    staffId: number
    type: number
    refreshToken: number
    refreshExpiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthTokenMinAggregateInputType = {
    id?: true
    userId?: true
    staffId?: true
    type?: true
    refreshToken?: true
    refreshExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    staffId?: true
    type?: true
    refreshToken?: true
    refreshExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthTokenCountAggregateInputType = {
    id?: true
    userId?: true
    staffId?: true
    type?: true
    refreshToken?: true
    refreshExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthToken to aggregate.
     */
    where?: AuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthTokens to fetch.
     */
    orderBy?: AuthTokenOrderByWithRelationInput | AuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthTokens
    **/
    _count?: true | AuthTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthTokenMaxAggregateInputType
  }

  export type GetAuthTokenAggregateType<T extends AuthTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthToken[P]>
      : GetScalarType<T[P], AggregateAuthToken[P]>
  }




  export type AuthTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthTokenWhereInput
    orderBy?: AuthTokenOrderByWithAggregationInput | AuthTokenOrderByWithAggregationInput[]
    by: AuthTokenScalarFieldEnum[] | AuthTokenScalarFieldEnum
    having?: AuthTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthTokenCountAggregateInputType | true
    _min?: AuthTokenMinAggregateInputType
    _max?: AuthTokenMaxAggregateInputType
  }

  export type AuthTokenGroupByOutputType = {
    id: string
    userId: string | null
    staffId: string | null
    type: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AuthTokenCountAggregateOutputType | null
    _min: AuthTokenMinAggregateOutputType | null
    _max: AuthTokenMaxAggregateOutputType | null
  }

  type GetAuthTokenGroupByPayload<T extends AuthTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthTokenGroupByOutputType[P]>
            : GetScalarType<T[P], AuthTokenGroupByOutputType[P]>
        }
      >
    >


  export type AuthTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    staffId?: boolean
    type?: boolean
    refreshToken?: boolean
    refreshExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | AuthToken$userArgs<ExtArgs>
    staff?: boolean | AuthToken$staffArgs<ExtArgs>
  }, ExtArgs["result"]["authToken"]>

  export type AuthTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    staffId?: boolean
    type?: boolean
    refreshToken?: boolean
    refreshExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | AuthToken$userArgs<ExtArgs>
    staff?: boolean | AuthToken$staffArgs<ExtArgs>
  }, ExtArgs["result"]["authToken"]>

  export type AuthTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    staffId?: boolean
    type?: boolean
    refreshToken?: boolean
    refreshExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | AuthToken$userArgs<ExtArgs>
    staff?: boolean | AuthToken$staffArgs<ExtArgs>
  }, ExtArgs["result"]["authToken"]>

  export type AuthTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    staffId?: boolean
    type?: boolean
    refreshToken?: boolean
    refreshExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "staffId" | "type" | "refreshToken" | "refreshExpiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["authToken"]>
  export type AuthTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuthToken$userArgs<ExtArgs>
    staff?: boolean | AuthToken$staffArgs<ExtArgs>
  }
  export type AuthTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuthToken$userArgs<ExtArgs>
    staff?: boolean | AuthToken$staffArgs<ExtArgs>
  }
  export type AuthTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuthToken$userArgs<ExtArgs>
    staff?: boolean | AuthToken$staffArgs<ExtArgs>
  }

  export type $AuthTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      staffId: string | null
      type: $Enums.AuthTokenType
      refreshToken: string
      refreshExpiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["authToken"]>
    composites: {}
  }

  type AuthTokenGetPayload<S extends boolean | null | undefined | AuthTokenDefaultArgs> = $Result.GetResult<Prisma.$AuthTokenPayload, S>

  type AuthTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthTokenCountAggregateInputType | true
    }

  export interface AuthTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthToken'], meta: { name: 'AuthToken' } }
    /**
     * Find zero or one AuthToken that matches the filter.
     * @param {AuthTokenFindUniqueArgs} args - Arguments to find a AuthToken
     * @example
     * // Get one AuthToken
     * const authToken = await prisma.authToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthTokenFindUniqueArgs>(args: SelectSubset<T, AuthTokenFindUniqueArgs<ExtArgs>>): Prisma__AuthTokenClient<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuthToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthTokenFindUniqueOrThrowArgs} args - Arguments to find a AuthToken
     * @example
     * // Get one AuthToken
     * const authToken = await prisma.authToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthTokenClient<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthTokenFindFirstArgs} args - Arguments to find a AuthToken
     * @example
     * // Get one AuthToken
     * const authToken = await prisma.authToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthTokenFindFirstArgs>(args?: SelectSubset<T, AuthTokenFindFirstArgs<ExtArgs>>): Prisma__AuthTokenClient<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthTokenFindFirstOrThrowArgs} args - Arguments to find a AuthToken
     * @example
     * // Get one AuthToken
     * const authToken = await prisma.authToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthTokenClient<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuthTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthTokens
     * const authTokens = await prisma.authToken.findMany()
     * 
     * // Get first 10 AuthTokens
     * const authTokens = await prisma.authToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authTokenWithIdOnly = await prisma.authToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthTokenFindManyArgs>(args?: SelectSubset<T, AuthTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuthToken.
     * @param {AuthTokenCreateArgs} args - Arguments to create a AuthToken.
     * @example
     * // Create one AuthToken
     * const AuthToken = await prisma.authToken.create({
     *   data: {
     *     // ... data to create a AuthToken
     *   }
     * })
     * 
     */
    create<T extends AuthTokenCreateArgs>(args: SelectSubset<T, AuthTokenCreateArgs<ExtArgs>>): Prisma__AuthTokenClient<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuthTokens.
     * @param {AuthTokenCreateManyArgs} args - Arguments to create many AuthTokens.
     * @example
     * // Create many AuthTokens
     * const authToken = await prisma.authToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthTokenCreateManyArgs>(args?: SelectSubset<T, AuthTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthTokens and returns the data saved in the database.
     * @param {AuthTokenCreateManyAndReturnArgs} args - Arguments to create many AuthTokens.
     * @example
     * // Create many AuthTokens
     * const authToken = await prisma.authToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthTokens and only return the `id`
     * const authTokenWithIdOnly = await prisma.authToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuthToken.
     * @param {AuthTokenDeleteArgs} args - Arguments to delete one AuthToken.
     * @example
     * // Delete one AuthToken
     * const AuthToken = await prisma.authToken.delete({
     *   where: {
     *     // ... filter to delete one AuthToken
     *   }
     * })
     * 
     */
    delete<T extends AuthTokenDeleteArgs>(args: SelectSubset<T, AuthTokenDeleteArgs<ExtArgs>>): Prisma__AuthTokenClient<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuthToken.
     * @param {AuthTokenUpdateArgs} args - Arguments to update one AuthToken.
     * @example
     * // Update one AuthToken
     * const authToken = await prisma.authToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthTokenUpdateArgs>(args: SelectSubset<T, AuthTokenUpdateArgs<ExtArgs>>): Prisma__AuthTokenClient<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuthTokens.
     * @param {AuthTokenDeleteManyArgs} args - Arguments to filter AuthTokens to delete.
     * @example
     * // Delete a few AuthTokens
     * const { count } = await prisma.authToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthTokenDeleteManyArgs>(args?: SelectSubset<T, AuthTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthTokens
     * const authToken = await prisma.authToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthTokenUpdateManyArgs>(args: SelectSubset<T, AuthTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthTokens and returns the data updated in the database.
     * @param {AuthTokenUpdateManyAndReturnArgs} args - Arguments to update many AuthTokens.
     * @example
     * // Update many AuthTokens
     * const authToken = await prisma.authToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuthTokens and only return the `id`
     * const authTokenWithIdOnly = await prisma.authToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuthToken.
     * @param {AuthTokenUpsertArgs} args - Arguments to update or create a AuthToken.
     * @example
     * // Update or create a AuthToken
     * const authToken = await prisma.authToken.upsert({
     *   create: {
     *     // ... data to create a AuthToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthToken we want to update
     *   }
     * })
     */
    upsert<T extends AuthTokenUpsertArgs>(args: SelectSubset<T, AuthTokenUpsertArgs<ExtArgs>>): Prisma__AuthTokenClient<$Result.GetResult<Prisma.$AuthTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuthTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthTokenCountArgs} args - Arguments to filter AuthTokens to count.
     * @example
     * // Count the number of AuthTokens
     * const count = await prisma.authToken.count({
     *   where: {
     *     // ... the filter for the AuthTokens we want to count
     *   }
     * })
    **/
    count<T extends AuthTokenCountArgs>(
      args?: Subset<T, AuthTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthTokenAggregateArgs>(args: Subset<T, AuthTokenAggregateArgs>): Prisma.PrismaPromise<GetAuthTokenAggregateType<T>>

    /**
     * Group by AuthToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthTokenGroupByArgs['orderBy'] }
        : { orderBy?: AuthTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthToken model
   */
  readonly fields: AuthTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuthToken$userArgs<ExtArgs> = {}>(args?: Subset<T, AuthToken$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staff<T extends AuthToken$staffArgs<ExtArgs> = {}>(args?: Subset<T, AuthToken$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthToken model
   */
  interface AuthTokenFieldRefs {
    readonly id: FieldRef<"AuthToken", 'String'>
    readonly userId: FieldRef<"AuthToken", 'String'>
    readonly staffId: FieldRef<"AuthToken", 'String'>
    readonly type: FieldRef<"AuthToken", 'AuthTokenType'>
    readonly refreshToken: FieldRef<"AuthToken", 'String'>
    readonly refreshExpiresAt: FieldRef<"AuthToken", 'DateTime'>
    readonly createdAt: FieldRef<"AuthToken", 'DateTime'>
    readonly updatedAt: FieldRef<"AuthToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthToken findUnique
   */
  export type AuthTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which AuthToken to fetch.
     */
    where: AuthTokenWhereUniqueInput
  }

  /**
   * AuthToken findUniqueOrThrow
   */
  export type AuthTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which AuthToken to fetch.
     */
    where: AuthTokenWhereUniqueInput
  }

  /**
   * AuthToken findFirst
   */
  export type AuthTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which AuthToken to fetch.
     */
    where?: AuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthTokens to fetch.
     */
    orderBy?: AuthTokenOrderByWithRelationInput | AuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthTokens.
     */
    cursor?: AuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthTokens.
     */
    distinct?: AuthTokenScalarFieldEnum | AuthTokenScalarFieldEnum[]
  }

  /**
   * AuthToken findFirstOrThrow
   */
  export type AuthTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which AuthToken to fetch.
     */
    where?: AuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthTokens to fetch.
     */
    orderBy?: AuthTokenOrderByWithRelationInput | AuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthTokens.
     */
    cursor?: AuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthTokens.
     */
    distinct?: AuthTokenScalarFieldEnum | AuthTokenScalarFieldEnum[]
  }

  /**
   * AuthToken findMany
   */
  export type AuthTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which AuthTokens to fetch.
     */
    where?: AuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthTokens to fetch.
     */
    orderBy?: AuthTokenOrderByWithRelationInput | AuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthTokens.
     */
    cursor?: AuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthTokens.
     */
    skip?: number
    distinct?: AuthTokenScalarFieldEnum | AuthTokenScalarFieldEnum[]
  }

  /**
   * AuthToken create
   */
  export type AuthTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthToken.
     */
    data: XOR<AuthTokenCreateInput, AuthTokenUncheckedCreateInput>
  }

  /**
   * AuthToken createMany
   */
  export type AuthTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthTokens.
     */
    data: AuthTokenCreateManyInput | AuthTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthToken createManyAndReturn
   */
  export type AuthTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * The data used to create many AuthTokens.
     */
    data: AuthTokenCreateManyInput | AuthTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthToken update
   */
  export type AuthTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthToken.
     */
    data: XOR<AuthTokenUpdateInput, AuthTokenUncheckedUpdateInput>
    /**
     * Choose, which AuthToken to update.
     */
    where: AuthTokenWhereUniqueInput
  }

  /**
   * AuthToken updateMany
   */
  export type AuthTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthTokens.
     */
    data: XOR<AuthTokenUpdateManyMutationInput, AuthTokenUncheckedUpdateManyInput>
    /**
     * Filter which AuthTokens to update
     */
    where?: AuthTokenWhereInput
    /**
     * Limit how many AuthTokens to update.
     */
    limit?: number
  }

  /**
   * AuthToken updateManyAndReturn
   */
  export type AuthTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * The data used to update AuthTokens.
     */
    data: XOR<AuthTokenUpdateManyMutationInput, AuthTokenUncheckedUpdateManyInput>
    /**
     * Filter which AuthTokens to update
     */
    where?: AuthTokenWhereInput
    /**
     * Limit how many AuthTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthToken upsert
   */
  export type AuthTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthToken to update in case it exists.
     */
    where: AuthTokenWhereUniqueInput
    /**
     * In case the AuthToken found by the `where` argument doesn't exist, create a new AuthToken with this data.
     */
    create: XOR<AuthTokenCreateInput, AuthTokenUncheckedCreateInput>
    /**
     * In case the AuthToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthTokenUpdateInput, AuthTokenUncheckedUpdateInput>
  }

  /**
   * AuthToken delete
   */
  export type AuthTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
    /**
     * Filter which AuthToken to delete.
     */
    where: AuthTokenWhereUniqueInput
  }

  /**
   * AuthToken deleteMany
   */
  export type AuthTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthTokens to delete
     */
    where?: AuthTokenWhereInput
    /**
     * Limit how many AuthTokens to delete.
     */
    limit?: number
  }

  /**
   * AuthToken.user
   */
  export type AuthToken$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuthToken.staff
   */
  export type AuthToken$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * AuthToken without action
   */
  export type AuthTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthToken
     */
    select?: AuthTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthToken
     */
    omit?: AuthTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthTokenInclude<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerAvgAggregateOutputType = {
    sequence: number | null
  }

  export type BannerSumAggregateOutputType = {
    sequence: number | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    image: string | null
    link: string | null
    isActive: boolean | null
    startAt: Date | null
    endAt: Date | null
    sequence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    image: string | null
    link: string | null
    isActive: boolean | null
    startAt: Date | null
    endAt: Date | null
    sequence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    image: number
    link: number
    isActive: number
    startAt: number
    endAt: number
    sequence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerAvgAggregateInputType = {
    sequence?: true
  }

  export type BannerSumAggregateInputType = {
    sequence?: true
  }

  export type BannerMinAggregateInputType = {
    id?: true
    image?: true
    link?: true
    isActive?: true
    startAt?: true
    endAt?: true
    sequence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    image?: true
    link?: true
    isActive?: true
    startAt?: true
    endAt?: true
    sequence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    image?: true
    link?: true
    isActive?: true
    startAt?: true
    endAt?: true
    sequence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _avg?: BannerAvgAggregateInputType
    _sum?: BannerSumAggregateInputType
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    image: string
    link: string | null
    isActive: boolean
    startAt: Date | null
    endAt: Date | null
    sequence: number
    createdAt: Date
    updatedAt: Date
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    link?: boolean
    isActive?: boolean
    startAt?: boolean
    endAt?: boolean
    sequence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    link?: boolean
    isActive?: boolean
    startAt?: boolean
    endAt?: boolean
    sequence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    link?: boolean
    isActive?: boolean
    startAt?: boolean
    endAt?: boolean
    sequence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectScalar = {
    id?: boolean
    image?: boolean
    link?: boolean
    isActive?: boolean
    startAt?: boolean
    endAt?: boolean
    sequence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "link" | "isActive" | "startAt" | "endAt" | "sequence" | "createdAt" | "updatedAt", ExtArgs["result"]["banner"]>

  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string
      link: string | null
      isActive: boolean
      startAt: Date | null
      endAt: Date | null
      sequence: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Banners and returns the data saved in the database.
     * @param {BannerCreateManyAndReturnArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BannerCreateManyAndReturnArgs>(args?: SelectSubset<T, BannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners and returns the data updated in the database.
     * @param {BannerUpdateManyAndReturnArgs} args - Arguments to update many Banners.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Banners and only return the `id`
     * const bannerWithIdOnly = await prisma.banner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BannerUpdateManyAndReturnArgs>(args: SelectSubset<T, BannerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'String'>
    readonly image: FieldRef<"Banner", 'String'>
    readonly link: FieldRef<"Banner", 'String'>
    readonly isActive: FieldRef<"Banner", 'Boolean'>
    readonly startAt: FieldRef<"Banner", 'DateTime'>
    readonly endAt: FieldRef<"Banner", 'DateTime'>
    readonly sequence: FieldRef<"Banner", 'Int'>
    readonly createdAt: FieldRef<"Banner", 'DateTime'>
    readonly updatedAt: FieldRef<"Banner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner createManyAndReturn
   */
  export type BannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner updateManyAndReturn
   */
  export type BannerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to delete.
     */
    limit?: number
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
  }


  /**
   * Model Court
   */

  export type AggregateCourt = {
    _count: CourtCountAggregateOutputType | null
    _min: CourtMinAggregateOutputType | null
    _max: CourtMaxAggregateOutputType | null
  }

  export type CourtMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourtMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourtCountAggregateOutputType = {
    id: number
    name: number
    description: number
    image: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourtMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourtMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourtCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Court to aggregate.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courts
    **/
    _count?: true | CourtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourtMaxAggregateInputType
  }

  export type GetCourtAggregateType<T extends CourtAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt[P]>
      : GetScalarType<T[P], AggregateCourt[P]>
  }




  export type CourtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtWhereInput
    orderBy?: CourtOrderByWithAggregationInput | CourtOrderByWithAggregationInput[]
    by: CourtScalarFieldEnum[] | CourtScalarFieldEnum
    having?: CourtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourtCountAggregateInputType | true
    _min?: CourtMinAggregateInputType
    _max?: CourtMaxAggregateInputType
  }

  export type CourtGroupByOutputType = {
    id: string
    name: string
    description: string | null
    image: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CourtCountAggregateOutputType | null
    _min: CourtMinAggregateOutputType | null
    _max: CourtMaxAggregateOutputType | null
  }

  type GetCourtGroupByPayload<T extends CourtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourtGroupByOutputType[P]>
            : GetScalarType<T[P], CourtGroupByOutputType[P]>
        }
      >
    >


  export type CourtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costSchedules?: boolean | Court$costSchedulesArgs<ExtArgs>
    bookingDetail?: boolean | Court$bookingDetailArgs<ExtArgs>
    slot?: boolean | Court$slotArgs<ExtArgs>
    _count?: boolean | CourtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["court"]>

  export type CourtSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["court"]>

  export type CourtSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["court"]>

  export type CourtSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "image" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["court"]>
  export type CourtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costSchedules?: boolean | Court$costSchedulesArgs<ExtArgs>
    bookingDetail?: boolean | Court$bookingDetailArgs<ExtArgs>
    slot?: boolean | Court$slotArgs<ExtArgs>
    _count?: boolean | CourtCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourtIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CourtIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CourtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Court"
    objects: {
      costSchedules: Prisma.$CourtCostSchedulePayload<ExtArgs>[]
      bookingDetail: Prisma.$BookingDetailPayload<ExtArgs>[]
      slot: Prisma.$SlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      image: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["court"]>
    composites: {}
  }

  type CourtGetPayload<S extends boolean | null | undefined | CourtDefaultArgs> = $Result.GetResult<Prisma.$CourtPayload, S>

  type CourtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourtCountAggregateInputType | true
    }

  export interface CourtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Court'], meta: { name: 'Court' } }
    /**
     * Find zero or one Court that matches the filter.
     * @param {CourtFindUniqueArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourtFindUniqueArgs>(args: SelectSubset<T, CourtFindUniqueArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourtFindUniqueOrThrowArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourtFindUniqueOrThrowArgs>(args: SelectSubset<T, CourtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindFirstArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourtFindFirstArgs>(args?: SelectSubset<T, CourtFindFirstArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindFirstOrThrowArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourtFindFirstOrThrowArgs>(args?: SelectSubset<T, CourtFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courts
     * const courts = await prisma.court.findMany()
     * 
     * // Get first 10 Courts
     * const courts = await prisma.court.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courtWithIdOnly = await prisma.court.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourtFindManyArgs>(args?: SelectSubset<T, CourtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court.
     * @param {CourtCreateArgs} args - Arguments to create a Court.
     * @example
     * // Create one Court
     * const Court = await prisma.court.create({
     *   data: {
     *     // ... data to create a Court
     *   }
     * })
     * 
     */
    create<T extends CourtCreateArgs>(args: SelectSubset<T, CourtCreateArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courts.
     * @param {CourtCreateManyArgs} args - Arguments to create many Courts.
     * @example
     * // Create many Courts
     * const court = await prisma.court.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourtCreateManyArgs>(args?: SelectSubset<T, CourtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courts and returns the data saved in the database.
     * @param {CourtCreateManyAndReturnArgs} args - Arguments to create many Courts.
     * @example
     * // Create many Courts
     * const court = await prisma.court.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courts and only return the `id`
     * const courtWithIdOnly = await prisma.court.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourtCreateManyAndReturnArgs>(args?: SelectSubset<T, CourtCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Court.
     * @param {CourtDeleteArgs} args - Arguments to delete one Court.
     * @example
     * // Delete one Court
     * const Court = await prisma.court.delete({
     *   where: {
     *     // ... filter to delete one Court
     *   }
     * })
     * 
     */
    delete<T extends CourtDeleteArgs>(args: SelectSubset<T, CourtDeleteArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court.
     * @param {CourtUpdateArgs} args - Arguments to update one Court.
     * @example
     * // Update one Court
     * const court = await prisma.court.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourtUpdateArgs>(args: SelectSubset<T, CourtUpdateArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courts.
     * @param {CourtDeleteManyArgs} args - Arguments to filter Courts to delete.
     * @example
     * // Delete a few Courts
     * const { count } = await prisma.court.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourtDeleteManyArgs>(args?: SelectSubset<T, CourtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courts
     * const court = await prisma.court.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourtUpdateManyArgs>(args: SelectSubset<T, CourtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courts and returns the data updated in the database.
     * @param {CourtUpdateManyAndReturnArgs} args - Arguments to update many Courts.
     * @example
     * // Update many Courts
     * const court = await prisma.court.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courts and only return the `id`
     * const courtWithIdOnly = await prisma.court.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourtUpdateManyAndReturnArgs>(args: SelectSubset<T, CourtUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Court.
     * @param {CourtUpsertArgs} args - Arguments to update or create a Court.
     * @example
     * // Update or create a Court
     * const court = await prisma.court.upsert({
     *   create: {
     *     // ... data to create a Court
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court we want to update
     *   }
     * })
     */
    upsert<T extends CourtUpsertArgs>(args: SelectSubset<T, CourtUpsertArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCountArgs} args - Arguments to filter Courts to count.
     * @example
     * // Count the number of Courts
     * const count = await prisma.court.count({
     *   where: {
     *     // ... the filter for the Courts we want to count
     *   }
     * })
    **/
    count<T extends CourtCountArgs>(
      args?: Subset<T, CourtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourtAggregateArgs>(args: Subset<T, CourtAggregateArgs>): Prisma.PrismaPromise<GetCourtAggregateType<T>>

    /**
     * Group by Court.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourtGroupByArgs['orderBy'] }
        : { orderBy?: CourtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Court model
   */
  readonly fields: CourtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Court.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costSchedules<T extends Court$costSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Court$costSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingDetail<T extends Court$bookingDetailArgs<ExtArgs> = {}>(args?: Subset<T, Court$bookingDetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slot<T extends Court$slotArgs<ExtArgs> = {}>(args?: Subset<T, Court$slotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Court model
   */
  interface CourtFieldRefs {
    readonly id: FieldRef<"Court", 'String'>
    readonly name: FieldRef<"Court", 'String'>
    readonly description: FieldRef<"Court", 'String'>
    readonly image: FieldRef<"Court", 'String'>
    readonly isActive: FieldRef<"Court", 'Boolean'>
    readonly createdAt: FieldRef<"Court", 'DateTime'>
    readonly updatedAt: FieldRef<"Court", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Court findUnique
   */
  export type CourtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court findUniqueOrThrow
   */
  export type CourtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court findFirst
   */
  export type CourtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courts.
     */
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court findFirstOrThrow
   */
  export type CourtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courts.
     */
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court findMany
   */
  export type CourtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Courts to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court create
   */
  export type CourtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The data needed to create a Court.
     */
    data: XOR<CourtCreateInput, CourtUncheckedCreateInput>
  }

  /**
   * Court createMany
   */
  export type CourtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courts.
     */
    data: CourtCreateManyInput | CourtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Court createManyAndReturn
   */
  export type CourtCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * The data used to create many Courts.
     */
    data: CourtCreateManyInput | CourtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Court update
   */
  export type CourtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The data needed to update a Court.
     */
    data: XOR<CourtUpdateInput, CourtUncheckedUpdateInput>
    /**
     * Choose, which Court to update.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court updateMany
   */
  export type CourtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courts.
     */
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyInput>
    /**
     * Filter which Courts to update
     */
    where?: CourtWhereInput
    /**
     * Limit how many Courts to update.
     */
    limit?: number
  }

  /**
   * Court updateManyAndReturn
   */
  export type CourtUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * The data used to update Courts.
     */
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyInput>
    /**
     * Filter which Courts to update
     */
    where?: CourtWhereInput
    /**
     * Limit how many Courts to update.
     */
    limit?: number
  }

  /**
   * Court upsert
   */
  export type CourtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The filter to search for the Court to update in case it exists.
     */
    where: CourtWhereUniqueInput
    /**
     * In case the Court found by the `where` argument doesn't exist, create a new Court with this data.
     */
    create: XOR<CourtCreateInput, CourtUncheckedCreateInput>
    /**
     * In case the Court was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourtUpdateInput, CourtUncheckedUpdateInput>
  }

  /**
   * Court delete
   */
  export type CourtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter which Court to delete.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court deleteMany
   */
  export type CourtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courts to delete
     */
    where?: CourtWhereInput
    /**
     * Limit how many Courts to delete.
     */
    limit?: number
  }

  /**
   * Court.costSchedules
   */
  export type Court$costSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    where?: CourtCostScheduleWhereInput
    orderBy?: CourtCostScheduleOrderByWithRelationInput | CourtCostScheduleOrderByWithRelationInput[]
    cursor?: CourtCostScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourtCostScheduleScalarFieldEnum | CourtCostScheduleScalarFieldEnum[]
  }

  /**
   * Court.bookingDetail
   */
  export type Court$bookingDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    where?: BookingDetailWhereInput
    orderBy?: BookingDetailOrderByWithRelationInput | BookingDetailOrderByWithRelationInput[]
    cursor?: BookingDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingDetailScalarFieldEnum | BookingDetailScalarFieldEnum[]
  }

  /**
   * Court.slot
   */
  export type Court$slotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    where?: SlotWhereInput
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    cursor?: SlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * Court without action
   */
  export type CourtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventorySumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    quantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    quantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    quantity: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    quantity?: true
  }

  export type InventorySumAggregateInputType = {
    quantity?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    quantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    quantity: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingInventory?: boolean | Inventory$bookingInventoryArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "quantity" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingInventory?: boolean | Inventory$bookingInventoryArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      bookingInventory: Prisma.$BookingInventoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      quantity: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `id`
     * const inventoryWithIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingInventory<T extends Inventory$bookingInventoryArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$bookingInventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'String'>
    readonly name: FieldRef<"Inventory", 'String'>
    readonly description: FieldRef<"Inventory", 'String'>
    readonly quantity: FieldRef<"Inventory", 'Int'>
    readonly isActive: FieldRef<"Inventory", 'Boolean'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory.bookingInventory
   */
  export type Inventory$bookingInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    where?: BookingInventoryWhereInput
    orderBy?: BookingInventoryOrderByWithRelationInput | BookingInventoryOrderByWithRelationInput[]
    cursor?: BookingInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingInventoryScalarFieldEnum | BookingInventoryScalarFieldEnum[]
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model Slot
   */

  export type AggregateSlot = {
    _count: SlotCountAggregateOutputType | null
    _avg: SlotAvgAggregateOutputType | null
    _sum: SlotSumAggregateOutputType | null
    _min: SlotMinAggregateOutputType | null
    _max: SlotMaxAggregateOutputType | null
  }

  export type SlotAvgAggregateOutputType = {
    price: number | null
  }

  export type SlotSumAggregateOutputType = {
    price: number | null
  }

  export type SlotMinAggregateOutputType = {
    id: string | null
    type: $Enums.SlotType | null
    courtId: string | null
    staffId: string | null
    startAt: Date | null
    endAt: Date | null
    price: number | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlotMaxAggregateOutputType = {
    id: string | null
    type: $Enums.SlotType | null
    courtId: string | null
    staffId: string | null
    startAt: Date | null
    endAt: Date | null
    price: number | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlotCountAggregateOutputType = {
    id: number
    type: number
    courtId: number
    staffId: number
    startAt: number
    endAt: number
    price: number
    isAvailable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SlotAvgAggregateInputType = {
    price?: true
  }

  export type SlotSumAggregateInputType = {
    price?: true
  }

  export type SlotMinAggregateInputType = {
    id?: true
    type?: true
    courtId?: true
    staffId?: true
    startAt?: true
    endAt?: true
    price?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlotMaxAggregateInputType = {
    id?: true
    type?: true
    courtId?: true
    staffId?: true
    startAt?: true
    endAt?: true
    price?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlotCountAggregateInputType = {
    id?: true
    type?: true
    courtId?: true
    staffId?: true
    startAt?: true
    endAt?: true
    price?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Slot to aggregate.
     */
    where?: SlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Slots
    **/
    _count?: true | SlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlotMaxAggregateInputType
  }

  export type GetSlotAggregateType<T extends SlotAggregateArgs> = {
        [P in keyof T & keyof AggregateSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlot[P]>
      : GetScalarType<T[P], AggregateSlot[P]>
  }




  export type SlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlotWhereInput
    orderBy?: SlotOrderByWithAggregationInput | SlotOrderByWithAggregationInput[]
    by: SlotScalarFieldEnum[] | SlotScalarFieldEnum
    having?: SlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlotCountAggregateInputType | true
    _avg?: SlotAvgAggregateInputType
    _sum?: SlotSumAggregateInputType
    _min?: SlotMinAggregateInputType
    _max?: SlotMaxAggregateInputType
  }

  export type SlotGroupByOutputType = {
    id: string
    type: $Enums.SlotType
    courtId: string | null
    staffId: string | null
    startAt: Date
    endAt: Date
    price: number
    isAvailable: boolean
    createdAt: Date
    updatedAt: Date
    _count: SlotCountAggregateOutputType | null
    _avg: SlotAvgAggregateOutputType | null
    _sum: SlotSumAggregateOutputType | null
    _min: SlotMinAggregateOutputType | null
    _max: SlotMaxAggregateOutputType | null
  }

  type GetSlotGroupByPayload<T extends SlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlotGroupByOutputType[P]>
            : GetScalarType<T[P], SlotGroupByOutputType[P]>
        }
      >
    >


  export type SlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    courtId?: boolean
    staffId?: boolean
    startAt?: boolean
    endAt?: boolean
    price?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    court?: boolean | Slot$courtArgs<ExtArgs>
    staff?: boolean | Slot$staffArgs<ExtArgs>
    bookingDetails?: boolean | Slot$bookingDetailsArgs<ExtArgs>
    bookingCoaches?: boolean | Slot$bookingCoachesArgs<ExtArgs>
    bookingBallboys?: boolean | Slot$bookingBallboysArgs<ExtArgs>
    _count?: boolean | SlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slot"]>

  export type SlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    courtId?: boolean
    staffId?: boolean
    startAt?: boolean
    endAt?: boolean
    price?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    court?: boolean | Slot$courtArgs<ExtArgs>
    staff?: boolean | Slot$staffArgs<ExtArgs>
  }, ExtArgs["result"]["slot"]>

  export type SlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    courtId?: boolean
    staffId?: boolean
    startAt?: boolean
    endAt?: boolean
    price?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    court?: boolean | Slot$courtArgs<ExtArgs>
    staff?: boolean | Slot$staffArgs<ExtArgs>
  }, ExtArgs["result"]["slot"]>

  export type SlotSelectScalar = {
    id?: boolean
    type?: boolean
    courtId?: boolean
    staffId?: boolean
    startAt?: boolean
    endAt?: boolean
    price?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "courtId" | "staffId" | "startAt" | "endAt" | "price" | "isAvailable" | "createdAt" | "updatedAt", ExtArgs["result"]["slot"]>
  export type SlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    court?: boolean | Slot$courtArgs<ExtArgs>
    staff?: boolean | Slot$staffArgs<ExtArgs>
    bookingDetails?: boolean | Slot$bookingDetailsArgs<ExtArgs>
    bookingCoaches?: boolean | Slot$bookingCoachesArgs<ExtArgs>
    bookingBallboys?: boolean | Slot$bookingBallboysArgs<ExtArgs>
    _count?: boolean | SlotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    court?: boolean | Slot$courtArgs<ExtArgs>
    staff?: boolean | Slot$staffArgs<ExtArgs>
  }
  export type SlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    court?: boolean | Slot$courtArgs<ExtArgs>
    staff?: boolean | Slot$staffArgs<ExtArgs>
  }

  export type $SlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Slot"
    objects: {
      court: Prisma.$CourtPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs> | null
      bookingDetails: Prisma.$BookingDetailPayload<ExtArgs>[]
      bookingCoaches: Prisma.$BookingCoachPayload<ExtArgs>[]
      bookingBallboys: Prisma.$BookingBallboyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.SlotType
      courtId: string | null
      staffId: string | null
      startAt: Date
      endAt: Date
      price: number
      isAvailable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["slot"]>
    composites: {}
  }

  type SlotGetPayload<S extends boolean | null | undefined | SlotDefaultArgs> = $Result.GetResult<Prisma.$SlotPayload, S>

  type SlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SlotCountAggregateInputType | true
    }

  export interface SlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Slot'], meta: { name: 'Slot' } }
    /**
     * Find zero or one Slot that matches the filter.
     * @param {SlotFindUniqueArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SlotFindUniqueArgs>(args: SelectSubset<T, SlotFindUniqueArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Slot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SlotFindUniqueOrThrowArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SlotFindUniqueOrThrowArgs>(args: SelectSubset<T, SlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Slot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotFindFirstArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SlotFindFirstArgs>(args?: SelectSubset<T, SlotFindFirstArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Slot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotFindFirstOrThrowArgs} args - Arguments to find a Slot
     * @example
     * // Get one Slot
     * const slot = await prisma.slot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SlotFindFirstOrThrowArgs>(args?: SelectSubset<T, SlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Slots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Slots
     * const slots = await prisma.slot.findMany()
     * 
     * // Get first 10 Slots
     * const slots = await prisma.slot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slotWithIdOnly = await prisma.slot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SlotFindManyArgs>(args?: SelectSubset<T, SlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Slot.
     * @param {SlotCreateArgs} args - Arguments to create a Slot.
     * @example
     * // Create one Slot
     * const Slot = await prisma.slot.create({
     *   data: {
     *     // ... data to create a Slot
     *   }
     * })
     * 
     */
    create<T extends SlotCreateArgs>(args: SelectSubset<T, SlotCreateArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Slots.
     * @param {SlotCreateManyArgs} args - Arguments to create many Slots.
     * @example
     * // Create many Slots
     * const slot = await prisma.slot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SlotCreateManyArgs>(args?: SelectSubset<T, SlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Slots and returns the data saved in the database.
     * @param {SlotCreateManyAndReturnArgs} args - Arguments to create many Slots.
     * @example
     * // Create many Slots
     * const slot = await prisma.slot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Slots and only return the `id`
     * const slotWithIdOnly = await prisma.slot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SlotCreateManyAndReturnArgs>(args?: SelectSubset<T, SlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Slot.
     * @param {SlotDeleteArgs} args - Arguments to delete one Slot.
     * @example
     * // Delete one Slot
     * const Slot = await prisma.slot.delete({
     *   where: {
     *     // ... filter to delete one Slot
     *   }
     * })
     * 
     */
    delete<T extends SlotDeleteArgs>(args: SelectSubset<T, SlotDeleteArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Slot.
     * @param {SlotUpdateArgs} args - Arguments to update one Slot.
     * @example
     * // Update one Slot
     * const slot = await prisma.slot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SlotUpdateArgs>(args: SelectSubset<T, SlotUpdateArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Slots.
     * @param {SlotDeleteManyArgs} args - Arguments to filter Slots to delete.
     * @example
     * // Delete a few Slots
     * const { count } = await prisma.slot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SlotDeleteManyArgs>(args?: SelectSubset<T, SlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Slots
     * const slot = await prisma.slot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SlotUpdateManyArgs>(args: SelectSubset<T, SlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slots and returns the data updated in the database.
     * @param {SlotUpdateManyAndReturnArgs} args - Arguments to update many Slots.
     * @example
     * // Update many Slots
     * const slot = await prisma.slot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Slots and only return the `id`
     * const slotWithIdOnly = await prisma.slot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SlotUpdateManyAndReturnArgs>(args: SelectSubset<T, SlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Slot.
     * @param {SlotUpsertArgs} args - Arguments to update or create a Slot.
     * @example
     * // Update or create a Slot
     * const slot = await prisma.slot.upsert({
     *   create: {
     *     // ... data to create a Slot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slot we want to update
     *   }
     * })
     */
    upsert<T extends SlotUpsertArgs>(args: SelectSubset<T, SlotUpsertArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Slots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotCountArgs} args - Arguments to filter Slots to count.
     * @example
     * // Count the number of Slots
     * const count = await prisma.slot.count({
     *   where: {
     *     // ... the filter for the Slots we want to count
     *   }
     * })
    **/
    count<T extends SlotCountArgs>(
      args?: Subset<T, SlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlotAggregateArgs>(args: Subset<T, SlotAggregateArgs>): Prisma.PrismaPromise<GetSlotAggregateType<T>>

    /**
     * Group by Slot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SlotGroupByArgs['orderBy'] }
        : { orderBy?: SlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Slot model
   */
  readonly fields: SlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Slot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    court<T extends Slot$courtArgs<ExtArgs> = {}>(args?: Subset<T, Slot$courtArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staff<T extends Slot$staffArgs<ExtArgs> = {}>(args?: Subset<T, Slot$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookingDetails<T extends Slot$bookingDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Slot$bookingDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingCoaches<T extends Slot$bookingCoachesArgs<ExtArgs> = {}>(args?: Subset<T, Slot$bookingCoachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingBallboys<T extends Slot$bookingBallboysArgs<ExtArgs> = {}>(args?: Subset<T, Slot$bookingBallboysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Slot model
   */
  interface SlotFieldRefs {
    readonly id: FieldRef<"Slot", 'String'>
    readonly type: FieldRef<"Slot", 'SlotType'>
    readonly courtId: FieldRef<"Slot", 'String'>
    readonly staffId: FieldRef<"Slot", 'String'>
    readonly startAt: FieldRef<"Slot", 'DateTime'>
    readonly endAt: FieldRef<"Slot", 'DateTime'>
    readonly price: FieldRef<"Slot", 'Int'>
    readonly isAvailable: FieldRef<"Slot", 'Boolean'>
    readonly createdAt: FieldRef<"Slot", 'DateTime'>
    readonly updatedAt: FieldRef<"Slot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Slot findUnique
   */
  export type SlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slot to fetch.
     */
    where: SlotWhereUniqueInput
  }

  /**
   * Slot findUniqueOrThrow
   */
  export type SlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slot to fetch.
     */
    where: SlotWhereUniqueInput
  }

  /**
   * Slot findFirst
   */
  export type SlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slot to fetch.
     */
    where?: SlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Slots.
     */
    cursor?: SlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Slots.
     */
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * Slot findFirstOrThrow
   */
  export type SlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slot to fetch.
     */
    where?: SlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Slots.
     */
    cursor?: SlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Slots.
     */
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * Slot findMany
   */
  export type SlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter, which Slots to fetch.
     */
    where?: SlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Slots to fetch.
     */
    orderBy?: SlotOrderByWithRelationInput | SlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Slots.
     */
    cursor?: SlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Slots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Slots.
     */
    skip?: number
    distinct?: SlotScalarFieldEnum | SlotScalarFieldEnum[]
  }

  /**
   * Slot create
   */
  export type SlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * The data needed to create a Slot.
     */
    data: XOR<SlotCreateInput, SlotUncheckedCreateInput>
  }

  /**
   * Slot createMany
   */
  export type SlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Slots.
     */
    data: SlotCreateManyInput | SlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Slot createManyAndReturn
   */
  export type SlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * The data used to create many Slots.
     */
    data: SlotCreateManyInput | SlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Slot update
   */
  export type SlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * The data needed to update a Slot.
     */
    data: XOR<SlotUpdateInput, SlotUncheckedUpdateInput>
    /**
     * Choose, which Slot to update.
     */
    where: SlotWhereUniqueInput
  }

  /**
   * Slot updateMany
   */
  export type SlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Slots.
     */
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyInput>
    /**
     * Filter which Slots to update
     */
    where?: SlotWhereInput
    /**
     * Limit how many Slots to update.
     */
    limit?: number
  }

  /**
   * Slot updateManyAndReturn
   */
  export type SlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * The data used to update Slots.
     */
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyInput>
    /**
     * Filter which Slots to update
     */
    where?: SlotWhereInput
    /**
     * Limit how many Slots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Slot upsert
   */
  export type SlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * The filter to search for the Slot to update in case it exists.
     */
    where: SlotWhereUniqueInput
    /**
     * In case the Slot found by the `where` argument doesn't exist, create a new Slot with this data.
     */
    create: XOR<SlotCreateInput, SlotUncheckedCreateInput>
    /**
     * In case the Slot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SlotUpdateInput, SlotUncheckedUpdateInput>
  }

  /**
   * Slot delete
   */
  export type SlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
    /**
     * Filter which Slot to delete.
     */
    where: SlotWhereUniqueInput
  }

  /**
   * Slot deleteMany
   */
  export type SlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Slots to delete
     */
    where?: SlotWhereInput
    /**
     * Limit how many Slots to delete.
     */
    limit?: number
  }

  /**
   * Slot.court
   */
  export type Slot$courtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    where?: CourtWhereInput
  }

  /**
   * Slot.staff
   */
  export type Slot$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * Slot.bookingDetails
   */
  export type Slot$bookingDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    where?: BookingDetailWhereInput
    orderBy?: BookingDetailOrderByWithRelationInput | BookingDetailOrderByWithRelationInput[]
    cursor?: BookingDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingDetailScalarFieldEnum | BookingDetailScalarFieldEnum[]
  }

  /**
   * Slot.bookingCoaches
   */
  export type Slot$bookingCoachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    where?: BookingCoachWhereInput
    orderBy?: BookingCoachOrderByWithRelationInput | BookingCoachOrderByWithRelationInput[]
    cursor?: BookingCoachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingCoachScalarFieldEnum | BookingCoachScalarFieldEnum[]
  }

  /**
   * Slot.bookingBallboys
   */
  export type Slot$bookingBallboysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    where?: BookingBallboyWhereInput
    orderBy?: BookingBallboyOrderByWithRelationInput | BookingBallboyOrderByWithRelationInput[]
    cursor?: BookingBallboyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingBallboyScalarFieldEnum | BookingBallboyScalarFieldEnum[]
  }

  /**
   * Slot without action
   */
  export type SlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Slot
     */
    select?: SlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Slot
     */
    omit?: SlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlotInclude<ExtArgs> | null
  }


  /**
   * Model CourtCostSchedule
   */

  export type AggregateCourtCostSchedule = {
    _count: CourtCostScheduleCountAggregateOutputType | null
    _avg: CourtCostScheduleAvgAggregateOutputType | null
    _sum: CourtCostScheduleSumAggregateOutputType | null
    _min: CourtCostScheduleMinAggregateOutputType | null
    _max: CourtCostScheduleMaxAggregateOutputType | null
  }

  export type CourtCostScheduleAvgAggregateOutputType = {
    price: number | null
  }

  export type CourtCostScheduleSumAggregateOutputType = {
    price: number | null
  }

  export type CourtCostScheduleMinAggregateOutputType = {
    id: string | null
    courtId: string | null
    startAt: Date | null
    endAt: Date | null
    price: number | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourtCostScheduleMaxAggregateOutputType = {
    id: string | null
    courtId: string | null
    startAt: Date | null
    endAt: Date | null
    price: number | null
    isAvailable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourtCostScheduleCountAggregateOutputType = {
    id: number
    courtId: number
    startAt: number
    endAt: number
    price: number
    isAvailable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourtCostScheduleAvgAggregateInputType = {
    price?: true
  }

  export type CourtCostScheduleSumAggregateInputType = {
    price?: true
  }

  export type CourtCostScheduleMinAggregateInputType = {
    id?: true
    courtId?: true
    startAt?: true
    endAt?: true
    price?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourtCostScheduleMaxAggregateInputType = {
    id?: true
    courtId?: true
    startAt?: true
    endAt?: true
    price?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourtCostScheduleCountAggregateInputType = {
    id?: true
    courtId?: true
    startAt?: true
    endAt?: true
    price?: true
    isAvailable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourtCostScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourtCostSchedule to aggregate.
     */
    where?: CourtCostScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtCostSchedules to fetch.
     */
    orderBy?: CourtCostScheduleOrderByWithRelationInput | CourtCostScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourtCostScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtCostSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtCostSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourtCostSchedules
    **/
    _count?: true | CourtCostScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourtCostScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourtCostScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourtCostScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourtCostScheduleMaxAggregateInputType
  }

  export type GetCourtCostScheduleAggregateType<T extends CourtCostScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateCourtCostSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourtCostSchedule[P]>
      : GetScalarType<T[P], AggregateCourtCostSchedule[P]>
  }




  export type CourtCostScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtCostScheduleWhereInput
    orderBy?: CourtCostScheduleOrderByWithAggregationInput | CourtCostScheduleOrderByWithAggregationInput[]
    by: CourtCostScheduleScalarFieldEnum[] | CourtCostScheduleScalarFieldEnum
    having?: CourtCostScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourtCostScheduleCountAggregateInputType | true
    _avg?: CourtCostScheduleAvgAggregateInputType
    _sum?: CourtCostScheduleSumAggregateInputType
    _min?: CourtCostScheduleMinAggregateInputType
    _max?: CourtCostScheduleMaxAggregateInputType
  }

  export type CourtCostScheduleGroupByOutputType = {
    id: string
    courtId: string
    startAt: Date
    endAt: Date
    price: number
    isAvailable: boolean
    createdAt: Date
    updatedAt: Date
    _count: CourtCostScheduleCountAggregateOutputType | null
    _avg: CourtCostScheduleAvgAggregateOutputType | null
    _sum: CourtCostScheduleSumAggregateOutputType | null
    _min: CourtCostScheduleMinAggregateOutputType | null
    _max: CourtCostScheduleMaxAggregateOutputType | null
  }

  type GetCourtCostScheduleGroupByPayload<T extends CourtCostScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourtCostScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourtCostScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourtCostScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], CourtCostScheduleGroupByOutputType[P]>
        }
      >
    >


  export type CourtCostScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courtId?: boolean
    startAt?: boolean
    endAt?: boolean
    price?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courtCostSchedule"]>

  export type CourtCostScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courtId?: boolean
    startAt?: boolean
    endAt?: boolean
    price?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courtCostSchedule"]>

  export type CourtCostScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courtId?: boolean
    startAt?: boolean
    endAt?: boolean
    price?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courtCostSchedule"]>

  export type CourtCostScheduleSelectScalar = {
    id?: boolean
    courtId?: boolean
    startAt?: boolean
    endAt?: boolean
    price?: boolean
    isAvailable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourtCostScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courtId" | "startAt" | "endAt" | "price" | "isAvailable" | "createdAt" | "updatedAt", ExtArgs["result"]["courtCostSchedule"]>
  export type CourtCostScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }
  export type CourtCostScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }
  export type CourtCostScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }

  export type $CourtCostSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourtCostSchedule"
    objects: {
      court: Prisma.$CourtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courtId: string
      startAt: Date
      endAt: Date
      price: number
      isAvailable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courtCostSchedule"]>
    composites: {}
  }

  type CourtCostScheduleGetPayload<S extends boolean | null | undefined | CourtCostScheduleDefaultArgs> = $Result.GetResult<Prisma.$CourtCostSchedulePayload, S>

  type CourtCostScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourtCostScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourtCostScheduleCountAggregateInputType | true
    }

  export interface CourtCostScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourtCostSchedule'], meta: { name: 'CourtCostSchedule' } }
    /**
     * Find zero or one CourtCostSchedule that matches the filter.
     * @param {CourtCostScheduleFindUniqueArgs} args - Arguments to find a CourtCostSchedule
     * @example
     * // Get one CourtCostSchedule
     * const courtCostSchedule = await prisma.courtCostSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourtCostScheduleFindUniqueArgs>(args: SelectSubset<T, CourtCostScheduleFindUniqueArgs<ExtArgs>>): Prisma__CourtCostScheduleClient<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourtCostSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourtCostScheduleFindUniqueOrThrowArgs} args - Arguments to find a CourtCostSchedule
     * @example
     * // Get one CourtCostSchedule
     * const courtCostSchedule = await prisma.courtCostSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourtCostScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, CourtCostScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourtCostScheduleClient<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourtCostSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCostScheduleFindFirstArgs} args - Arguments to find a CourtCostSchedule
     * @example
     * // Get one CourtCostSchedule
     * const courtCostSchedule = await prisma.courtCostSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourtCostScheduleFindFirstArgs>(args?: SelectSubset<T, CourtCostScheduleFindFirstArgs<ExtArgs>>): Prisma__CourtCostScheduleClient<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourtCostSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCostScheduleFindFirstOrThrowArgs} args - Arguments to find a CourtCostSchedule
     * @example
     * // Get one CourtCostSchedule
     * const courtCostSchedule = await prisma.courtCostSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourtCostScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, CourtCostScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourtCostScheduleClient<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourtCostSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCostScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourtCostSchedules
     * const courtCostSchedules = await prisma.courtCostSchedule.findMany()
     * 
     * // Get first 10 CourtCostSchedules
     * const courtCostSchedules = await prisma.courtCostSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courtCostScheduleWithIdOnly = await prisma.courtCostSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourtCostScheduleFindManyArgs>(args?: SelectSubset<T, CourtCostScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourtCostSchedule.
     * @param {CourtCostScheduleCreateArgs} args - Arguments to create a CourtCostSchedule.
     * @example
     * // Create one CourtCostSchedule
     * const CourtCostSchedule = await prisma.courtCostSchedule.create({
     *   data: {
     *     // ... data to create a CourtCostSchedule
     *   }
     * })
     * 
     */
    create<T extends CourtCostScheduleCreateArgs>(args: SelectSubset<T, CourtCostScheduleCreateArgs<ExtArgs>>): Prisma__CourtCostScheduleClient<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourtCostSchedules.
     * @param {CourtCostScheduleCreateManyArgs} args - Arguments to create many CourtCostSchedules.
     * @example
     * // Create many CourtCostSchedules
     * const courtCostSchedule = await prisma.courtCostSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourtCostScheduleCreateManyArgs>(args?: SelectSubset<T, CourtCostScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourtCostSchedules and returns the data saved in the database.
     * @param {CourtCostScheduleCreateManyAndReturnArgs} args - Arguments to create many CourtCostSchedules.
     * @example
     * // Create many CourtCostSchedules
     * const courtCostSchedule = await prisma.courtCostSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourtCostSchedules and only return the `id`
     * const courtCostScheduleWithIdOnly = await prisma.courtCostSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourtCostScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, CourtCostScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourtCostSchedule.
     * @param {CourtCostScheduleDeleteArgs} args - Arguments to delete one CourtCostSchedule.
     * @example
     * // Delete one CourtCostSchedule
     * const CourtCostSchedule = await prisma.courtCostSchedule.delete({
     *   where: {
     *     // ... filter to delete one CourtCostSchedule
     *   }
     * })
     * 
     */
    delete<T extends CourtCostScheduleDeleteArgs>(args: SelectSubset<T, CourtCostScheduleDeleteArgs<ExtArgs>>): Prisma__CourtCostScheduleClient<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourtCostSchedule.
     * @param {CourtCostScheduleUpdateArgs} args - Arguments to update one CourtCostSchedule.
     * @example
     * // Update one CourtCostSchedule
     * const courtCostSchedule = await prisma.courtCostSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourtCostScheduleUpdateArgs>(args: SelectSubset<T, CourtCostScheduleUpdateArgs<ExtArgs>>): Prisma__CourtCostScheduleClient<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourtCostSchedules.
     * @param {CourtCostScheduleDeleteManyArgs} args - Arguments to filter CourtCostSchedules to delete.
     * @example
     * // Delete a few CourtCostSchedules
     * const { count } = await prisma.courtCostSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourtCostScheduleDeleteManyArgs>(args?: SelectSubset<T, CourtCostScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourtCostSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCostScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourtCostSchedules
     * const courtCostSchedule = await prisma.courtCostSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourtCostScheduleUpdateManyArgs>(args: SelectSubset<T, CourtCostScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourtCostSchedules and returns the data updated in the database.
     * @param {CourtCostScheduleUpdateManyAndReturnArgs} args - Arguments to update many CourtCostSchedules.
     * @example
     * // Update many CourtCostSchedules
     * const courtCostSchedule = await prisma.courtCostSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourtCostSchedules and only return the `id`
     * const courtCostScheduleWithIdOnly = await prisma.courtCostSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourtCostScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, CourtCostScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourtCostSchedule.
     * @param {CourtCostScheduleUpsertArgs} args - Arguments to update or create a CourtCostSchedule.
     * @example
     * // Update or create a CourtCostSchedule
     * const courtCostSchedule = await prisma.courtCostSchedule.upsert({
     *   create: {
     *     // ... data to create a CourtCostSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourtCostSchedule we want to update
     *   }
     * })
     */
    upsert<T extends CourtCostScheduleUpsertArgs>(args: SelectSubset<T, CourtCostScheduleUpsertArgs<ExtArgs>>): Prisma__CourtCostScheduleClient<$Result.GetResult<Prisma.$CourtCostSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourtCostSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCostScheduleCountArgs} args - Arguments to filter CourtCostSchedules to count.
     * @example
     * // Count the number of CourtCostSchedules
     * const count = await prisma.courtCostSchedule.count({
     *   where: {
     *     // ... the filter for the CourtCostSchedules we want to count
     *   }
     * })
    **/
    count<T extends CourtCostScheduleCountArgs>(
      args?: Subset<T, CourtCostScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourtCostScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourtCostSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCostScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourtCostScheduleAggregateArgs>(args: Subset<T, CourtCostScheduleAggregateArgs>): Prisma.PrismaPromise<GetCourtCostScheduleAggregateType<T>>

    /**
     * Group by CourtCostSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCostScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourtCostScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourtCostScheduleGroupByArgs['orderBy'] }
        : { orderBy?: CourtCostScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourtCostScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourtCostScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourtCostSchedule model
   */
  readonly fields: CourtCostScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourtCostSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourtCostScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    court<T extends CourtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourtDefaultArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourtCostSchedule model
   */
  interface CourtCostScheduleFieldRefs {
    readonly id: FieldRef<"CourtCostSchedule", 'String'>
    readonly courtId: FieldRef<"CourtCostSchedule", 'String'>
    readonly startAt: FieldRef<"CourtCostSchedule", 'DateTime'>
    readonly endAt: FieldRef<"CourtCostSchedule", 'DateTime'>
    readonly price: FieldRef<"CourtCostSchedule", 'Int'>
    readonly isAvailable: FieldRef<"CourtCostSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"CourtCostSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"CourtCostSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourtCostSchedule findUnique
   */
  export type CourtCostScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CourtCostSchedule to fetch.
     */
    where: CourtCostScheduleWhereUniqueInput
  }

  /**
   * CourtCostSchedule findUniqueOrThrow
   */
  export type CourtCostScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CourtCostSchedule to fetch.
     */
    where: CourtCostScheduleWhereUniqueInput
  }

  /**
   * CourtCostSchedule findFirst
   */
  export type CourtCostScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CourtCostSchedule to fetch.
     */
    where?: CourtCostScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtCostSchedules to fetch.
     */
    orderBy?: CourtCostScheduleOrderByWithRelationInput | CourtCostScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourtCostSchedules.
     */
    cursor?: CourtCostScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtCostSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtCostSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourtCostSchedules.
     */
    distinct?: CourtCostScheduleScalarFieldEnum | CourtCostScheduleScalarFieldEnum[]
  }

  /**
   * CourtCostSchedule findFirstOrThrow
   */
  export type CourtCostScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CourtCostSchedule to fetch.
     */
    where?: CourtCostScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtCostSchedules to fetch.
     */
    orderBy?: CourtCostScheduleOrderByWithRelationInput | CourtCostScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourtCostSchedules.
     */
    cursor?: CourtCostScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtCostSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtCostSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourtCostSchedules.
     */
    distinct?: CourtCostScheduleScalarFieldEnum | CourtCostScheduleScalarFieldEnum[]
  }

  /**
   * CourtCostSchedule findMany
   */
  export type CourtCostScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CourtCostSchedules to fetch.
     */
    where?: CourtCostScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtCostSchedules to fetch.
     */
    orderBy?: CourtCostScheduleOrderByWithRelationInput | CourtCostScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourtCostSchedules.
     */
    cursor?: CourtCostScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtCostSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtCostSchedules.
     */
    skip?: number
    distinct?: CourtCostScheduleScalarFieldEnum | CourtCostScheduleScalarFieldEnum[]
  }

  /**
   * CourtCostSchedule create
   */
  export type CourtCostScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a CourtCostSchedule.
     */
    data: XOR<CourtCostScheduleCreateInput, CourtCostScheduleUncheckedCreateInput>
  }

  /**
   * CourtCostSchedule createMany
   */
  export type CourtCostScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourtCostSchedules.
     */
    data: CourtCostScheduleCreateManyInput | CourtCostScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourtCostSchedule createManyAndReturn
   */
  export type CourtCostScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many CourtCostSchedules.
     */
    data: CourtCostScheduleCreateManyInput | CourtCostScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourtCostSchedule update
   */
  export type CourtCostScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a CourtCostSchedule.
     */
    data: XOR<CourtCostScheduleUpdateInput, CourtCostScheduleUncheckedUpdateInput>
    /**
     * Choose, which CourtCostSchedule to update.
     */
    where: CourtCostScheduleWhereUniqueInput
  }

  /**
   * CourtCostSchedule updateMany
   */
  export type CourtCostScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourtCostSchedules.
     */
    data: XOR<CourtCostScheduleUpdateManyMutationInput, CourtCostScheduleUncheckedUpdateManyInput>
    /**
     * Filter which CourtCostSchedules to update
     */
    where?: CourtCostScheduleWhereInput
    /**
     * Limit how many CourtCostSchedules to update.
     */
    limit?: number
  }

  /**
   * CourtCostSchedule updateManyAndReturn
   */
  export type CourtCostScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * The data used to update CourtCostSchedules.
     */
    data: XOR<CourtCostScheduleUpdateManyMutationInput, CourtCostScheduleUncheckedUpdateManyInput>
    /**
     * Filter which CourtCostSchedules to update
     */
    where?: CourtCostScheduleWhereInput
    /**
     * Limit how many CourtCostSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourtCostSchedule upsert
   */
  export type CourtCostScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the CourtCostSchedule to update in case it exists.
     */
    where: CourtCostScheduleWhereUniqueInput
    /**
     * In case the CourtCostSchedule found by the `where` argument doesn't exist, create a new CourtCostSchedule with this data.
     */
    create: XOR<CourtCostScheduleCreateInput, CourtCostScheduleUncheckedCreateInput>
    /**
     * In case the CourtCostSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourtCostScheduleUpdateInput, CourtCostScheduleUncheckedUpdateInput>
  }

  /**
   * CourtCostSchedule delete
   */
  export type CourtCostScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
    /**
     * Filter which CourtCostSchedule to delete.
     */
    where: CourtCostScheduleWhereUniqueInput
  }

  /**
   * CourtCostSchedule deleteMany
   */
  export type CourtCostScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourtCostSchedules to delete
     */
    where?: CourtCostScheduleWhereInput
    /**
     * Limit how many CourtCostSchedules to delete.
     */
    limit?: number
  }

  /**
   * CourtCostSchedule without action
   */
  export type CourtCostScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCostSchedule
     */
    select?: CourtCostScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCostSchedule
     */
    omit?: CourtCostScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCostScheduleInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    fees: number | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    fees: number | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    fees: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    fees: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    fees: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    fees?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    fees?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    fees?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    fees?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    fees?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    name: string
    logo: string | null
    fees: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    fees?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payments?: boolean | PaymentMethod$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    fees?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    fees?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    name?: boolean
    logo?: boolean
    fees?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logo" | "fees" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentMethod$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      logo: string | null
      fees: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends PaymentMethod$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly name: FieldRef<"PaymentMethod", 'String'>
    readonly logo: FieldRef<"PaymentMethod", 'String'>
    readonly fees: FieldRef<"PaymentMethod", 'Int'>
    readonly isActive: FieldRef<"PaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod.payments
   */
  export type PaymentMethod$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
    fees: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
    fees: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    paymentMethodId: string | null
    status: $Enums.PaymentStatus | null
    amount: number | null
    fees: number | null
    externalRef: string | null
    dueDate: Date | null
    paidAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    paymentMethodId: string | null
    status: $Enums.PaymentStatus | null
    amount: number | null
    fees: number | null
    externalRef: string | null
    dueDate: Date | null
    paidAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    paymentMethodId: number
    status: number
    amount: number
    fees: number
    externalRef: number
    meta: number
    dueDate: number
    paidAt: number
    cancelledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    fees?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    fees?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    paymentMethodId?: true
    status?: true
    amount?: true
    fees?: true
    externalRef?: true
    dueDate?: true
    paidAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    paymentMethodId?: true
    status?: true
    amount?: true
    fees?: true
    externalRef?: true
    dueDate?: true
    paidAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    paymentMethodId?: true
    status?: true
    amount?: true
    fees?: true
    externalRef?: true
    meta?: true
    dueDate?: true
    paidAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    paymentMethodId: string
    status: $Enums.PaymentStatus
    amount: number
    fees: number
    externalRef: string | null
    meta: JsonValue | null
    dueDate: Date | null
    paidAt: Date | null
    cancelledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethodId?: boolean
    status?: boolean
    amount?: boolean
    fees?: boolean
    externalRef?: boolean
    meta?: boolean
    dueDate?: boolean
    paidAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    method?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethodId?: boolean
    status?: boolean
    amount?: boolean
    fees?: boolean
    externalRef?: boolean
    meta?: boolean
    dueDate?: boolean
    paidAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    method?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethodId?: boolean
    status?: boolean
    amount?: boolean
    fees?: boolean
    externalRef?: boolean
    meta?: boolean
    dueDate?: boolean
    paidAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    method?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    paymentMethodId?: boolean
    status?: boolean
    amount?: boolean
    fees?: boolean
    externalRef?: boolean
    meta?: boolean
    dueDate?: boolean
    paidAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentMethodId" | "status" | "amount" | "fees" | "externalRef" | "meta" | "dueDate" | "paidAt" | "cancelledAt" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    method?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    method?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    method?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      method: Prisma.$PaymentMethodPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentMethodId: string
      status: $Enums.PaymentStatus
      amount: number
      fees: number
      externalRef: string | null
      meta: Prisma.JsonValue | null
      dueDate: Date | null
      paidAt: Date | null
      cancelledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    method<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly paymentMethodId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly fees: FieldRef<"Payment", 'Int'>
    readonly externalRef: FieldRef<"Payment", 'String'>
    readonly meta: FieldRef<"Payment", 'Json'>
    readonly dueDate: FieldRef<"Payment", 'DateTime'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly cancelledAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    processingFee: number | null
    total: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    processingFee: number | null
    total: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    classBookingId: string | null
    membershipUserId: string | null
    tournamentRegistrationId: string | null
    number: string | null
    userId: string | null
    paymentId: string | null
    subtotal: number | null
    processingFee: number | null
    total: number | null
    status: $Enums.PaymentStatus | null
    issuedAt: Date | null
    dueDate: Date | null
    paidAt: Date | null
    cancelledAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    classBookingId: string | null
    membershipUserId: string | null
    tournamentRegistrationId: string | null
    number: string | null
    userId: string | null
    paymentId: string | null
    subtotal: number | null
    processingFee: number | null
    total: number | null
    status: $Enums.PaymentStatus | null
    issuedAt: Date | null
    dueDate: Date | null
    paidAt: Date | null
    cancelledAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    bookingId: number
    classBookingId: number
    membershipUserId: number
    tournamentRegistrationId: number
    number: number
    userId: number
    paymentId: number
    subtotal: number
    processingFee: number
    total: number
    status: number
    issuedAt: number
    dueDate: number
    paidAt: number
    cancelledAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    processingFee?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    processingFee?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    bookingId?: true
    classBookingId?: true
    membershipUserId?: true
    tournamentRegistrationId?: true
    number?: true
    userId?: true
    paymentId?: true
    subtotal?: true
    processingFee?: true
    total?: true
    status?: true
    issuedAt?: true
    dueDate?: true
    paidAt?: true
    cancelledAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    bookingId?: true
    classBookingId?: true
    membershipUserId?: true
    tournamentRegistrationId?: true
    number?: true
    userId?: true
    paymentId?: true
    subtotal?: true
    processingFee?: true
    total?: true
    status?: true
    issuedAt?: true
    dueDate?: true
    paidAt?: true
    cancelledAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    bookingId?: true
    classBookingId?: true
    membershipUserId?: true
    tournamentRegistrationId?: true
    number?: true
    userId?: true
    paymentId?: true
    subtotal?: true
    processingFee?: true
    total?: true
    status?: true
    issuedAt?: true
    dueDate?: true
    paidAt?: true
    cancelledAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    bookingId: string | null
    classBookingId: string | null
    membershipUserId: string | null
    tournamentRegistrationId: string | null
    number: string
    userId: string
    paymentId: string | null
    subtotal: number
    processingFee: number
    total: number
    status: $Enums.PaymentStatus
    issuedAt: Date
    dueDate: Date
    paidAt: Date | null
    cancelledAt: Date | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    classBookingId?: boolean
    membershipUserId?: boolean
    tournamentRegistrationId?: boolean
    number?: boolean
    userId?: boolean
    paymentId?: boolean
    subtotal?: boolean
    processingFee?: boolean
    total?: boolean
    status?: boolean
    issuedAt?: boolean
    dueDate?: boolean
    paidAt?: boolean
    cancelledAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Invoice$paymentArgs<ExtArgs>
    booking?: boolean | Invoice$bookingArgs<ExtArgs>
    classBooking?: boolean | Invoice$classBookingArgs<ExtArgs>
    membershipUser?: boolean | Invoice$membershipUserArgs<ExtArgs>
    tournamentRegistration?: boolean | Invoice$tournamentRegistrationArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    classBookingId?: boolean
    membershipUserId?: boolean
    tournamentRegistrationId?: boolean
    number?: boolean
    userId?: boolean
    paymentId?: boolean
    subtotal?: boolean
    processingFee?: boolean
    total?: boolean
    status?: boolean
    issuedAt?: boolean
    dueDate?: boolean
    paidAt?: boolean
    cancelledAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Invoice$paymentArgs<ExtArgs>
    booking?: boolean | Invoice$bookingArgs<ExtArgs>
    classBooking?: boolean | Invoice$classBookingArgs<ExtArgs>
    membershipUser?: boolean | Invoice$membershipUserArgs<ExtArgs>
    tournamentRegistration?: boolean | Invoice$tournamentRegistrationArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    classBookingId?: boolean
    membershipUserId?: boolean
    tournamentRegistrationId?: boolean
    number?: boolean
    userId?: boolean
    paymentId?: boolean
    subtotal?: boolean
    processingFee?: boolean
    total?: boolean
    status?: boolean
    issuedAt?: boolean
    dueDate?: boolean
    paidAt?: boolean
    cancelledAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Invoice$paymentArgs<ExtArgs>
    booking?: boolean | Invoice$bookingArgs<ExtArgs>
    classBooking?: boolean | Invoice$classBookingArgs<ExtArgs>
    membershipUser?: boolean | Invoice$membershipUserArgs<ExtArgs>
    tournamentRegistration?: boolean | Invoice$tournamentRegistrationArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    bookingId?: boolean
    classBookingId?: boolean
    membershipUserId?: boolean
    tournamentRegistrationId?: boolean
    number?: boolean
    userId?: boolean
    paymentId?: boolean
    subtotal?: boolean
    processingFee?: boolean
    total?: boolean
    status?: boolean
    issuedAt?: boolean
    dueDate?: boolean
    paidAt?: boolean
    cancelledAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "classBookingId" | "membershipUserId" | "tournamentRegistrationId" | "number" | "userId" | "paymentId" | "subtotal" | "processingFee" | "total" | "status" | "issuedAt" | "dueDate" | "paidAt" | "cancelledAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Invoice$paymentArgs<ExtArgs>
    booking?: boolean | Invoice$bookingArgs<ExtArgs>
    classBooking?: boolean | Invoice$classBookingArgs<ExtArgs>
    membershipUser?: boolean | Invoice$membershipUserArgs<ExtArgs>
    tournamentRegistration?: boolean | Invoice$tournamentRegistrationArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Invoice$paymentArgs<ExtArgs>
    booking?: boolean | Invoice$bookingArgs<ExtArgs>
    classBooking?: boolean | Invoice$classBookingArgs<ExtArgs>
    membershipUser?: boolean | Invoice$membershipUserArgs<ExtArgs>
    tournamentRegistration?: boolean | Invoice$tournamentRegistrationArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payment?: boolean | Invoice$paymentArgs<ExtArgs>
    booking?: boolean | Invoice$bookingArgs<ExtArgs>
    classBooking?: boolean | Invoice$classBookingArgs<ExtArgs>
    membershipUser?: boolean | Invoice$membershipUserArgs<ExtArgs>
    tournamentRegistration?: boolean | Invoice$tournamentRegistrationArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      booking: Prisma.$BookingPayload<ExtArgs> | null
      classBooking: Prisma.$ClassBookingPayload<ExtArgs> | null
      membershipUser: Prisma.$MembershipUserPayload<ExtArgs> | null
      tournamentRegistration: Prisma.$TournamentRegistrationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string | null
      classBookingId: string | null
      membershipUserId: string | null
      tournamentRegistrationId: string | null
      number: string
      userId: string
      paymentId: string | null
      subtotal: number
      processingFee: number
      total: number
      status: $Enums.PaymentStatus
      issuedAt: Date
      dueDate: Date
      paidAt: Date | null
      cancelledAt: Date | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends Invoice$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    booking<T extends Invoice$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    classBooking<T extends Invoice$classBookingArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$classBookingArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    membershipUser<T extends Invoice$membershipUserArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$membershipUserArgs<ExtArgs>>): Prisma__MembershipUserClient<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tournamentRegistration<T extends Invoice$tournamentRegistrationArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$tournamentRegistrationArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly bookingId: FieldRef<"Invoice", 'String'>
    readonly classBookingId: FieldRef<"Invoice", 'String'>
    readonly membershipUserId: FieldRef<"Invoice", 'String'>
    readonly tournamentRegistrationId: FieldRef<"Invoice", 'String'>
    readonly number: FieldRef<"Invoice", 'String'>
    readonly userId: FieldRef<"Invoice", 'String'>
    readonly paymentId: FieldRef<"Invoice", 'String'>
    readonly subtotal: FieldRef<"Invoice", 'Int'>
    readonly processingFee: FieldRef<"Invoice", 'Int'>
    readonly total: FieldRef<"Invoice", 'Int'>
    readonly status: FieldRef<"Invoice", 'PaymentStatus'>
    readonly issuedAt: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly cancelledAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.payment
   */
  export type Invoice$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Invoice.booking
   */
  export type Invoice$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Invoice.classBooking
   */
  export type Invoice$classBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    where?: ClassBookingWhereInput
  }

  /**
   * Invoice.membershipUser
   */
  export type Invoice$membershipUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    where?: MembershipUserWhereInput
  }

  /**
   * Invoice.tournamentRegistration
   */
  export type Invoice$tournamentRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    where?: TournamentRegistrationWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    totalPrice: number | null
    processingFee: number | null
  }

  export type BookingSumAggregateOutputType = {
    totalPrice: number | null
    processingFee: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.BookingStatus | null
    totalPrice: number | null
    processingFee: number | null
    createdAt: Date | null
    updatedAt: Date | null
    holdExpiresAt: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.BookingStatus | null
    totalPrice: number | null
    processingFee: number | null
    createdAt: Date | null
    updatedAt: Date | null
    holdExpiresAt: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    totalPrice: number
    processingFee: number
    createdAt: number
    updatedAt: number
    holdExpiresAt: number
    cancelledAt: number
    cancellationReason: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    totalPrice?: true
    processingFee?: true
  }

  export type BookingSumAggregateInputType = {
    totalPrice?: true
    processingFee?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    totalPrice?: true
    processingFee?: true
    createdAt?: true
    updatedAt?: true
    holdExpiresAt?: true
    cancelledAt?: true
    cancellationReason?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    totalPrice?: true
    processingFee?: true
    createdAt?: true
    updatedAt?: true
    holdExpiresAt?: true
    cancelledAt?: true
    cancellationReason?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    totalPrice?: true
    processingFee?: true
    createdAt?: true
    updatedAt?: true
    holdExpiresAt?: true
    cancelledAt?: true
    cancellationReason?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.BookingStatus
    totalPrice: number
    processingFee: number
    createdAt: Date
    updatedAt: Date
    holdExpiresAt: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    totalPrice?: boolean
    processingFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    holdExpiresAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    details?: boolean | Booking$detailsArgs<ExtArgs>
    inventories?: boolean | Booking$inventoriesArgs<ExtArgs>
    ballboys?: boolean | Booking$ballboysArgs<ExtArgs>
    coaches?: boolean | Booking$coachesArgs<ExtArgs>
    invoice?: boolean | Booking$invoiceArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    totalPrice?: boolean
    processingFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    holdExpiresAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    totalPrice?: boolean
    processingFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    holdExpiresAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    totalPrice?: boolean
    processingFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    holdExpiresAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "totalPrice" | "processingFee" | "createdAt" | "updatedAt" | "holdExpiresAt" | "cancelledAt" | "cancellationReason", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    details?: boolean | Booking$detailsArgs<ExtArgs>
    inventories?: boolean | Booking$inventoriesArgs<ExtArgs>
    ballboys?: boolean | Booking$ballboysArgs<ExtArgs>
    coaches?: boolean | Booking$coachesArgs<ExtArgs>
    invoice?: boolean | Booking$invoiceArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      details: Prisma.$BookingDetailPayload<ExtArgs>[]
      inventories: Prisma.$BookingInventoryPayload<ExtArgs>[]
      ballboys: Prisma.$BookingBallboyPayload<ExtArgs>[]
      coaches: Prisma.$BookingCoachPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.BookingStatus
      totalPrice: number
      processingFee: number
      createdAt: Date
      updatedAt: Date
      holdExpiresAt: Date | null
      cancelledAt: Date | null
      cancellationReason: string | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    details<T extends Booking$detailsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventories<T extends Booking$inventoriesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$inventoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ballboys<T extends Booking$ballboysArgs<ExtArgs> = {}>(args?: Subset<T, Booking$ballboysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coaches<T extends Booking$coachesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$coachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends Booking$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Booking$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly totalPrice: FieldRef<"Booking", 'Int'>
    readonly processingFee: FieldRef<"Booking", 'Int'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
    readonly holdExpiresAt: FieldRef<"Booking", 'DateTime'>
    readonly cancelledAt: FieldRef<"Booking", 'DateTime'>
    readonly cancellationReason: FieldRef<"Booking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.details
   */
  export type Booking$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    where?: BookingDetailWhereInput
    orderBy?: BookingDetailOrderByWithRelationInput | BookingDetailOrderByWithRelationInput[]
    cursor?: BookingDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingDetailScalarFieldEnum | BookingDetailScalarFieldEnum[]
  }

  /**
   * Booking.inventories
   */
  export type Booking$inventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    where?: BookingInventoryWhereInput
    orderBy?: BookingInventoryOrderByWithRelationInput | BookingInventoryOrderByWithRelationInput[]
    cursor?: BookingInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingInventoryScalarFieldEnum | BookingInventoryScalarFieldEnum[]
  }

  /**
   * Booking.ballboys
   */
  export type Booking$ballboysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    where?: BookingBallboyWhereInput
    orderBy?: BookingBallboyOrderByWithRelationInput | BookingBallboyOrderByWithRelationInput[]
    cursor?: BookingBallboyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingBallboyScalarFieldEnum | BookingBallboyScalarFieldEnum[]
  }

  /**
   * Booking.coaches
   */
  export type Booking$coachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    where?: BookingCoachWhereInput
    orderBy?: BookingCoachOrderByWithRelationInput | BookingCoachOrderByWithRelationInput[]
    cursor?: BookingCoachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingCoachScalarFieldEnum | BookingCoachScalarFieldEnum[]
  }

  /**
   * Booking.invoice
   */
  export type Booking$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model BookingDetail
   */

  export type AggregateBookingDetail = {
    _count: BookingDetailCountAggregateOutputType | null
    _avg: BookingDetailAvgAggregateOutputType | null
    _sum: BookingDetailSumAggregateOutputType | null
    _min: BookingDetailMinAggregateOutputType | null
    _max: BookingDetailMaxAggregateOutputType | null
  }

  export type BookingDetailAvgAggregateOutputType = {
    price: number | null
  }

  export type BookingDetailSumAggregateOutputType = {
    price: number | null
  }

  export type BookingDetailMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    slotId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    courtId: string | null
  }

  export type BookingDetailMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    slotId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    courtId: string | null
  }

  export type BookingDetailCountAggregateOutputType = {
    id: number
    bookingId: number
    slotId: number
    price: number
    createdAt: number
    updatedAt: number
    courtId: number
    _all: number
  }


  export type BookingDetailAvgAggregateInputType = {
    price?: true
  }

  export type BookingDetailSumAggregateInputType = {
    price?: true
  }

  export type BookingDetailMinAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    courtId?: true
  }

  export type BookingDetailMaxAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    courtId?: true
  }

  export type BookingDetailCountAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    courtId?: true
    _all?: true
  }

  export type BookingDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingDetail to aggregate.
     */
    where?: BookingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingDetails to fetch.
     */
    orderBy?: BookingDetailOrderByWithRelationInput | BookingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingDetails
    **/
    _count?: true | BookingDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingDetailMaxAggregateInputType
  }

  export type GetBookingDetailAggregateType<T extends BookingDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingDetail[P]>
      : GetScalarType<T[P], AggregateBookingDetail[P]>
  }




  export type BookingDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingDetailWhereInput
    orderBy?: BookingDetailOrderByWithAggregationInput | BookingDetailOrderByWithAggregationInput[]
    by: BookingDetailScalarFieldEnum[] | BookingDetailScalarFieldEnum
    having?: BookingDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingDetailCountAggregateInputType | true
    _avg?: BookingDetailAvgAggregateInputType
    _sum?: BookingDetailSumAggregateInputType
    _min?: BookingDetailMinAggregateInputType
    _max?: BookingDetailMaxAggregateInputType
  }

  export type BookingDetailGroupByOutputType = {
    id: string
    bookingId: string
    slotId: string
    price: number
    createdAt: Date
    updatedAt: Date
    courtId: string | null
    _count: BookingDetailCountAggregateOutputType | null
    _avg: BookingDetailAvgAggregateOutputType | null
    _sum: BookingDetailSumAggregateOutputType | null
    _min: BookingDetailMinAggregateOutputType | null
    _max: BookingDetailMaxAggregateOutputType | null
  }

  type GetBookingDetailGroupByPayload<T extends BookingDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingDetailGroupByOutputType[P]>
            : GetScalarType<T[P], BookingDetailGroupByOutputType[P]>
        }
      >
    >


  export type BookingDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courtId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    court?: boolean | BookingDetail$courtArgs<ExtArgs>
  }, ExtArgs["result"]["bookingDetail"]>

  export type BookingDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courtId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    court?: boolean | BookingDetail$courtArgs<ExtArgs>
  }, ExtArgs["result"]["bookingDetail"]>

  export type BookingDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courtId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    court?: boolean | BookingDetail$courtArgs<ExtArgs>
  }, ExtArgs["result"]["bookingDetail"]>

  export type BookingDetailSelectScalar = {
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courtId?: boolean
  }

  export type BookingDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "slotId" | "price" | "createdAt" | "updatedAt" | "courtId", ExtArgs["result"]["bookingDetail"]>
  export type BookingDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    court?: boolean | BookingDetail$courtArgs<ExtArgs>
  }
  export type BookingDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    court?: boolean | BookingDetail$courtArgs<ExtArgs>
  }
  export type BookingDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    court?: boolean | BookingDetail$courtArgs<ExtArgs>
  }

  export type $BookingDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingDetail"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      slot: Prisma.$SlotPayload<ExtArgs>
      court: Prisma.$CourtPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      slotId: string
      price: number
      createdAt: Date
      updatedAt: Date
      courtId: string | null
    }, ExtArgs["result"]["bookingDetail"]>
    composites: {}
  }

  type BookingDetailGetPayload<S extends boolean | null | undefined | BookingDetailDefaultArgs> = $Result.GetResult<Prisma.$BookingDetailPayload, S>

  type BookingDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingDetailCountAggregateInputType | true
    }

  export interface BookingDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingDetail'], meta: { name: 'BookingDetail' } }
    /**
     * Find zero or one BookingDetail that matches the filter.
     * @param {BookingDetailFindUniqueArgs} args - Arguments to find a BookingDetail
     * @example
     * // Get one BookingDetail
     * const bookingDetail = await prisma.bookingDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingDetailFindUniqueArgs>(args: SelectSubset<T, BookingDetailFindUniqueArgs<ExtArgs>>): Prisma__BookingDetailClient<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingDetailFindUniqueOrThrowArgs} args - Arguments to find a BookingDetail
     * @example
     * // Get one BookingDetail
     * const bookingDetail = await prisma.bookingDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingDetailClient<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingDetailFindFirstArgs} args - Arguments to find a BookingDetail
     * @example
     * // Get one BookingDetail
     * const bookingDetail = await prisma.bookingDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingDetailFindFirstArgs>(args?: SelectSubset<T, BookingDetailFindFirstArgs<ExtArgs>>): Prisma__BookingDetailClient<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingDetailFindFirstOrThrowArgs} args - Arguments to find a BookingDetail
     * @example
     * // Get one BookingDetail
     * const bookingDetail = await prisma.bookingDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingDetailClient<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingDetails
     * const bookingDetails = await prisma.bookingDetail.findMany()
     * 
     * // Get first 10 BookingDetails
     * const bookingDetails = await prisma.bookingDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingDetailWithIdOnly = await prisma.bookingDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingDetailFindManyArgs>(args?: SelectSubset<T, BookingDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingDetail.
     * @param {BookingDetailCreateArgs} args - Arguments to create a BookingDetail.
     * @example
     * // Create one BookingDetail
     * const BookingDetail = await prisma.bookingDetail.create({
     *   data: {
     *     // ... data to create a BookingDetail
     *   }
     * })
     * 
     */
    create<T extends BookingDetailCreateArgs>(args: SelectSubset<T, BookingDetailCreateArgs<ExtArgs>>): Prisma__BookingDetailClient<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingDetails.
     * @param {BookingDetailCreateManyArgs} args - Arguments to create many BookingDetails.
     * @example
     * // Create many BookingDetails
     * const bookingDetail = await prisma.bookingDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingDetailCreateManyArgs>(args?: SelectSubset<T, BookingDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingDetails and returns the data saved in the database.
     * @param {BookingDetailCreateManyAndReturnArgs} args - Arguments to create many BookingDetails.
     * @example
     * // Create many BookingDetails
     * const bookingDetail = await prisma.bookingDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingDetails and only return the `id`
     * const bookingDetailWithIdOnly = await prisma.bookingDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingDetail.
     * @param {BookingDetailDeleteArgs} args - Arguments to delete one BookingDetail.
     * @example
     * // Delete one BookingDetail
     * const BookingDetail = await prisma.bookingDetail.delete({
     *   where: {
     *     // ... filter to delete one BookingDetail
     *   }
     * })
     * 
     */
    delete<T extends BookingDetailDeleteArgs>(args: SelectSubset<T, BookingDetailDeleteArgs<ExtArgs>>): Prisma__BookingDetailClient<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingDetail.
     * @param {BookingDetailUpdateArgs} args - Arguments to update one BookingDetail.
     * @example
     * // Update one BookingDetail
     * const bookingDetail = await prisma.bookingDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingDetailUpdateArgs>(args: SelectSubset<T, BookingDetailUpdateArgs<ExtArgs>>): Prisma__BookingDetailClient<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingDetails.
     * @param {BookingDetailDeleteManyArgs} args - Arguments to filter BookingDetails to delete.
     * @example
     * // Delete a few BookingDetails
     * const { count } = await prisma.bookingDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDetailDeleteManyArgs>(args?: SelectSubset<T, BookingDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingDetails
     * const bookingDetail = await prisma.bookingDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingDetailUpdateManyArgs>(args: SelectSubset<T, BookingDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingDetails and returns the data updated in the database.
     * @param {BookingDetailUpdateManyAndReturnArgs} args - Arguments to update many BookingDetails.
     * @example
     * // Update many BookingDetails
     * const bookingDetail = await prisma.bookingDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingDetails and only return the `id`
     * const bookingDetailWithIdOnly = await prisma.bookingDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingDetail.
     * @param {BookingDetailUpsertArgs} args - Arguments to update or create a BookingDetail.
     * @example
     * // Update or create a BookingDetail
     * const bookingDetail = await prisma.bookingDetail.upsert({
     *   create: {
     *     // ... data to create a BookingDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingDetail we want to update
     *   }
     * })
     */
    upsert<T extends BookingDetailUpsertArgs>(args: SelectSubset<T, BookingDetailUpsertArgs<ExtArgs>>): Prisma__BookingDetailClient<$Result.GetResult<Prisma.$BookingDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingDetailCountArgs} args - Arguments to filter BookingDetails to count.
     * @example
     * // Count the number of BookingDetails
     * const count = await prisma.bookingDetail.count({
     *   where: {
     *     // ... the filter for the BookingDetails we want to count
     *   }
     * })
    **/
    count<T extends BookingDetailCountArgs>(
      args?: Subset<T, BookingDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingDetailAggregateArgs>(args: Subset<T, BookingDetailAggregateArgs>): Prisma.PrismaPromise<GetBookingDetailAggregateType<T>>

    /**
     * Group by BookingDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingDetailGroupByArgs['orderBy'] }
        : { orderBy?: BookingDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingDetail model
   */
  readonly fields: BookingDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    slot<T extends SlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SlotDefaultArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    court<T extends BookingDetail$courtArgs<ExtArgs> = {}>(args?: Subset<T, BookingDetail$courtArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingDetail model
   */
  interface BookingDetailFieldRefs {
    readonly id: FieldRef<"BookingDetail", 'String'>
    readonly bookingId: FieldRef<"BookingDetail", 'String'>
    readonly slotId: FieldRef<"BookingDetail", 'String'>
    readonly price: FieldRef<"BookingDetail", 'Int'>
    readonly createdAt: FieldRef<"BookingDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingDetail", 'DateTime'>
    readonly courtId: FieldRef<"BookingDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookingDetail findUnique
   */
  export type BookingDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which BookingDetail to fetch.
     */
    where: BookingDetailWhereUniqueInput
  }

  /**
   * BookingDetail findUniqueOrThrow
   */
  export type BookingDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which BookingDetail to fetch.
     */
    where: BookingDetailWhereUniqueInput
  }

  /**
   * BookingDetail findFirst
   */
  export type BookingDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which BookingDetail to fetch.
     */
    where?: BookingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingDetails to fetch.
     */
    orderBy?: BookingDetailOrderByWithRelationInput | BookingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingDetails.
     */
    cursor?: BookingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingDetails.
     */
    distinct?: BookingDetailScalarFieldEnum | BookingDetailScalarFieldEnum[]
  }

  /**
   * BookingDetail findFirstOrThrow
   */
  export type BookingDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which BookingDetail to fetch.
     */
    where?: BookingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingDetails to fetch.
     */
    orderBy?: BookingDetailOrderByWithRelationInput | BookingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingDetails.
     */
    cursor?: BookingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingDetails.
     */
    distinct?: BookingDetailScalarFieldEnum | BookingDetailScalarFieldEnum[]
  }

  /**
   * BookingDetail findMany
   */
  export type BookingDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which BookingDetails to fetch.
     */
    where?: BookingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingDetails to fetch.
     */
    orderBy?: BookingDetailOrderByWithRelationInput | BookingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingDetails.
     */
    cursor?: BookingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingDetails.
     */
    skip?: number
    distinct?: BookingDetailScalarFieldEnum | BookingDetailScalarFieldEnum[]
  }

  /**
   * BookingDetail create
   */
  export type BookingDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingDetail.
     */
    data: XOR<BookingDetailCreateInput, BookingDetailUncheckedCreateInput>
  }

  /**
   * BookingDetail createMany
   */
  export type BookingDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingDetails.
     */
    data: BookingDetailCreateManyInput | BookingDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingDetail createManyAndReturn
   */
  export type BookingDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * The data used to create many BookingDetails.
     */
    data: BookingDetailCreateManyInput | BookingDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingDetail update
   */
  export type BookingDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingDetail.
     */
    data: XOR<BookingDetailUpdateInput, BookingDetailUncheckedUpdateInput>
    /**
     * Choose, which BookingDetail to update.
     */
    where: BookingDetailWhereUniqueInput
  }

  /**
   * BookingDetail updateMany
   */
  export type BookingDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingDetails.
     */
    data: XOR<BookingDetailUpdateManyMutationInput, BookingDetailUncheckedUpdateManyInput>
    /**
     * Filter which BookingDetails to update
     */
    where?: BookingDetailWhereInput
    /**
     * Limit how many BookingDetails to update.
     */
    limit?: number
  }

  /**
   * BookingDetail updateManyAndReturn
   */
  export type BookingDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * The data used to update BookingDetails.
     */
    data: XOR<BookingDetailUpdateManyMutationInput, BookingDetailUncheckedUpdateManyInput>
    /**
     * Filter which BookingDetails to update
     */
    where?: BookingDetailWhereInput
    /**
     * Limit how many BookingDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingDetail upsert
   */
  export type BookingDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingDetail to update in case it exists.
     */
    where: BookingDetailWhereUniqueInput
    /**
     * In case the BookingDetail found by the `where` argument doesn't exist, create a new BookingDetail with this data.
     */
    create: XOR<BookingDetailCreateInput, BookingDetailUncheckedCreateInput>
    /**
     * In case the BookingDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingDetailUpdateInput, BookingDetailUncheckedUpdateInput>
  }

  /**
   * BookingDetail delete
   */
  export type BookingDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
    /**
     * Filter which BookingDetail to delete.
     */
    where: BookingDetailWhereUniqueInput
  }

  /**
   * BookingDetail deleteMany
   */
  export type BookingDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingDetails to delete
     */
    where?: BookingDetailWhereInput
    /**
     * Limit how many BookingDetails to delete.
     */
    limit?: number
  }

  /**
   * BookingDetail.court
   */
  export type BookingDetail$courtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    where?: CourtWhereInput
  }

  /**
   * BookingDetail without action
   */
  export type BookingDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingDetail
     */
    select?: BookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingDetail
     */
    omit?: BookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingDetailInclude<ExtArgs> | null
  }


  /**
   * Model BookingInventory
   */

  export type AggregateBookingInventory = {
    _count: BookingInventoryCountAggregateOutputType | null
    _avg: BookingInventoryAvgAggregateOutputType | null
    _sum: BookingInventorySumAggregateOutputType | null
    _min: BookingInventoryMinAggregateOutputType | null
    _max: BookingInventoryMaxAggregateOutputType | null
  }

  export type BookingInventoryAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type BookingInventorySumAggregateOutputType = {
    quantity: number | null
    price: number | null
  }

  export type BookingInventoryMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    inventoryId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingInventoryMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    inventoryId: string | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingInventoryCountAggregateOutputType = {
    id: number
    bookingId: number
    inventoryId: number
    quantity: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingInventoryAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type BookingInventorySumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type BookingInventoryMinAggregateInputType = {
    id?: true
    bookingId?: true
    inventoryId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingInventoryMaxAggregateInputType = {
    id?: true
    bookingId?: true
    inventoryId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingInventoryCountAggregateInputType = {
    id?: true
    bookingId?: true
    inventoryId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingInventory to aggregate.
     */
    where?: BookingInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingInventories to fetch.
     */
    orderBy?: BookingInventoryOrderByWithRelationInput | BookingInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingInventories
    **/
    _count?: true | BookingInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingInventoryMaxAggregateInputType
  }

  export type GetBookingInventoryAggregateType<T extends BookingInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingInventory[P]>
      : GetScalarType<T[P], AggregateBookingInventory[P]>
  }




  export type BookingInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingInventoryWhereInput
    orderBy?: BookingInventoryOrderByWithAggregationInput | BookingInventoryOrderByWithAggregationInput[]
    by: BookingInventoryScalarFieldEnum[] | BookingInventoryScalarFieldEnum
    having?: BookingInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingInventoryCountAggregateInputType | true
    _avg?: BookingInventoryAvgAggregateInputType
    _sum?: BookingInventorySumAggregateInputType
    _min?: BookingInventoryMinAggregateInputType
    _max?: BookingInventoryMaxAggregateInputType
  }

  export type BookingInventoryGroupByOutputType = {
    id: string
    bookingId: string
    inventoryId: string
    quantity: number
    price: number
    createdAt: Date
    updatedAt: Date
    _count: BookingInventoryCountAggregateOutputType | null
    _avg: BookingInventoryAvgAggregateOutputType | null
    _sum: BookingInventorySumAggregateOutputType | null
    _min: BookingInventoryMinAggregateOutputType | null
    _max: BookingInventoryMaxAggregateOutputType | null
  }

  type GetBookingInventoryGroupByPayload<T extends BookingInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], BookingInventoryGroupByOutputType[P]>
        }
      >
    >


  export type BookingInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    inventoryId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingInventory"]>

  export type BookingInventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    inventoryId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingInventory"]>

  export type BookingInventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    inventoryId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingInventory"]>

  export type BookingInventorySelectScalar = {
    id?: boolean
    bookingId?: boolean
    inventoryId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingInventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "inventoryId" | "quantity" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["bookingInventory"]>
  export type BookingInventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }
  export type BookingInventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }
  export type BookingInventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
  }

  export type $BookingInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingInventory"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      inventory: Prisma.$InventoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      inventoryId: string
      quantity: number
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookingInventory"]>
    composites: {}
  }

  type BookingInventoryGetPayload<S extends boolean | null | undefined | BookingInventoryDefaultArgs> = $Result.GetResult<Prisma.$BookingInventoryPayload, S>

  type BookingInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingInventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingInventoryCountAggregateInputType | true
    }

  export interface BookingInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingInventory'], meta: { name: 'BookingInventory' } }
    /**
     * Find zero or one BookingInventory that matches the filter.
     * @param {BookingInventoryFindUniqueArgs} args - Arguments to find a BookingInventory
     * @example
     * // Get one BookingInventory
     * const bookingInventory = await prisma.bookingInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingInventoryFindUniqueArgs>(args: SelectSubset<T, BookingInventoryFindUniqueArgs<ExtArgs>>): Prisma__BookingInventoryClient<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingInventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingInventoryFindUniqueOrThrowArgs} args - Arguments to find a BookingInventory
     * @example
     * // Get one BookingInventory
     * const bookingInventory = await prisma.bookingInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingInventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingInventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingInventoryClient<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInventoryFindFirstArgs} args - Arguments to find a BookingInventory
     * @example
     * // Get one BookingInventory
     * const bookingInventory = await prisma.bookingInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingInventoryFindFirstArgs>(args?: SelectSubset<T, BookingInventoryFindFirstArgs<ExtArgs>>): Prisma__BookingInventoryClient<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInventoryFindFirstOrThrowArgs} args - Arguments to find a BookingInventory
     * @example
     * // Get one BookingInventory
     * const bookingInventory = await prisma.bookingInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingInventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingInventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingInventoryClient<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingInventories
     * const bookingInventories = await prisma.bookingInventory.findMany()
     * 
     * // Get first 10 BookingInventories
     * const bookingInventories = await prisma.bookingInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingInventoryWithIdOnly = await prisma.bookingInventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingInventoryFindManyArgs>(args?: SelectSubset<T, BookingInventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingInventory.
     * @param {BookingInventoryCreateArgs} args - Arguments to create a BookingInventory.
     * @example
     * // Create one BookingInventory
     * const BookingInventory = await prisma.bookingInventory.create({
     *   data: {
     *     // ... data to create a BookingInventory
     *   }
     * })
     * 
     */
    create<T extends BookingInventoryCreateArgs>(args: SelectSubset<T, BookingInventoryCreateArgs<ExtArgs>>): Prisma__BookingInventoryClient<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingInventories.
     * @param {BookingInventoryCreateManyArgs} args - Arguments to create many BookingInventories.
     * @example
     * // Create many BookingInventories
     * const bookingInventory = await prisma.bookingInventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingInventoryCreateManyArgs>(args?: SelectSubset<T, BookingInventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingInventories and returns the data saved in the database.
     * @param {BookingInventoryCreateManyAndReturnArgs} args - Arguments to create many BookingInventories.
     * @example
     * // Create many BookingInventories
     * const bookingInventory = await prisma.bookingInventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingInventories and only return the `id`
     * const bookingInventoryWithIdOnly = await prisma.bookingInventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingInventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingInventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingInventory.
     * @param {BookingInventoryDeleteArgs} args - Arguments to delete one BookingInventory.
     * @example
     * // Delete one BookingInventory
     * const BookingInventory = await prisma.bookingInventory.delete({
     *   where: {
     *     // ... filter to delete one BookingInventory
     *   }
     * })
     * 
     */
    delete<T extends BookingInventoryDeleteArgs>(args: SelectSubset<T, BookingInventoryDeleteArgs<ExtArgs>>): Prisma__BookingInventoryClient<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingInventory.
     * @param {BookingInventoryUpdateArgs} args - Arguments to update one BookingInventory.
     * @example
     * // Update one BookingInventory
     * const bookingInventory = await prisma.bookingInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingInventoryUpdateArgs>(args: SelectSubset<T, BookingInventoryUpdateArgs<ExtArgs>>): Prisma__BookingInventoryClient<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingInventories.
     * @param {BookingInventoryDeleteManyArgs} args - Arguments to filter BookingInventories to delete.
     * @example
     * // Delete a few BookingInventories
     * const { count } = await prisma.bookingInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingInventoryDeleteManyArgs>(args?: SelectSubset<T, BookingInventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingInventories
     * const bookingInventory = await prisma.bookingInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingInventoryUpdateManyArgs>(args: SelectSubset<T, BookingInventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingInventories and returns the data updated in the database.
     * @param {BookingInventoryUpdateManyAndReturnArgs} args - Arguments to update many BookingInventories.
     * @example
     * // Update many BookingInventories
     * const bookingInventory = await prisma.bookingInventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingInventories and only return the `id`
     * const bookingInventoryWithIdOnly = await prisma.bookingInventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingInventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingInventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingInventory.
     * @param {BookingInventoryUpsertArgs} args - Arguments to update or create a BookingInventory.
     * @example
     * // Update or create a BookingInventory
     * const bookingInventory = await prisma.bookingInventory.upsert({
     *   create: {
     *     // ... data to create a BookingInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingInventory we want to update
     *   }
     * })
     */
    upsert<T extends BookingInventoryUpsertArgs>(args: SelectSubset<T, BookingInventoryUpsertArgs<ExtArgs>>): Prisma__BookingInventoryClient<$Result.GetResult<Prisma.$BookingInventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInventoryCountArgs} args - Arguments to filter BookingInventories to count.
     * @example
     * // Count the number of BookingInventories
     * const count = await prisma.bookingInventory.count({
     *   where: {
     *     // ... the filter for the BookingInventories we want to count
     *   }
     * })
    **/
    count<T extends BookingInventoryCountArgs>(
      args?: Subset<T, BookingInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingInventoryAggregateArgs>(args: Subset<T, BookingInventoryAggregateArgs>): Prisma.PrismaPromise<GetBookingInventoryAggregateType<T>>

    /**
     * Group by BookingInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingInventoryGroupByArgs['orderBy'] }
        : { orderBy?: BookingInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingInventory model
   */
  readonly fields: BookingInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingInventory model
   */
  interface BookingInventoryFieldRefs {
    readonly id: FieldRef<"BookingInventory", 'String'>
    readonly bookingId: FieldRef<"BookingInventory", 'String'>
    readonly inventoryId: FieldRef<"BookingInventory", 'String'>
    readonly quantity: FieldRef<"BookingInventory", 'Int'>
    readonly price: FieldRef<"BookingInventory", 'Int'>
    readonly createdAt: FieldRef<"BookingInventory", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingInventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingInventory findUnique
   */
  export type BookingInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingInventory to fetch.
     */
    where: BookingInventoryWhereUniqueInput
  }

  /**
   * BookingInventory findUniqueOrThrow
   */
  export type BookingInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingInventory to fetch.
     */
    where: BookingInventoryWhereUniqueInput
  }

  /**
   * BookingInventory findFirst
   */
  export type BookingInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingInventory to fetch.
     */
    where?: BookingInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingInventories to fetch.
     */
    orderBy?: BookingInventoryOrderByWithRelationInput | BookingInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingInventories.
     */
    cursor?: BookingInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingInventories.
     */
    distinct?: BookingInventoryScalarFieldEnum | BookingInventoryScalarFieldEnum[]
  }

  /**
   * BookingInventory findFirstOrThrow
   */
  export type BookingInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingInventory to fetch.
     */
    where?: BookingInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingInventories to fetch.
     */
    orderBy?: BookingInventoryOrderByWithRelationInput | BookingInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingInventories.
     */
    cursor?: BookingInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingInventories.
     */
    distinct?: BookingInventoryScalarFieldEnum | BookingInventoryScalarFieldEnum[]
  }

  /**
   * BookingInventory findMany
   */
  export type BookingInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingInventories to fetch.
     */
    where?: BookingInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingInventories to fetch.
     */
    orderBy?: BookingInventoryOrderByWithRelationInput | BookingInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingInventories.
     */
    cursor?: BookingInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingInventories.
     */
    skip?: number
    distinct?: BookingInventoryScalarFieldEnum | BookingInventoryScalarFieldEnum[]
  }

  /**
   * BookingInventory create
   */
  export type BookingInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingInventory.
     */
    data: XOR<BookingInventoryCreateInput, BookingInventoryUncheckedCreateInput>
  }

  /**
   * BookingInventory createMany
   */
  export type BookingInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingInventories.
     */
    data: BookingInventoryCreateManyInput | BookingInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingInventory createManyAndReturn
   */
  export type BookingInventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * The data used to create many BookingInventories.
     */
    data: BookingInventoryCreateManyInput | BookingInventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingInventory update
   */
  export type BookingInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingInventory.
     */
    data: XOR<BookingInventoryUpdateInput, BookingInventoryUncheckedUpdateInput>
    /**
     * Choose, which BookingInventory to update.
     */
    where: BookingInventoryWhereUniqueInput
  }

  /**
   * BookingInventory updateMany
   */
  export type BookingInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingInventories.
     */
    data: XOR<BookingInventoryUpdateManyMutationInput, BookingInventoryUncheckedUpdateManyInput>
    /**
     * Filter which BookingInventories to update
     */
    where?: BookingInventoryWhereInput
    /**
     * Limit how many BookingInventories to update.
     */
    limit?: number
  }

  /**
   * BookingInventory updateManyAndReturn
   */
  export type BookingInventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * The data used to update BookingInventories.
     */
    data: XOR<BookingInventoryUpdateManyMutationInput, BookingInventoryUncheckedUpdateManyInput>
    /**
     * Filter which BookingInventories to update
     */
    where?: BookingInventoryWhereInput
    /**
     * Limit how many BookingInventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingInventory upsert
   */
  export type BookingInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingInventory to update in case it exists.
     */
    where: BookingInventoryWhereUniqueInput
    /**
     * In case the BookingInventory found by the `where` argument doesn't exist, create a new BookingInventory with this data.
     */
    create: XOR<BookingInventoryCreateInput, BookingInventoryUncheckedCreateInput>
    /**
     * In case the BookingInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingInventoryUpdateInput, BookingInventoryUncheckedUpdateInput>
  }

  /**
   * BookingInventory delete
   */
  export type BookingInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
    /**
     * Filter which BookingInventory to delete.
     */
    where: BookingInventoryWhereUniqueInput
  }

  /**
   * BookingInventory deleteMany
   */
  export type BookingInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingInventories to delete
     */
    where?: BookingInventoryWhereInput
    /**
     * Limit how many BookingInventories to delete.
     */
    limit?: number
  }

  /**
   * BookingInventory without action
   */
  export type BookingInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInventory
     */
    select?: BookingInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInventory
     */
    omit?: BookingInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInventoryInclude<ExtArgs> | null
  }


  /**
   * Model BookingBallboy
   */

  export type AggregateBookingBallboy = {
    _count: BookingBallboyCountAggregateOutputType | null
    _avg: BookingBallboyAvgAggregateOutputType | null
    _sum: BookingBallboySumAggregateOutputType | null
    _min: BookingBallboyMinAggregateOutputType | null
    _max: BookingBallboyMaxAggregateOutputType | null
  }

  export type BookingBallboyAvgAggregateOutputType = {
    price: number | null
  }

  export type BookingBallboySumAggregateOutputType = {
    price: number | null
  }

  export type BookingBallboyMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    slotId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingBallboyMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    slotId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingBallboyCountAggregateOutputType = {
    id: number
    bookingId: number
    slotId: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingBallboyAvgAggregateInputType = {
    price?: true
  }

  export type BookingBallboySumAggregateInputType = {
    price?: true
  }

  export type BookingBallboyMinAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingBallboyMaxAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingBallboyCountAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingBallboyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingBallboy to aggregate.
     */
    where?: BookingBallboyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingBallboys to fetch.
     */
    orderBy?: BookingBallboyOrderByWithRelationInput | BookingBallboyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingBallboyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingBallboys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingBallboys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingBallboys
    **/
    _count?: true | BookingBallboyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingBallboyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingBallboySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingBallboyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingBallboyMaxAggregateInputType
  }

  export type GetBookingBallboyAggregateType<T extends BookingBallboyAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingBallboy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingBallboy[P]>
      : GetScalarType<T[P], AggregateBookingBallboy[P]>
  }




  export type BookingBallboyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingBallboyWhereInput
    orderBy?: BookingBallboyOrderByWithAggregationInput | BookingBallboyOrderByWithAggregationInput[]
    by: BookingBallboyScalarFieldEnum[] | BookingBallboyScalarFieldEnum
    having?: BookingBallboyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingBallboyCountAggregateInputType | true
    _avg?: BookingBallboyAvgAggregateInputType
    _sum?: BookingBallboySumAggregateInputType
    _min?: BookingBallboyMinAggregateInputType
    _max?: BookingBallboyMaxAggregateInputType
  }

  export type BookingBallboyGroupByOutputType = {
    id: string
    bookingId: string
    slotId: string
    price: number
    createdAt: Date
    updatedAt: Date
    _count: BookingBallboyCountAggregateOutputType | null
    _avg: BookingBallboyAvgAggregateOutputType | null
    _sum: BookingBallboySumAggregateOutputType | null
    _min: BookingBallboyMinAggregateOutputType | null
    _max: BookingBallboyMaxAggregateOutputType | null
  }

  type GetBookingBallboyGroupByPayload<T extends BookingBallboyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingBallboyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingBallboyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingBallboyGroupByOutputType[P]>
            : GetScalarType<T[P], BookingBallboyGroupByOutputType[P]>
        }
      >
    >


  export type BookingBallboySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingBallboy"]>

  export type BookingBallboySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingBallboy"]>

  export type BookingBallboySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingBallboy"]>

  export type BookingBallboySelectScalar = {
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingBallboyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "slotId" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["bookingBallboy"]>
  export type BookingBallboyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
  }
  export type BookingBallboyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
  }
  export type BookingBallboyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
  }

  export type $BookingBallboyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingBallboy"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      slot: Prisma.$SlotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      slotId: string
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookingBallboy"]>
    composites: {}
  }

  type BookingBallboyGetPayload<S extends boolean | null | undefined | BookingBallboyDefaultArgs> = $Result.GetResult<Prisma.$BookingBallboyPayload, S>

  type BookingBallboyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingBallboyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingBallboyCountAggregateInputType | true
    }

  export interface BookingBallboyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingBallboy'], meta: { name: 'BookingBallboy' } }
    /**
     * Find zero or one BookingBallboy that matches the filter.
     * @param {BookingBallboyFindUniqueArgs} args - Arguments to find a BookingBallboy
     * @example
     * // Get one BookingBallboy
     * const bookingBallboy = await prisma.bookingBallboy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingBallboyFindUniqueArgs>(args: SelectSubset<T, BookingBallboyFindUniqueArgs<ExtArgs>>): Prisma__BookingBallboyClient<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingBallboy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingBallboyFindUniqueOrThrowArgs} args - Arguments to find a BookingBallboy
     * @example
     * // Get one BookingBallboy
     * const bookingBallboy = await prisma.bookingBallboy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingBallboyFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingBallboyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingBallboyClient<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingBallboy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingBallboyFindFirstArgs} args - Arguments to find a BookingBallboy
     * @example
     * // Get one BookingBallboy
     * const bookingBallboy = await prisma.bookingBallboy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingBallboyFindFirstArgs>(args?: SelectSubset<T, BookingBallboyFindFirstArgs<ExtArgs>>): Prisma__BookingBallboyClient<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingBallboy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingBallboyFindFirstOrThrowArgs} args - Arguments to find a BookingBallboy
     * @example
     * // Get one BookingBallboy
     * const bookingBallboy = await prisma.bookingBallboy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingBallboyFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingBallboyFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingBallboyClient<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingBallboys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingBallboyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingBallboys
     * const bookingBallboys = await prisma.bookingBallboy.findMany()
     * 
     * // Get first 10 BookingBallboys
     * const bookingBallboys = await prisma.bookingBallboy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingBallboyWithIdOnly = await prisma.bookingBallboy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingBallboyFindManyArgs>(args?: SelectSubset<T, BookingBallboyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingBallboy.
     * @param {BookingBallboyCreateArgs} args - Arguments to create a BookingBallboy.
     * @example
     * // Create one BookingBallboy
     * const BookingBallboy = await prisma.bookingBallboy.create({
     *   data: {
     *     // ... data to create a BookingBallboy
     *   }
     * })
     * 
     */
    create<T extends BookingBallboyCreateArgs>(args: SelectSubset<T, BookingBallboyCreateArgs<ExtArgs>>): Prisma__BookingBallboyClient<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingBallboys.
     * @param {BookingBallboyCreateManyArgs} args - Arguments to create many BookingBallboys.
     * @example
     * // Create many BookingBallboys
     * const bookingBallboy = await prisma.bookingBallboy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingBallboyCreateManyArgs>(args?: SelectSubset<T, BookingBallboyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingBallboys and returns the data saved in the database.
     * @param {BookingBallboyCreateManyAndReturnArgs} args - Arguments to create many BookingBallboys.
     * @example
     * // Create many BookingBallboys
     * const bookingBallboy = await prisma.bookingBallboy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingBallboys and only return the `id`
     * const bookingBallboyWithIdOnly = await prisma.bookingBallboy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingBallboyCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingBallboyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingBallboy.
     * @param {BookingBallboyDeleteArgs} args - Arguments to delete one BookingBallboy.
     * @example
     * // Delete one BookingBallboy
     * const BookingBallboy = await prisma.bookingBallboy.delete({
     *   where: {
     *     // ... filter to delete one BookingBallboy
     *   }
     * })
     * 
     */
    delete<T extends BookingBallboyDeleteArgs>(args: SelectSubset<T, BookingBallboyDeleteArgs<ExtArgs>>): Prisma__BookingBallboyClient<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingBallboy.
     * @param {BookingBallboyUpdateArgs} args - Arguments to update one BookingBallboy.
     * @example
     * // Update one BookingBallboy
     * const bookingBallboy = await prisma.bookingBallboy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingBallboyUpdateArgs>(args: SelectSubset<T, BookingBallboyUpdateArgs<ExtArgs>>): Prisma__BookingBallboyClient<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingBallboys.
     * @param {BookingBallboyDeleteManyArgs} args - Arguments to filter BookingBallboys to delete.
     * @example
     * // Delete a few BookingBallboys
     * const { count } = await prisma.bookingBallboy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingBallboyDeleteManyArgs>(args?: SelectSubset<T, BookingBallboyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingBallboys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingBallboyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingBallboys
     * const bookingBallboy = await prisma.bookingBallboy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingBallboyUpdateManyArgs>(args: SelectSubset<T, BookingBallboyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingBallboys and returns the data updated in the database.
     * @param {BookingBallboyUpdateManyAndReturnArgs} args - Arguments to update many BookingBallboys.
     * @example
     * // Update many BookingBallboys
     * const bookingBallboy = await prisma.bookingBallboy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingBallboys and only return the `id`
     * const bookingBallboyWithIdOnly = await prisma.bookingBallboy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingBallboyUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingBallboyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingBallboy.
     * @param {BookingBallboyUpsertArgs} args - Arguments to update or create a BookingBallboy.
     * @example
     * // Update or create a BookingBallboy
     * const bookingBallboy = await prisma.bookingBallboy.upsert({
     *   create: {
     *     // ... data to create a BookingBallboy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingBallboy we want to update
     *   }
     * })
     */
    upsert<T extends BookingBallboyUpsertArgs>(args: SelectSubset<T, BookingBallboyUpsertArgs<ExtArgs>>): Prisma__BookingBallboyClient<$Result.GetResult<Prisma.$BookingBallboyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingBallboys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingBallboyCountArgs} args - Arguments to filter BookingBallboys to count.
     * @example
     * // Count the number of BookingBallboys
     * const count = await prisma.bookingBallboy.count({
     *   where: {
     *     // ... the filter for the BookingBallboys we want to count
     *   }
     * })
    **/
    count<T extends BookingBallboyCountArgs>(
      args?: Subset<T, BookingBallboyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingBallboyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingBallboy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingBallboyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingBallboyAggregateArgs>(args: Subset<T, BookingBallboyAggregateArgs>): Prisma.PrismaPromise<GetBookingBallboyAggregateType<T>>

    /**
     * Group by BookingBallboy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingBallboyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingBallboyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingBallboyGroupByArgs['orderBy'] }
        : { orderBy?: BookingBallboyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingBallboyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingBallboyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingBallboy model
   */
  readonly fields: BookingBallboyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingBallboy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingBallboyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    slot<T extends SlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SlotDefaultArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingBallboy model
   */
  interface BookingBallboyFieldRefs {
    readonly id: FieldRef<"BookingBallboy", 'String'>
    readonly bookingId: FieldRef<"BookingBallboy", 'String'>
    readonly slotId: FieldRef<"BookingBallboy", 'String'>
    readonly price: FieldRef<"BookingBallboy", 'Int'>
    readonly createdAt: FieldRef<"BookingBallboy", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingBallboy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingBallboy findUnique
   */
  export type BookingBallboyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    /**
     * Filter, which BookingBallboy to fetch.
     */
    where: BookingBallboyWhereUniqueInput
  }

  /**
   * BookingBallboy findUniqueOrThrow
   */
  export type BookingBallboyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    /**
     * Filter, which BookingBallboy to fetch.
     */
    where: BookingBallboyWhereUniqueInput
  }

  /**
   * BookingBallboy findFirst
   */
  export type BookingBallboyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    /**
     * Filter, which BookingBallboy to fetch.
     */
    where?: BookingBallboyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingBallboys to fetch.
     */
    orderBy?: BookingBallboyOrderByWithRelationInput | BookingBallboyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingBallboys.
     */
    cursor?: BookingBallboyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingBallboys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingBallboys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingBallboys.
     */
    distinct?: BookingBallboyScalarFieldEnum | BookingBallboyScalarFieldEnum[]
  }

  /**
   * BookingBallboy findFirstOrThrow
   */
  export type BookingBallboyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    /**
     * Filter, which BookingBallboy to fetch.
     */
    where?: BookingBallboyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingBallboys to fetch.
     */
    orderBy?: BookingBallboyOrderByWithRelationInput | BookingBallboyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingBallboys.
     */
    cursor?: BookingBallboyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingBallboys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingBallboys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingBallboys.
     */
    distinct?: BookingBallboyScalarFieldEnum | BookingBallboyScalarFieldEnum[]
  }

  /**
   * BookingBallboy findMany
   */
  export type BookingBallboyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    /**
     * Filter, which BookingBallboys to fetch.
     */
    where?: BookingBallboyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingBallboys to fetch.
     */
    orderBy?: BookingBallboyOrderByWithRelationInput | BookingBallboyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingBallboys.
     */
    cursor?: BookingBallboyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingBallboys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingBallboys.
     */
    skip?: number
    distinct?: BookingBallboyScalarFieldEnum | BookingBallboyScalarFieldEnum[]
  }

  /**
   * BookingBallboy create
   */
  export type BookingBallboyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingBallboy.
     */
    data: XOR<BookingBallboyCreateInput, BookingBallboyUncheckedCreateInput>
  }

  /**
   * BookingBallboy createMany
   */
  export type BookingBallboyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingBallboys.
     */
    data: BookingBallboyCreateManyInput | BookingBallboyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingBallboy createManyAndReturn
   */
  export type BookingBallboyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * The data used to create many BookingBallboys.
     */
    data: BookingBallboyCreateManyInput | BookingBallboyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingBallboy update
   */
  export type BookingBallboyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingBallboy.
     */
    data: XOR<BookingBallboyUpdateInput, BookingBallboyUncheckedUpdateInput>
    /**
     * Choose, which BookingBallboy to update.
     */
    where: BookingBallboyWhereUniqueInput
  }

  /**
   * BookingBallboy updateMany
   */
  export type BookingBallboyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingBallboys.
     */
    data: XOR<BookingBallboyUpdateManyMutationInput, BookingBallboyUncheckedUpdateManyInput>
    /**
     * Filter which BookingBallboys to update
     */
    where?: BookingBallboyWhereInput
    /**
     * Limit how many BookingBallboys to update.
     */
    limit?: number
  }

  /**
   * BookingBallboy updateManyAndReturn
   */
  export type BookingBallboyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * The data used to update BookingBallboys.
     */
    data: XOR<BookingBallboyUpdateManyMutationInput, BookingBallboyUncheckedUpdateManyInput>
    /**
     * Filter which BookingBallboys to update
     */
    where?: BookingBallboyWhereInput
    /**
     * Limit how many BookingBallboys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingBallboy upsert
   */
  export type BookingBallboyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingBallboy to update in case it exists.
     */
    where: BookingBallboyWhereUniqueInput
    /**
     * In case the BookingBallboy found by the `where` argument doesn't exist, create a new BookingBallboy with this data.
     */
    create: XOR<BookingBallboyCreateInput, BookingBallboyUncheckedCreateInput>
    /**
     * In case the BookingBallboy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingBallboyUpdateInput, BookingBallboyUncheckedUpdateInput>
  }

  /**
   * BookingBallboy delete
   */
  export type BookingBallboyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
    /**
     * Filter which BookingBallboy to delete.
     */
    where: BookingBallboyWhereUniqueInput
  }

  /**
   * BookingBallboy deleteMany
   */
  export type BookingBallboyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingBallboys to delete
     */
    where?: BookingBallboyWhereInput
    /**
     * Limit how many BookingBallboys to delete.
     */
    limit?: number
  }

  /**
   * BookingBallboy without action
   */
  export type BookingBallboyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingBallboy
     */
    select?: BookingBallboySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingBallboy
     */
    omit?: BookingBallboyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingBallboyInclude<ExtArgs> | null
  }


  /**
   * Model BookingCoachType
   */

  export type AggregateBookingCoachType = {
    _count: BookingCoachTypeCountAggregateOutputType | null
    _min: BookingCoachTypeMinAggregateOutputType | null
    _max: BookingCoachTypeMaxAggregateOutputType | null
  }

  export type BookingCoachTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCoachTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCoachTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingCoachTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCoachTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCoachTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingCoachTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingCoachType to aggregate.
     */
    where?: BookingCoachTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingCoachTypes to fetch.
     */
    orderBy?: BookingCoachTypeOrderByWithRelationInput | BookingCoachTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingCoachTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingCoachTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingCoachTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingCoachTypes
    **/
    _count?: true | BookingCoachTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingCoachTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingCoachTypeMaxAggregateInputType
  }

  export type GetBookingCoachTypeAggregateType<T extends BookingCoachTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingCoachType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingCoachType[P]>
      : GetScalarType<T[P], AggregateBookingCoachType[P]>
  }




  export type BookingCoachTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingCoachTypeWhereInput
    orderBy?: BookingCoachTypeOrderByWithAggregationInput | BookingCoachTypeOrderByWithAggregationInput[]
    by: BookingCoachTypeScalarFieldEnum[] | BookingCoachTypeScalarFieldEnum
    having?: BookingCoachTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCoachTypeCountAggregateInputType | true
    _min?: BookingCoachTypeMinAggregateInputType
    _max?: BookingCoachTypeMaxAggregateInputType
  }

  export type BookingCoachTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BookingCoachTypeCountAggregateOutputType | null
    _min: BookingCoachTypeMinAggregateOutputType | null
    _max: BookingCoachTypeMaxAggregateOutputType | null
  }

  type GetBookingCoachTypeGroupByPayload<T extends BookingCoachTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingCoachTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingCoachTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingCoachTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BookingCoachTypeGroupByOutputType[P]>
        }
      >
    >


  export type BookingCoachTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingCoach?: boolean | BookingCoachType$bookingCoachArgs<ExtArgs>
    coachTypeStaffPrice?: boolean | BookingCoachType$coachTypeStaffPriceArgs<ExtArgs>
    _count?: boolean | BookingCoachTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingCoachType"]>

  export type BookingCoachTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bookingCoachType"]>

  export type BookingCoachTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bookingCoachType"]>

  export type BookingCoachTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingCoachTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["bookingCoachType"]>
  export type BookingCoachTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingCoach?: boolean | BookingCoachType$bookingCoachArgs<ExtArgs>
    coachTypeStaffPrice?: boolean | BookingCoachType$coachTypeStaffPriceArgs<ExtArgs>
    _count?: boolean | BookingCoachTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingCoachTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BookingCoachTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BookingCoachTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingCoachType"
    objects: {
      bookingCoach: Prisma.$BookingCoachPayload<ExtArgs>[]
      coachTypeStaffPrice: Prisma.$CoachTypeStaffPricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookingCoachType"]>
    composites: {}
  }

  type BookingCoachTypeGetPayload<S extends boolean | null | undefined | BookingCoachTypeDefaultArgs> = $Result.GetResult<Prisma.$BookingCoachTypePayload, S>

  type BookingCoachTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingCoachTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCoachTypeCountAggregateInputType | true
    }

  export interface BookingCoachTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingCoachType'], meta: { name: 'BookingCoachType' } }
    /**
     * Find zero or one BookingCoachType that matches the filter.
     * @param {BookingCoachTypeFindUniqueArgs} args - Arguments to find a BookingCoachType
     * @example
     * // Get one BookingCoachType
     * const bookingCoachType = await prisma.bookingCoachType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingCoachTypeFindUniqueArgs>(args: SelectSubset<T, BookingCoachTypeFindUniqueArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingCoachType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingCoachTypeFindUniqueOrThrowArgs} args - Arguments to find a BookingCoachType
     * @example
     * // Get one BookingCoachType
     * const bookingCoachType = await prisma.bookingCoachType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingCoachTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingCoachTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingCoachType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachTypeFindFirstArgs} args - Arguments to find a BookingCoachType
     * @example
     * // Get one BookingCoachType
     * const bookingCoachType = await prisma.bookingCoachType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingCoachTypeFindFirstArgs>(args?: SelectSubset<T, BookingCoachTypeFindFirstArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingCoachType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachTypeFindFirstOrThrowArgs} args - Arguments to find a BookingCoachType
     * @example
     * // Get one BookingCoachType
     * const bookingCoachType = await prisma.bookingCoachType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingCoachTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingCoachTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingCoachTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingCoachTypes
     * const bookingCoachTypes = await prisma.bookingCoachType.findMany()
     * 
     * // Get first 10 BookingCoachTypes
     * const bookingCoachTypes = await prisma.bookingCoachType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingCoachTypeWithIdOnly = await prisma.bookingCoachType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingCoachTypeFindManyArgs>(args?: SelectSubset<T, BookingCoachTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingCoachType.
     * @param {BookingCoachTypeCreateArgs} args - Arguments to create a BookingCoachType.
     * @example
     * // Create one BookingCoachType
     * const BookingCoachType = await prisma.bookingCoachType.create({
     *   data: {
     *     // ... data to create a BookingCoachType
     *   }
     * })
     * 
     */
    create<T extends BookingCoachTypeCreateArgs>(args: SelectSubset<T, BookingCoachTypeCreateArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingCoachTypes.
     * @param {BookingCoachTypeCreateManyArgs} args - Arguments to create many BookingCoachTypes.
     * @example
     * // Create many BookingCoachTypes
     * const bookingCoachType = await prisma.bookingCoachType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCoachTypeCreateManyArgs>(args?: SelectSubset<T, BookingCoachTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingCoachTypes and returns the data saved in the database.
     * @param {BookingCoachTypeCreateManyAndReturnArgs} args - Arguments to create many BookingCoachTypes.
     * @example
     * // Create many BookingCoachTypes
     * const bookingCoachType = await prisma.bookingCoachType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingCoachTypes and only return the `id`
     * const bookingCoachTypeWithIdOnly = await prisma.bookingCoachType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCoachTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCoachTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingCoachType.
     * @param {BookingCoachTypeDeleteArgs} args - Arguments to delete one BookingCoachType.
     * @example
     * // Delete one BookingCoachType
     * const BookingCoachType = await prisma.bookingCoachType.delete({
     *   where: {
     *     // ... filter to delete one BookingCoachType
     *   }
     * })
     * 
     */
    delete<T extends BookingCoachTypeDeleteArgs>(args: SelectSubset<T, BookingCoachTypeDeleteArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingCoachType.
     * @param {BookingCoachTypeUpdateArgs} args - Arguments to update one BookingCoachType.
     * @example
     * // Update one BookingCoachType
     * const bookingCoachType = await prisma.bookingCoachType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingCoachTypeUpdateArgs>(args: SelectSubset<T, BookingCoachTypeUpdateArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingCoachTypes.
     * @param {BookingCoachTypeDeleteManyArgs} args - Arguments to filter BookingCoachTypes to delete.
     * @example
     * // Delete a few BookingCoachTypes
     * const { count } = await prisma.bookingCoachType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingCoachTypeDeleteManyArgs>(args?: SelectSubset<T, BookingCoachTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingCoachTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingCoachTypes
     * const bookingCoachType = await prisma.bookingCoachType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingCoachTypeUpdateManyArgs>(args: SelectSubset<T, BookingCoachTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingCoachTypes and returns the data updated in the database.
     * @param {BookingCoachTypeUpdateManyAndReturnArgs} args - Arguments to update many BookingCoachTypes.
     * @example
     * // Update many BookingCoachTypes
     * const bookingCoachType = await prisma.bookingCoachType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingCoachTypes and only return the `id`
     * const bookingCoachTypeWithIdOnly = await prisma.bookingCoachType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingCoachTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingCoachTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingCoachType.
     * @param {BookingCoachTypeUpsertArgs} args - Arguments to update or create a BookingCoachType.
     * @example
     * // Update or create a BookingCoachType
     * const bookingCoachType = await prisma.bookingCoachType.upsert({
     *   create: {
     *     // ... data to create a BookingCoachType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingCoachType we want to update
     *   }
     * })
     */
    upsert<T extends BookingCoachTypeUpsertArgs>(args: SelectSubset<T, BookingCoachTypeUpsertArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingCoachTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachTypeCountArgs} args - Arguments to filter BookingCoachTypes to count.
     * @example
     * // Count the number of BookingCoachTypes
     * const count = await prisma.bookingCoachType.count({
     *   where: {
     *     // ... the filter for the BookingCoachTypes we want to count
     *   }
     * })
    **/
    count<T extends BookingCoachTypeCountArgs>(
      args?: Subset<T, BookingCoachTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCoachTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingCoachType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingCoachTypeAggregateArgs>(args: Subset<T, BookingCoachTypeAggregateArgs>): Prisma.PrismaPromise<GetBookingCoachTypeAggregateType<T>>

    /**
     * Group by BookingCoachType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingCoachTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingCoachTypeGroupByArgs['orderBy'] }
        : { orderBy?: BookingCoachTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingCoachTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingCoachTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingCoachType model
   */
  readonly fields: BookingCoachTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingCoachType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingCoachTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingCoach<T extends BookingCoachType$bookingCoachArgs<ExtArgs> = {}>(args?: Subset<T, BookingCoachType$bookingCoachArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coachTypeStaffPrice<T extends BookingCoachType$coachTypeStaffPriceArgs<ExtArgs> = {}>(args?: Subset<T, BookingCoachType$coachTypeStaffPriceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingCoachType model
   */
  interface BookingCoachTypeFieldRefs {
    readonly id: FieldRef<"BookingCoachType", 'String'>
    readonly name: FieldRef<"BookingCoachType", 'String'>
    readonly description: FieldRef<"BookingCoachType", 'String'>
    readonly isActive: FieldRef<"BookingCoachType", 'Boolean'>
    readonly createdAt: FieldRef<"BookingCoachType", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingCoachType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingCoachType findUnique
   */
  export type BookingCoachTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoachType to fetch.
     */
    where: BookingCoachTypeWhereUniqueInput
  }

  /**
   * BookingCoachType findUniqueOrThrow
   */
  export type BookingCoachTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoachType to fetch.
     */
    where: BookingCoachTypeWhereUniqueInput
  }

  /**
   * BookingCoachType findFirst
   */
  export type BookingCoachTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoachType to fetch.
     */
    where?: BookingCoachTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingCoachTypes to fetch.
     */
    orderBy?: BookingCoachTypeOrderByWithRelationInput | BookingCoachTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingCoachTypes.
     */
    cursor?: BookingCoachTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingCoachTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingCoachTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingCoachTypes.
     */
    distinct?: BookingCoachTypeScalarFieldEnum | BookingCoachTypeScalarFieldEnum[]
  }

  /**
   * BookingCoachType findFirstOrThrow
   */
  export type BookingCoachTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoachType to fetch.
     */
    where?: BookingCoachTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingCoachTypes to fetch.
     */
    orderBy?: BookingCoachTypeOrderByWithRelationInput | BookingCoachTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingCoachTypes.
     */
    cursor?: BookingCoachTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingCoachTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingCoachTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingCoachTypes.
     */
    distinct?: BookingCoachTypeScalarFieldEnum | BookingCoachTypeScalarFieldEnum[]
  }

  /**
   * BookingCoachType findMany
   */
  export type BookingCoachTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoachTypes to fetch.
     */
    where?: BookingCoachTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingCoachTypes to fetch.
     */
    orderBy?: BookingCoachTypeOrderByWithRelationInput | BookingCoachTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingCoachTypes.
     */
    cursor?: BookingCoachTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingCoachTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingCoachTypes.
     */
    skip?: number
    distinct?: BookingCoachTypeScalarFieldEnum | BookingCoachTypeScalarFieldEnum[]
  }

  /**
   * BookingCoachType create
   */
  export type BookingCoachTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingCoachType.
     */
    data: XOR<BookingCoachTypeCreateInput, BookingCoachTypeUncheckedCreateInput>
  }

  /**
   * BookingCoachType createMany
   */
  export type BookingCoachTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingCoachTypes.
     */
    data: BookingCoachTypeCreateManyInput | BookingCoachTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingCoachType createManyAndReturn
   */
  export type BookingCoachTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * The data used to create many BookingCoachTypes.
     */
    data: BookingCoachTypeCreateManyInput | BookingCoachTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingCoachType update
   */
  export type BookingCoachTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingCoachType.
     */
    data: XOR<BookingCoachTypeUpdateInput, BookingCoachTypeUncheckedUpdateInput>
    /**
     * Choose, which BookingCoachType to update.
     */
    where: BookingCoachTypeWhereUniqueInput
  }

  /**
   * BookingCoachType updateMany
   */
  export type BookingCoachTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingCoachTypes.
     */
    data: XOR<BookingCoachTypeUpdateManyMutationInput, BookingCoachTypeUncheckedUpdateManyInput>
    /**
     * Filter which BookingCoachTypes to update
     */
    where?: BookingCoachTypeWhereInput
    /**
     * Limit how many BookingCoachTypes to update.
     */
    limit?: number
  }

  /**
   * BookingCoachType updateManyAndReturn
   */
  export type BookingCoachTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * The data used to update BookingCoachTypes.
     */
    data: XOR<BookingCoachTypeUpdateManyMutationInput, BookingCoachTypeUncheckedUpdateManyInput>
    /**
     * Filter which BookingCoachTypes to update
     */
    where?: BookingCoachTypeWhereInput
    /**
     * Limit how many BookingCoachTypes to update.
     */
    limit?: number
  }

  /**
   * BookingCoachType upsert
   */
  export type BookingCoachTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingCoachType to update in case it exists.
     */
    where: BookingCoachTypeWhereUniqueInput
    /**
     * In case the BookingCoachType found by the `where` argument doesn't exist, create a new BookingCoachType with this data.
     */
    create: XOR<BookingCoachTypeCreateInput, BookingCoachTypeUncheckedCreateInput>
    /**
     * In case the BookingCoachType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingCoachTypeUpdateInput, BookingCoachTypeUncheckedUpdateInput>
  }

  /**
   * BookingCoachType delete
   */
  export type BookingCoachTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
    /**
     * Filter which BookingCoachType to delete.
     */
    where: BookingCoachTypeWhereUniqueInput
  }

  /**
   * BookingCoachType deleteMany
   */
  export type BookingCoachTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingCoachTypes to delete
     */
    where?: BookingCoachTypeWhereInput
    /**
     * Limit how many BookingCoachTypes to delete.
     */
    limit?: number
  }

  /**
   * BookingCoachType.bookingCoach
   */
  export type BookingCoachType$bookingCoachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    where?: BookingCoachWhereInput
    orderBy?: BookingCoachOrderByWithRelationInput | BookingCoachOrderByWithRelationInput[]
    cursor?: BookingCoachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingCoachScalarFieldEnum | BookingCoachScalarFieldEnum[]
  }

  /**
   * BookingCoachType.coachTypeStaffPrice
   */
  export type BookingCoachType$coachTypeStaffPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    where?: CoachTypeStaffPriceWhereInput
    orderBy?: CoachTypeStaffPriceOrderByWithRelationInput | CoachTypeStaffPriceOrderByWithRelationInput[]
    cursor?: CoachTypeStaffPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachTypeStaffPriceScalarFieldEnum | CoachTypeStaffPriceScalarFieldEnum[]
  }

  /**
   * BookingCoachType without action
   */
  export type BookingCoachTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoachType
     */
    select?: BookingCoachTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoachType
     */
    omit?: BookingCoachTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachTypeInclude<ExtArgs> | null
  }


  /**
   * Model CoachTypeStaffPrice
   */

  export type AggregateCoachTypeStaffPrice = {
    _count: CoachTypeStaffPriceCountAggregateOutputType | null
    _avg: CoachTypeStaffPriceAvgAggregateOutputType | null
    _sum: CoachTypeStaffPriceSumAggregateOutputType | null
    _min: CoachTypeStaffPriceMinAggregateOutputType | null
    _max: CoachTypeStaffPriceMaxAggregateOutputType | null
  }

  export type CoachTypeStaffPriceAvgAggregateOutputType = {
    basePrice: number | null
  }

  export type CoachTypeStaffPriceSumAggregateOutputType = {
    basePrice: bigint | null
  }

  export type CoachTypeStaffPriceMinAggregateOutputType = {
    id: string | null
    staffId: string | null
    coachTypeId: string | null
    basePrice: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachTypeStaffPriceMaxAggregateOutputType = {
    id: string | null
    staffId: string | null
    coachTypeId: string | null
    basePrice: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachTypeStaffPriceCountAggregateOutputType = {
    id: number
    staffId: number
    coachTypeId: number
    basePrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoachTypeStaffPriceAvgAggregateInputType = {
    basePrice?: true
  }

  export type CoachTypeStaffPriceSumAggregateInputType = {
    basePrice?: true
  }

  export type CoachTypeStaffPriceMinAggregateInputType = {
    id?: true
    staffId?: true
    coachTypeId?: true
    basePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachTypeStaffPriceMaxAggregateInputType = {
    id?: true
    staffId?: true
    coachTypeId?: true
    basePrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachTypeStaffPriceCountAggregateInputType = {
    id?: true
    staffId?: true
    coachTypeId?: true
    basePrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoachTypeStaffPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachTypeStaffPrice to aggregate.
     */
    where?: CoachTypeStaffPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachTypeStaffPrices to fetch.
     */
    orderBy?: CoachTypeStaffPriceOrderByWithRelationInput | CoachTypeStaffPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachTypeStaffPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachTypeStaffPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachTypeStaffPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachTypeStaffPrices
    **/
    _count?: true | CoachTypeStaffPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoachTypeStaffPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoachTypeStaffPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachTypeStaffPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachTypeStaffPriceMaxAggregateInputType
  }

  export type GetCoachTypeStaffPriceAggregateType<T extends CoachTypeStaffPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachTypeStaffPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachTypeStaffPrice[P]>
      : GetScalarType<T[P], AggregateCoachTypeStaffPrice[P]>
  }




  export type CoachTypeStaffPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachTypeStaffPriceWhereInput
    orderBy?: CoachTypeStaffPriceOrderByWithAggregationInput | CoachTypeStaffPriceOrderByWithAggregationInput[]
    by: CoachTypeStaffPriceScalarFieldEnum[] | CoachTypeStaffPriceScalarFieldEnum
    having?: CoachTypeStaffPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachTypeStaffPriceCountAggregateInputType | true
    _avg?: CoachTypeStaffPriceAvgAggregateInputType
    _sum?: CoachTypeStaffPriceSumAggregateInputType
    _min?: CoachTypeStaffPriceMinAggregateInputType
    _max?: CoachTypeStaffPriceMaxAggregateInputType
  }

  export type CoachTypeStaffPriceGroupByOutputType = {
    id: string
    staffId: string
    coachTypeId: string
    basePrice: bigint
    createdAt: Date
    updatedAt: Date
    _count: CoachTypeStaffPriceCountAggregateOutputType | null
    _avg: CoachTypeStaffPriceAvgAggregateOutputType | null
    _sum: CoachTypeStaffPriceSumAggregateOutputType | null
    _min: CoachTypeStaffPriceMinAggregateOutputType | null
    _max: CoachTypeStaffPriceMaxAggregateOutputType | null
  }

  type GetCoachTypeStaffPriceGroupByPayload<T extends CoachTypeStaffPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachTypeStaffPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachTypeStaffPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachTypeStaffPriceGroupByOutputType[P]>
            : GetScalarType<T[P], CoachTypeStaffPriceGroupByOutputType[P]>
        }
      >
    >


  export type CoachTypeStaffPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    coachTypeId?: boolean
    basePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    coachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachTypeStaffPrice"]>

  export type CoachTypeStaffPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    coachTypeId?: boolean
    basePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    coachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachTypeStaffPrice"]>

  export type CoachTypeStaffPriceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    staffId?: boolean
    coachTypeId?: boolean
    basePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    coachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachTypeStaffPrice"]>

  export type CoachTypeStaffPriceSelectScalar = {
    id?: boolean
    staffId?: boolean
    coachTypeId?: boolean
    basePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoachTypeStaffPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "staffId" | "coachTypeId" | "basePrice" | "createdAt" | "updatedAt", ExtArgs["result"]["coachTypeStaffPrice"]>
  export type CoachTypeStaffPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    coachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }
  export type CoachTypeStaffPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    coachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }
  export type CoachTypeStaffPriceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    coachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }

  export type $CoachTypeStaffPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachTypeStaffPrice"
    objects: {
      staff: Prisma.$StaffPayload<ExtArgs>
      coachType: Prisma.$BookingCoachTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      staffId: string
      coachTypeId: string
      basePrice: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coachTypeStaffPrice"]>
    composites: {}
  }

  type CoachTypeStaffPriceGetPayload<S extends boolean | null | undefined | CoachTypeStaffPriceDefaultArgs> = $Result.GetResult<Prisma.$CoachTypeStaffPricePayload, S>

  type CoachTypeStaffPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoachTypeStaffPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoachTypeStaffPriceCountAggregateInputType | true
    }

  export interface CoachTypeStaffPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachTypeStaffPrice'], meta: { name: 'CoachTypeStaffPrice' } }
    /**
     * Find zero or one CoachTypeStaffPrice that matches the filter.
     * @param {CoachTypeStaffPriceFindUniqueArgs} args - Arguments to find a CoachTypeStaffPrice
     * @example
     * // Get one CoachTypeStaffPrice
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachTypeStaffPriceFindUniqueArgs>(args: SelectSubset<T, CoachTypeStaffPriceFindUniqueArgs<ExtArgs>>): Prisma__CoachTypeStaffPriceClient<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoachTypeStaffPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoachTypeStaffPriceFindUniqueOrThrowArgs} args - Arguments to find a CoachTypeStaffPrice
     * @example
     * // Get one CoachTypeStaffPrice
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachTypeStaffPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachTypeStaffPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachTypeStaffPriceClient<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoachTypeStaffPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachTypeStaffPriceFindFirstArgs} args - Arguments to find a CoachTypeStaffPrice
     * @example
     * // Get one CoachTypeStaffPrice
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachTypeStaffPriceFindFirstArgs>(args?: SelectSubset<T, CoachTypeStaffPriceFindFirstArgs<ExtArgs>>): Prisma__CoachTypeStaffPriceClient<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoachTypeStaffPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachTypeStaffPriceFindFirstOrThrowArgs} args - Arguments to find a CoachTypeStaffPrice
     * @example
     * // Get one CoachTypeStaffPrice
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachTypeStaffPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachTypeStaffPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachTypeStaffPriceClient<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoachTypeStaffPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachTypeStaffPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachTypeStaffPrices
     * const coachTypeStaffPrices = await prisma.coachTypeStaffPrice.findMany()
     * 
     * // Get first 10 CoachTypeStaffPrices
     * const coachTypeStaffPrices = await prisma.coachTypeStaffPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachTypeStaffPriceWithIdOnly = await prisma.coachTypeStaffPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachTypeStaffPriceFindManyArgs>(args?: SelectSubset<T, CoachTypeStaffPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoachTypeStaffPrice.
     * @param {CoachTypeStaffPriceCreateArgs} args - Arguments to create a CoachTypeStaffPrice.
     * @example
     * // Create one CoachTypeStaffPrice
     * const CoachTypeStaffPrice = await prisma.coachTypeStaffPrice.create({
     *   data: {
     *     // ... data to create a CoachTypeStaffPrice
     *   }
     * })
     * 
     */
    create<T extends CoachTypeStaffPriceCreateArgs>(args: SelectSubset<T, CoachTypeStaffPriceCreateArgs<ExtArgs>>): Prisma__CoachTypeStaffPriceClient<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoachTypeStaffPrices.
     * @param {CoachTypeStaffPriceCreateManyArgs} args - Arguments to create many CoachTypeStaffPrices.
     * @example
     * // Create many CoachTypeStaffPrices
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachTypeStaffPriceCreateManyArgs>(args?: SelectSubset<T, CoachTypeStaffPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachTypeStaffPrices and returns the data saved in the database.
     * @param {CoachTypeStaffPriceCreateManyAndReturnArgs} args - Arguments to create many CoachTypeStaffPrices.
     * @example
     * // Create many CoachTypeStaffPrices
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachTypeStaffPrices and only return the `id`
     * const coachTypeStaffPriceWithIdOnly = await prisma.coachTypeStaffPrice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachTypeStaffPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachTypeStaffPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoachTypeStaffPrice.
     * @param {CoachTypeStaffPriceDeleteArgs} args - Arguments to delete one CoachTypeStaffPrice.
     * @example
     * // Delete one CoachTypeStaffPrice
     * const CoachTypeStaffPrice = await prisma.coachTypeStaffPrice.delete({
     *   where: {
     *     // ... filter to delete one CoachTypeStaffPrice
     *   }
     * })
     * 
     */
    delete<T extends CoachTypeStaffPriceDeleteArgs>(args: SelectSubset<T, CoachTypeStaffPriceDeleteArgs<ExtArgs>>): Prisma__CoachTypeStaffPriceClient<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoachTypeStaffPrice.
     * @param {CoachTypeStaffPriceUpdateArgs} args - Arguments to update one CoachTypeStaffPrice.
     * @example
     * // Update one CoachTypeStaffPrice
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachTypeStaffPriceUpdateArgs>(args: SelectSubset<T, CoachTypeStaffPriceUpdateArgs<ExtArgs>>): Prisma__CoachTypeStaffPriceClient<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoachTypeStaffPrices.
     * @param {CoachTypeStaffPriceDeleteManyArgs} args - Arguments to filter CoachTypeStaffPrices to delete.
     * @example
     * // Delete a few CoachTypeStaffPrices
     * const { count } = await prisma.coachTypeStaffPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachTypeStaffPriceDeleteManyArgs>(args?: SelectSubset<T, CoachTypeStaffPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachTypeStaffPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachTypeStaffPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachTypeStaffPrices
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachTypeStaffPriceUpdateManyArgs>(args: SelectSubset<T, CoachTypeStaffPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachTypeStaffPrices and returns the data updated in the database.
     * @param {CoachTypeStaffPriceUpdateManyAndReturnArgs} args - Arguments to update many CoachTypeStaffPrices.
     * @example
     * // Update many CoachTypeStaffPrices
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoachTypeStaffPrices and only return the `id`
     * const coachTypeStaffPriceWithIdOnly = await prisma.coachTypeStaffPrice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoachTypeStaffPriceUpdateManyAndReturnArgs>(args: SelectSubset<T, CoachTypeStaffPriceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoachTypeStaffPrice.
     * @param {CoachTypeStaffPriceUpsertArgs} args - Arguments to update or create a CoachTypeStaffPrice.
     * @example
     * // Update or create a CoachTypeStaffPrice
     * const coachTypeStaffPrice = await prisma.coachTypeStaffPrice.upsert({
     *   create: {
     *     // ... data to create a CoachTypeStaffPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachTypeStaffPrice we want to update
     *   }
     * })
     */
    upsert<T extends CoachTypeStaffPriceUpsertArgs>(args: SelectSubset<T, CoachTypeStaffPriceUpsertArgs<ExtArgs>>): Prisma__CoachTypeStaffPriceClient<$Result.GetResult<Prisma.$CoachTypeStaffPricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoachTypeStaffPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachTypeStaffPriceCountArgs} args - Arguments to filter CoachTypeStaffPrices to count.
     * @example
     * // Count the number of CoachTypeStaffPrices
     * const count = await prisma.coachTypeStaffPrice.count({
     *   where: {
     *     // ... the filter for the CoachTypeStaffPrices we want to count
     *   }
     * })
    **/
    count<T extends CoachTypeStaffPriceCountArgs>(
      args?: Subset<T, CoachTypeStaffPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachTypeStaffPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachTypeStaffPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachTypeStaffPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachTypeStaffPriceAggregateArgs>(args: Subset<T, CoachTypeStaffPriceAggregateArgs>): Prisma.PrismaPromise<GetCoachTypeStaffPriceAggregateType<T>>

    /**
     * Group by CoachTypeStaffPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachTypeStaffPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachTypeStaffPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachTypeStaffPriceGroupByArgs['orderBy'] }
        : { orderBy?: CoachTypeStaffPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachTypeStaffPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachTypeStaffPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachTypeStaffPrice model
   */
  readonly fields: CoachTypeStaffPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachTypeStaffPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachTypeStaffPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coachType<T extends BookingCoachTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingCoachTypeDefaultArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachTypeStaffPrice model
   */
  interface CoachTypeStaffPriceFieldRefs {
    readonly id: FieldRef<"CoachTypeStaffPrice", 'String'>
    readonly staffId: FieldRef<"CoachTypeStaffPrice", 'String'>
    readonly coachTypeId: FieldRef<"CoachTypeStaffPrice", 'String'>
    readonly basePrice: FieldRef<"CoachTypeStaffPrice", 'BigInt'>
    readonly createdAt: FieldRef<"CoachTypeStaffPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"CoachTypeStaffPrice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachTypeStaffPrice findUnique
   */
  export type CoachTypeStaffPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    /**
     * Filter, which CoachTypeStaffPrice to fetch.
     */
    where: CoachTypeStaffPriceWhereUniqueInput
  }

  /**
   * CoachTypeStaffPrice findUniqueOrThrow
   */
  export type CoachTypeStaffPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    /**
     * Filter, which CoachTypeStaffPrice to fetch.
     */
    where: CoachTypeStaffPriceWhereUniqueInput
  }

  /**
   * CoachTypeStaffPrice findFirst
   */
  export type CoachTypeStaffPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    /**
     * Filter, which CoachTypeStaffPrice to fetch.
     */
    where?: CoachTypeStaffPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachTypeStaffPrices to fetch.
     */
    orderBy?: CoachTypeStaffPriceOrderByWithRelationInput | CoachTypeStaffPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachTypeStaffPrices.
     */
    cursor?: CoachTypeStaffPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachTypeStaffPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachTypeStaffPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachTypeStaffPrices.
     */
    distinct?: CoachTypeStaffPriceScalarFieldEnum | CoachTypeStaffPriceScalarFieldEnum[]
  }

  /**
   * CoachTypeStaffPrice findFirstOrThrow
   */
  export type CoachTypeStaffPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    /**
     * Filter, which CoachTypeStaffPrice to fetch.
     */
    where?: CoachTypeStaffPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachTypeStaffPrices to fetch.
     */
    orderBy?: CoachTypeStaffPriceOrderByWithRelationInput | CoachTypeStaffPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachTypeStaffPrices.
     */
    cursor?: CoachTypeStaffPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachTypeStaffPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachTypeStaffPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachTypeStaffPrices.
     */
    distinct?: CoachTypeStaffPriceScalarFieldEnum | CoachTypeStaffPriceScalarFieldEnum[]
  }

  /**
   * CoachTypeStaffPrice findMany
   */
  export type CoachTypeStaffPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    /**
     * Filter, which CoachTypeStaffPrices to fetch.
     */
    where?: CoachTypeStaffPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachTypeStaffPrices to fetch.
     */
    orderBy?: CoachTypeStaffPriceOrderByWithRelationInput | CoachTypeStaffPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachTypeStaffPrices.
     */
    cursor?: CoachTypeStaffPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachTypeStaffPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachTypeStaffPrices.
     */
    skip?: number
    distinct?: CoachTypeStaffPriceScalarFieldEnum | CoachTypeStaffPriceScalarFieldEnum[]
  }

  /**
   * CoachTypeStaffPrice create
   */
  export type CoachTypeStaffPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachTypeStaffPrice.
     */
    data: XOR<CoachTypeStaffPriceCreateInput, CoachTypeStaffPriceUncheckedCreateInput>
  }

  /**
   * CoachTypeStaffPrice createMany
   */
  export type CoachTypeStaffPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachTypeStaffPrices.
     */
    data: CoachTypeStaffPriceCreateManyInput | CoachTypeStaffPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachTypeStaffPrice createManyAndReturn
   */
  export type CoachTypeStaffPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * The data used to create many CoachTypeStaffPrices.
     */
    data: CoachTypeStaffPriceCreateManyInput | CoachTypeStaffPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachTypeStaffPrice update
   */
  export type CoachTypeStaffPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachTypeStaffPrice.
     */
    data: XOR<CoachTypeStaffPriceUpdateInput, CoachTypeStaffPriceUncheckedUpdateInput>
    /**
     * Choose, which CoachTypeStaffPrice to update.
     */
    where: CoachTypeStaffPriceWhereUniqueInput
  }

  /**
   * CoachTypeStaffPrice updateMany
   */
  export type CoachTypeStaffPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachTypeStaffPrices.
     */
    data: XOR<CoachTypeStaffPriceUpdateManyMutationInput, CoachTypeStaffPriceUncheckedUpdateManyInput>
    /**
     * Filter which CoachTypeStaffPrices to update
     */
    where?: CoachTypeStaffPriceWhereInput
    /**
     * Limit how many CoachTypeStaffPrices to update.
     */
    limit?: number
  }

  /**
   * CoachTypeStaffPrice updateManyAndReturn
   */
  export type CoachTypeStaffPriceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * The data used to update CoachTypeStaffPrices.
     */
    data: XOR<CoachTypeStaffPriceUpdateManyMutationInput, CoachTypeStaffPriceUncheckedUpdateManyInput>
    /**
     * Filter which CoachTypeStaffPrices to update
     */
    where?: CoachTypeStaffPriceWhereInput
    /**
     * Limit how many CoachTypeStaffPrices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachTypeStaffPrice upsert
   */
  export type CoachTypeStaffPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachTypeStaffPrice to update in case it exists.
     */
    where: CoachTypeStaffPriceWhereUniqueInput
    /**
     * In case the CoachTypeStaffPrice found by the `where` argument doesn't exist, create a new CoachTypeStaffPrice with this data.
     */
    create: XOR<CoachTypeStaffPriceCreateInput, CoachTypeStaffPriceUncheckedCreateInput>
    /**
     * In case the CoachTypeStaffPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachTypeStaffPriceUpdateInput, CoachTypeStaffPriceUncheckedUpdateInput>
  }

  /**
   * CoachTypeStaffPrice delete
   */
  export type CoachTypeStaffPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
    /**
     * Filter which CoachTypeStaffPrice to delete.
     */
    where: CoachTypeStaffPriceWhereUniqueInput
  }

  /**
   * CoachTypeStaffPrice deleteMany
   */
  export type CoachTypeStaffPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachTypeStaffPrices to delete
     */
    where?: CoachTypeStaffPriceWhereInput
    /**
     * Limit how many CoachTypeStaffPrices to delete.
     */
    limit?: number
  }

  /**
   * CoachTypeStaffPrice without action
   */
  export type CoachTypeStaffPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachTypeStaffPrice
     */
    select?: CoachTypeStaffPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoachTypeStaffPrice
     */
    omit?: CoachTypeStaffPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachTypeStaffPriceInclude<ExtArgs> | null
  }


  /**
   * Model BookingCoach
   */

  export type AggregateBookingCoach = {
    _count: BookingCoachCountAggregateOutputType | null
    _avg: BookingCoachAvgAggregateOutputType | null
    _sum: BookingCoachSumAggregateOutputType | null
    _min: BookingCoachMinAggregateOutputType | null
    _max: BookingCoachMaxAggregateOutputType | null
  }

  export type BookingCoachAvgAggregateOutputType = {
    price: number | null
  }

  export type BookingCoachSumAggregateOutputType = {
    price: number | null
  }

  export type BookingCoachMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    slotId: string | null
    bookingCoachTypeId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCoachMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    slotId: string | null
    bookingCoachTypeId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCoachCountAggregateOutputType = {
    id: number
    bookingId: number
    slotId: number
    bookingCoachTypeId: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingCoachAvgAggregateInputType = {
    price?: true
  }

  export type BookingCoachSumAggregateInputType = {
    price?: true
  }

  export type BookingCoachMinAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    bookingCoachTypeId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCoachMaxAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    bookingCoachTypeId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCoachCountAggregateInputType = {
    id?: true
    bookingId?: true
    slotId?: true
    bookingCoachTypeId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingCoachAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingCoach to aggregate.
     */
    where?: BookingCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingCoaches to fetch.
     */
    orderBy?: BookingCoachOrderByWithRelationInput | BookingCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingCoaches
    **/
    _count?: true | BookingCoachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingCoachAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingCoachSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingCoachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingCoachMaxAggregateInputType
  }

  export type GetBookingCoachAggregateType<T extends BookingCoachAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingCoach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingCoach[P]>
      : GetScalarType<T[P], AggregateBookingCoach[P]>
  }




  export type BookingCoachGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingCoachWhereInput
    orderBy?: BookingCoachOrderByWithAggregationInput | BookingCoachOrderByWithAggregationInput[]
    by: BookingCoachScalarFieldEnum[] | BookingCoachScalarFieldEnum
    having?: BookingCoachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCoachCountAggregateInputType | true
    _avg?: BookingCoachAvgAggregateInputType
    _sum?: BookingCoachSumAggregateInputType
    _min?: BookingCoachMinAggregateInputType
    _max?: BookingCoachMaxAggregateInputType
  }

  export type BookingCoachGroupByOutputType = {
    id: string
    bookingId: string
    slotId: string
    bookingCoachTypeId: string
    price: number
    createdAt: Date
    updatedAt: Date
    _count: BookingCoachCountAggregateOutputType | null
    _avg: BookingCoachAvgAggregateOutputType | null
    _sum: BookingCoachSumAggregateOutputType | null
    _min: BookingCoachMinAggregateOutputType | null
    _max: BookingCoachMaxAggregateOutputType | null
  }

  type GetBookingCoachGroupByPayload<T extends BookingCoachGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingCoachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingCoachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingCoachGroupByOutputType[P]>
            : GetScalarType<T[P], BookingCoachGroupByOutputType[P]>
        }
      >
    >


  export type BookingCoachSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    bookingCoachTypeId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    bookingCoachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingCoach"]>

  export type BookingCoachSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    bookingCoachTypeId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    bookingCoachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingCoach"]>

  export type BookingCoachSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    bookingCoachTypeId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    bookingCoachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingCoach"]>

  export type BookingCoachSelectScalar = {
    id?: boolean
    bookingId?: boolean
    slotId?: boolean
    bookingCoachTypeId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingCoachOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "slotId" | "bookingCoachTypeId" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["bookingCoach"]>
  export type BookingCoachInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    bookingCoachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }
  export type BookingCoachIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    bookingCoachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }
  export type BookingCoachIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    slot?: boolean | SlotDefaultArgs<ExtArgs>
    bookingCoachType?: boolean | BookingCoachTypeDefaultArgs<ExtArgs>
  }

  export type $BookingCoachPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingCoach"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      slot: Prisma.$SlotPayload<ExtArgs>
      bookingCoachType: Prisma.$BookingCoachTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      slotId: string
      bookingCoachTypeId: string
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bookingCoach"]>
    composites: {}
  }

  type BookingCoachGetPayload<S extends boolean | null | undefined | BookingCoachDefaultArgs> = $Result.GetResult<Prisma.$BookingCoachPayload, S>

  type BookingCoachCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingCoachFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCoachCountAggregateInputType | true
    }

  export interface BookingCoachDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingCoach'], meta: { name: 'BookingCoach' } }
    /**
     * Find zero or one BookingCoach that matches the filter.
     * @param {BookingCoachFindUniqueArgs} args - Arguments to find a BookingCoach
     * @example
     * // Get one BookingCoach
     * const bookingCoach = await prisma.bookingCoach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingCoachFindUniqueArgs>(args: SelectSubset<T, BookingCoachFindUniqueArgs<ExtArgs>>): Prisma__BookingCoachClient<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingCoach that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingCoachFindUniqueOrThrowArgs} args - Arguments to find a BookingCoach
     * @example
     * // Get one BookingCoach
     * const bookingCoach = await prisma.bookingCoach.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingCoachFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingCoachFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingCoachClient<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingCoach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachFindFirstArgs} args - Arguments to find a BookingCoach
     * @example
     * // Get one BookingCoach
     * const bookingCoach = await prisma.bookingCoach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingCoachFindFirstArgs>(args?: SelectSubset<T, BookingCoachFindFirstArgs<ExtArgs>>): Prisma__BookingCoachClient<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingCoach that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachFindFirstOrThrowArgs} args - Arguments to find a BookingCoach
     * @example
     * // Get one BookingCoach
     * const bookingCoach = await prisma.bookingCoach.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingCoachFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingCoachFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingCoachClient<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingCoaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingCoaches
     * const bookingCoaches = await prisma.bookingCoach.findMany()
     * 
     * // Get first 10 BookingCoaches
     * const bookingCoaches = await prisma.bookingCoach.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingCoachWithIdOnly = await prisma.bookingCoach.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingCoachFindManyArgs>(args?: SelectSubset<T, BookingCoachFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingCoach.
     * @param {BookingCoachCreateArgs} args - Arguments to create a BookingCoach.
     * @example
     * // Create one BookingCoach
     * const BookingCoach = await prisma.bookingCoach.create({
     *   data: {
     *     // ... data to create a BookingCoach
     *   }
     * })
     * 
     */
    create<T extends BookingCoachCreateArgs>(args: SelectSubset<T, BookingCoachCreateArgs<ExtArgs>>): Prisma__BookingCoachClient<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingCoaches.
     * @param {BookingCoachCreateManyArgs} args - Arguments to create many BookingCoaches.
     * @example
     * // Create many BookingCoaches
     * const bookingCoach = await prisma.bookingCoach.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCoachCreateManyArgs>(args?: SelectSubset<T, BookingCoachCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingCoaches and returns the data saved in the database.
     * @param {BookingCoachCreateManyAndReturnArgs} args - Arguments to create many BookingCoaches.
     * @example
     * // Create many BookingCoaches
     * const bookingCoach = await prisma.bookingCoach.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingCoaches and only return the `id`
     * const bookingCoachWithIdOnly = await prisma.bookingCoach.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCoachCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCoachCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingCoach.
     * @param {BookingCoachDeleteArgs} args - Arguments to delete one BookingCoach.
     * @example
     * // Delete one BookingCoach
     * const BookingCoach = await prisma.bookingCoach.delete({
     *   where: {
     *     // ... filter to delete one BookingCoach
     *   }
     * })
     * 
     */
    delete<T extends BookingCoachDeleteArgs>(args: SelectSubset<T, BookingCoachDeleteArgs<ExtArgs>>): Prisma__BookingCoachClient<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingCoach.
     * @param {BookingCoachUpdateArgs} args - Arguments to update one BookingCoach.
     * @example
     * // Update one BookingCoach
     * const bookingCoach = await prisma.bookingCoach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingCoachUpdateArgs>(args: SelectSubset<T, BookingCoachUpdateArgs<ExtArgs>>): Prisma__BookingCoachClient<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingCoaches.
     * @param {BookingCoachDeleteManyArgs} args - Arguments to filter BookingCoaches to delete.
     * @example
     * // Delete a few BookingCoaches
     * const { count } = await prisma.bookingCoach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingCoachDeleteManyArgs>(args?: SelectSubset<T, BookingCoachDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingCoaches
     * const bookingCoach = await prisma.bookingCoach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingCoachUpdateManyArgs>(args: SelectSubset<T, BookingCoachUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingCoaches and returns the data updated in the database.
     * @param {BookingCoachUpdateManyAndReturnArgs} args - Arguments to update many BookingCoaches.
     * @example
     * // Update many BookingCoaches
     * const bookingCoach = await prisma.bookingCoach.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingCoaches and only return the `id`
     * const bookingCoachWithIdOnly = await prisma.bookingCoach.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingCoachUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingCoachUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingCoach.
     * @param {BookingCoachUpsertArgs} args - Arguments to update or create a BookingCoach.
     * @example
     * // Update or create a BookingCoach
     * const bookingCoach = await prisma.bookingCoach.upsert({
     *   create: {
     *     // ... data to create a BookingCoach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingCoach we want to update
     *   }
     * })
     */
    upsert<T extends BookingCoachUpsertArgs>(args: SelectSubset<T, BookingCoachUpsertArgs<ExtArgs>>): Prisma__BookingCoachClient<$Result.GetResult<Prisma.$BookingCoachPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachCountArgs} args - Arguments to filter BookingCoaches to count.
     * @example
     * // Count the number of BookingCoaches
     * const count = await prisma.bookingCoach.count({
     *   where: {
     *     // ... the filter for the BookingCoaches we want to count
     *   }
     * })
    **/
    count<T extends BookingCoachCountArgs>(
      args?: Subset<T, BookingCoachCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCoachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingCoach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingCoachAggregateArgs>(args: Subset<T, BookingCoachAggregateArgs>): Prisma.PrismaPromise<GetBookingCoachAggregateType<T>>

    /**
     * Group by BookingCoach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCoachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingCoachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingCoachGroupByArgs['orderBy'] }
        : { orderBy?: BookingCoachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingCoachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingCoachGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingCoach model
   */
  readonly fields: BookingCoachFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingCoach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingCoachClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    slot<T extends SlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SlotDefaultArgs<ExtArgs>>): Prisma__SlotClient<$Result.GetResult<Prisma.$SlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookingCoachType<T extends BookingCoachTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingCoachTypeDefaultArgs<ExtArgs>>): Prisma__BookingCoachTypeClient<$Result.GetResult<Prisma.$BookingCoachTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingCoach model
   */
  interface BookingCoachFieldRefs {
    readonly id: FieldRef<"BookingCoach", 'String'>
    readonly bookingId: FieldRef<"BookingCoach", 'String'>
    readonly slotId: FieldRef<"BookingCoach", 'String'>
    readonly bookingCoachTypeId: FieldRef<"BookingCoach", 'String'>
    readonly price: FieldRef<"BookingCoach", 'Int'>
    readonly createdAt: FieldRef<"BookingCoach", 'DateTime'>
    readonly updatedAt: FieldRef<"BookingCoach", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingCoach findUnique
   */
  export type BookingCoachFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoach to fetch.
     */
    where: BookingCoachWhereUniqueInput
  }

  /**
   * BookingCoach findUniqueOrThrow
   */
  export type BookingCoachFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoach to fetch.
     */
    where: BookingCoachWhereUniqueInput
  }

  /**
   * BookingCoach findFirst
   */
  export type BookingCoachFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoach to fetch.
     */
    where?: BookingCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingCoaches to fetch.
     */
    orderBy?: BookingCoachOrderByWithRelationInput | BookingCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingCoaches.
     */
    cursor?: BookingCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingCoaches.
     */
    distinct?: BookingCoachScalarFieldEnum | BookingCoachScalarFieldEnum[]
  }

  /**
   * BookingCoach findFirstOrThrow
   */
  export type BookingCoachFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoach to fetch.
     */
    where?: BookingCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingCoaches to fetch.
     */
    orderBy?: BookingCoachOrderByWithRelationInput | BookingCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingCoaches.
     */
    cursor?: BookingCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingCoaches.
     */
    distinct?: BookingCoachScalarFieldEnum | BookingCoachScalarFieldEnum[]
  }

  /**
   * BookingCoach findMany
   */
  export type BookingCoachFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    /**
     * Filter, which BookingCoaches to fetch.
     */
    where?: BookingCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingCoaches to fetch.
     */
    orderBy?: BookingCoachOrderByWithRelationInput | BookingCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingCoaches.
     */
    cursor?: BookingCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingCoaches.
     */
    skip?: number
    distinct?: BookingCoachScalarFieldEnum | BookingCoachScalarFieldEnum[]
  }

  /**
   * BookingCoach create
   */
  export type BookingCoachCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingCoach.
     */
    data: XOR<BookingCoachCreateInput, BookingCoachUncheckedCreateInput>
  }

  /**
   * BookingCoach createMany
   */
  export type BookingCoachCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingCoaches.
     */
    data: BookingCoachCreateManyInput | BookingCoachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingCoach createManyAndReturn
   */
  export type BookingCoachCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * The data used to create many BookingCoaches.
     */
    data: BookingCoachCreateManyInput | BookingCoachCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingCoach update
   */
  export type BookingCoachUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingCoach.
     */
    data: XOR<BookingCoachUpdateInput, BookingCoachUncheckedUpdateInput>
    /**
     * Choose, which BookingCoach to update.
     */
    where: BookingCoachWhereUniqueInput
  }

  /**
   * BookingCoach updateMany
   */
  export type BookingCoachUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingCoaches.
     */
    data: XOR<BookingCoachUpdateManyMutationInput, BookingCoachUncheckedUpdateManyInput>
    /**
     * Filter which BookingCoaches to update
     */
    where?: BookingCoachWhereInput
    /**
     * Limit how many BookingCoaches to update.
     */
    limit?: number
  }

  /**
   * BookingCoach updateManyAndReturn
   */
  export type BookingCoachUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * The data used to update BookingCoaches.
     */
    data: XOR<BookingCoachUpdateManyMutationInput, BookingCoachUncheckedUpdateManyInput>
    /**
     * Filter which BookingCoaches to update
     */
    where?: BookingCoachWhereInput
    /**
     * Limit how many BookingCoaches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingCoach upsert
   */
  export type BookingCoachUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingCoach to update in case it exists.
     */
    where: BookingCoachWhereUniqueInput
    /**
     * In case the BookingCoach found by the `where` argument doesn't exist, create a new BookingCoach with this data.
     */
    create: XOR<BookingCoachCreateInput, BookingCoachUncheckedCreateInput>
    /**
     * In case the BookingCoach was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingCoachUpdateInput, BookingCoachUncheckedUpdateInput>
  }

  /**
   * BookingCoach delete
   */
  export type BookingCoachDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
    /**
     * Filter which BookingCoach to delete.
     */
    where: BookingCoachWhereUniqueInput
  }

  /**
   * BookingCoach deleteMany
   */
  export type BookingCoachDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingCoaches to delete
     */
    where?: BookingCoachWhereInput
    /**
     * Limit how many BookingCoaches to delete.
     */
    limit?: number
  }

  /**
   * BookingCoach without action
   */
  export type BookingCoachDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCoach
     */
    select?: BookingCoachSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingCoach
     */
    omit?: BookingCoachOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingCoachInclude<ExtArgs> | null
  }


  /**
   * Model Membership
   */

  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null
    _avg: MembershipAvgAggregateOutputType | null
    _sum: MembershipSumAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  export type MembershipAvgAggregateOutputType = {
    price: number | null
    sessions: number | null
    duration: number | null
    sequence: number | null
  }

  export type MembershipSumAggregateOutputType = {
    price: number | null
    sessions: number | null
    duration: number | null
    sequence: number | null
  }

  export type MembershipMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    content: string | null
    price: number | null
    sessions: number | null
    duration: number | null
    sequence: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    content: string | null
    price: number | null
    sessions: number | null
    duration: number | null
    sequence: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipCountAggregateOutputType = {
    id: number
    name: number
    description: number
    content: number
    price: number
    sessions: number
    duration: number
    sequence: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipAvgAggregateInputType = {
    price?: true
    sessions?: true
    duration?: true
    sequence?: true
  }

  export type MembershipSumAggregateInputType = {
    price?: true
    sessions?: true
    duration?: true
    sequence?: true
  }

  export type MembershipMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    content?: true
    price?: true
    sessions?: true
    duration?: true
    sequence?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    content?: true
    price?: true
    sessions?: true
    duration?: true
    sequence?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    content?: true
    price?: true
    sessions?: true
    duration?: true
    sequence?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Membership to aggregate.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memberships
    **/
    _count?: true | MembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipMaxAggregateInputType
  }

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>
  }




  export type MembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithAggregationInput | MembershipOrderByWithAggregationInput[]
    by: MembershipScalarFieldEnum[] | MembershipScalarFieldEnum
    having?: MembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipCountAggregateInputType | true
    _avg?: MembershipAvgAggregateInputType
    _sum?: MembershipSumAggregateInputType
    _min?: MembershipMinAggregateInputType
    _max?: MembershipMaxAggregateInputType
  }

  export type MembershipGroupByOutputType = {
    id: string
    name: string
    description: string | null
    content: string | null
    price: number
    sessions: number
    duration: number
    sequence: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MembershipCountAggregateOutputType | null
    _avg: MembershipAvgAggregateOutputType | null
    _sum: MembershipSumAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>
        }
      >
    >


  export type MembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    price?: boolean
    sessions?: boolean
    duration?: boolean
    sequence?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    benefits?: boolean | Membership$benefitsArgs<ExtArgs>
    membershipUser?: boolean | Membership$membershipUserArgs<ExtArgs>
    _count?: boolean | MembershipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    price?: boolean
    sessions?: boolean
    duration?: boolean
    sequence?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    price?: boolean
    sessions?: boolean
    duration?: boolean
    sequence?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    price?: boolean
    sessions?: boolean
    duration?: boolean
    sequence?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "content" | "price" | "sessions" | "duration" | "sequence" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["membership"]>
  export type MembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    benefits?: boolean | Membership$benefitsArgs<ExtArgs>
    membershipUser?: boolean | Membership$membershipUserArgs<ExtArgs>
    _count?: boolean | MembershipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Membership"
    objects: {
      benefits: Prisma.$MembershipBenefitPayload<ExtArgs>[]
      membershipUser: Prisma.$MembershipUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      content: string | null
      price: number
      sessions: number
      duration: number
      sequence: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membership"]>
    composites: {}
  }

  type MembershipGetPayload<S extends boolean | null | undefined | MembershipDefaultArgs> = $Result.GetResult<Prisma.$MembershipPayload, S>

  type MembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipCountAggregateInputType | true
    }

  export interface MembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Membership'], meta: { name: 'Membership' } }
    /**
     * Find zero or one Membership that matches the filter.
     * @param {MembershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipFindUniqueArgs>(args: SelectSubset<T, MembershipFindUniqueArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Membership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipFindUniqueOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipFindFirstArgs>(args?: SelectSubset<T, MembershipFindFirstArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     * 
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipWithIdOnly = await prisma.membership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipFindManyArgs>(args?: SelectSubset<T, MembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Membership.
     * @param {MembershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     * 
     */
    create<T extends MembershipCreateArgs>(args: SelectSubset<T, MembershipCreateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Memberships.
     * @param {MembershipCreateManyArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipCreateManyArgs>(args?: SelectSubset<T, MembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memberships and returns the data saved in the database.
     * @param {MembershipCreateManyAndReturnArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Membership.
     * @param {MembershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     * 
     */
    delete<T extends MembershipDeleteArgs>(args: SelectSubset<T, MembershipDeleteArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Membership.
     * @param {MembershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipUpdateArgs>(args: SelectSubset<T, MembershipUpdateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Memberships.
     * @param {MembershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipDeleteManyArgs>(args?: SelectSubset<T, MembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipUpdateManyArgs>(args: SelectSubset<T, MembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships and returns the data updated in the database.
     * @param {MembershipUpdateManyAndReturnArgs} args - Arguments to update many Memberships.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Membership.
     * @param {MembershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUpsertArgs>(args: SelectSubset<T, MembershipUpsertArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
    **/
    count<T extends MembershipCountArgs>(
      args?: Subset<T, MembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipAggregateArgs>(args: Subset<T, MembershipAggregateArgs>): Prisma.PrismaPromise<GetMembershipAggregateType<T>>

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Membership model
   */
  readonly fields: MembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    benefits<T extends Membership$benefitsArgs<ExtArgs> = {}>(args?: Subset<T, Membership$benefitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    membershipUser<T extends Membership$membershipUserArgs<ExtArgs> = {}>(args?: Subset<T, Membership$membershipUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Membership model
   */
  interface MembershipFieldRefs {
    readonly id: FieldRef<"Membership", 'String'>
    readonly name: FieldRef<"Membership", 'String'>
    readonly description: FieldRef<"Membership", 'String'>
    readonly content: FieldRef<"Membership", 'String'>
    readonly price: FieldRef<"Membership", 'Int'>
    readonly sessions: FieldRef<"Membership", 'Int'>
    readonly duration: FieldRef<"Membership", 'Int'>
    readonly sequence: FieldRef<"Membership", 'Int'>
    readonly isActive: FieldRef<"Membership", 'Boolean'>
    readonly createdAt: FieldRef<"Membership", 'DateTime'>
    readonly updatedAt: FieldRef<"Membership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Membership findUnique
   */
  export type MembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findUniqueOrThrow
   */
  export type MembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findFirst
   */
  export type MembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findFirstOrThrow
   */
  export type MembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findMany
   */
  export type MembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership create
   */
  export type MembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a Membership.
     */
    data: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
  }

  /**
   * Membership createMany
   */
  export type MembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Membership createManyAndReturn
   */
  export type MembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Membership update
   */
  export type MembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a Membership.
     */
    data: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
    /**
     * Choose, which Membership to update.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership updateMany
   */
  export type MembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
  }

  /**
   * Membership updateManyAndReturn
   */
  export type MembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
  }

  /**
   * Membership upsert
   */
  export type MembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the Membership to update in case it exists.
     */
    where: MembershipWhereUniqueInput
    /**
     * In case the Membership found by the `where` argument doesn't exist, create a new Membership with this data.
     */
    create: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
    /**
     * In case the Membership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
  }

  /**
   * Membership delete
   */
  export type MembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter which Membership to delete.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership deleteMany
   */
  export type MembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memberships to delete
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to delete.
     */
    limit?: number
  }

  /**
   * Membership.benefits
   */
  export type Membership$benefitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    where?: MembershipBenefitWhereInput
    orderBy?: MembershipBenefitOrderByWithRelationInput | MembershipBenefitOrderByWithRelationInput[]
    cursor?: MembershipBenefitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipBenefitScalarFieldEnum | MembershipBenefitScalarFieldEnum[]
  }

  /**
   * Membership.membershipUser
   */
  export type Membership$membershipUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    where?: MembershipUserWhereInput
    orderBy?: MembershipUserOrderByWithRelationInput | MembershipUserOrderByWithRelationInput[]
    cursor?: MembershipUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipUserScalarFieldEnum | MembershipUserScalarFieldEnum[]
  }

  /**
   * Membership without action
   */
  export type MembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
  }


  /**
   * Model MembershipBenefit
   */

  export type AggregateMembershipBenefit = {
    _count: MembershipBenefitCountAggregateOutputType | null
    _min: MembershipBenefitMinAggregateOutputType | null
    _max: MembershipBenefitMaxAggregateOutputType | null
  }

  export type MembershipBenefitMinAggregateOutputType = {
    id: string | null
    membershipId: string | null
    benefit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipBenefitMaxAggregateOutputType = {
    id: string | null
    membershipId: string | null
    benefit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipBenefitCountAggregateOutputType = {
    id: number
    membershipId: number
    benefit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipBenefitMinAggregateInputType = {
    id?: true
    membershipId?: true
    benefit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipBenefitMaxAggregateInputType = {
    id?: true
    membershipId?: true
    benefit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipBenefitCountAggregateInputType = {
    id?: true
    membershipId?: true
    benefit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipBenefitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipBenefit to aggregate.
     */
    where?: MembershipBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipBenefits to fetch.
     */
    orderBy?: MembershipBenefitOrderByWithRelationInput | MembershipBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MembershipBenefits
    **/
    _count?: true | MembershipBenefitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipBenefitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipBenefitMaxAggregateInputType
  }

  export type GetMembershipBenefitAggregateType<T extends MembershipBenefitAggregateArgs> = {
        [P in keyof T & keyof AggregateMembershipBenefit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembershipBenefit[P]>
      : GetScalarType<T[P], AggregateMembershipBenefit[P]>
  }




  export type MembershipBenefitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipBenefitWhereInput
    orderBy?: MembershipBenefitOrderByWithAggregationInput | MembershipBenefitOrderByWithAggregationInput[]
    by: MembershipBenefitScalarFieldEnum[] | MembershipBenefitScalarFieldEnum
    having?: MembershipBenefitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipBenefitCountAggregateInputType | true
    _min?: MembershipBenefitMinAggregateInputType
    _max?: MembershipBenefitMaxAggregateInputType
  }

  export type MembershipBenefitGroupByOutputType = {
    id: string
    membershipId: string
    benefit: string
    createdAt: Date
    updatedAt: Date
    _count: MembershipBenefitCountAggregateOutputType | null
    _min: MembershipBenefitMinAggregateOutputType | null
    _max: MembershipBenefitMaxAggregateOutputType | null
  }

  type GetMembershipBenefitGroupByPayload<T extends MembershipBenefitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipBenefitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipBenefitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipBenefitGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipBenefitGroupByOutputType[P]>
        }
      >
    >


  export type MembershipBenefitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    membershipId?: boolean
    benefit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipBenefit"]>

  export type MembershipBenefitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    membershipId?: boolean
    benefit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipBenefit"]>

  export type MembershipBenefitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    membershipId?: boolean
    benefit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipBenefit"]>

  export type MembershipBenefitSelectScalar = {
    id?: boolean
    membershipId?: boolean
    benefit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipBenefitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "membershipId" | "benefit" | "createdAt" | "updatedAt", ExtArgs["result"]["membershipBenefit"]>
  export type MembershipBenefitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }
  export type MembershipBenefitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }
  export type MembershipBenefitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }

  export type $MembershipBenefitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MembershipBenefit"
    objects: {
      membership: Prisma.$MembershipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      membershipId: string
      benefit: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membershipBenefit"]>
    composites: {}
  }

  type MembershipBenefitGetPayload<S extends boolean | null | undefined | MembershipBenefitDefaultArgs> = $Result.GetResult<Prisma.$MembershipBenefitPayload, S>

  type MembershipBenefitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipBenefitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipBenefitCountAggregateInputType | true
    }

  export interface MembershipBenefitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MembershipBenefit'], meta: { name: 'MembershipBenefit' } }
    /**
     * Find zero or one MembershipBenefit that matches the filter.
     * @param {MembershipBenefitFindUniqueArgs} args - Arguments to find a MembershipBenefit
     * @example
     * // Get one MembershipBenefit
     * const membershipBenefit = await prisma.membershipBenefit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipBenefitFindUniqueArgs>(args: SelectSubset<T, MembershipBenefitFindUniqueArgs<ExtArgs>>): Prisma__MembershipBenefitClient<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MembershipBenefit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipBenefitFindUniqueOrThrowArgs} args - Arguments to find a MembershipBenefit
     * @example
     * // Get one MembershipBenefit
     * const membershipBenefit = await prisma.membershipBenefit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipBenefitFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipBenefitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipBenefitClient<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipBenefit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipBenefitFindFirstArgs} args - Arguments to find a MembershipBenefit
     * @example
     * // Get one MembershipBenefit
     * const membershipBenefit = await prisma.membershipBenefit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipBenefitFindFirstArgs>(args?: SelectSubset<T, MembershipBenefitFindFirstArgs<ExtArgs>>): Prisma__MembershipBenefitClient<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipBenefit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipBenefitFindFirstOrThrowArgs} args - Arguments to find a MembershipBenefit
     * @example
     * // Get one MembershipBenefit
     * const membershipBenefit = await prisma.membershipBenefit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipBenefitFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipBenefitFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipBenefitClient<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MembershipBenefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipBenefitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembershipBenefits
     * const membershipBenefits = await prisma.membershipBenefit.findMany()
     * 
     * // Get first 10 MembershipBenefits
     * const membershipBenefits = await prisma.membershipBenefit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipBenefitWithIdOnly = await prisma.membershipBenefit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipBenefitFindManyArgs>(args?: SelectSubset<T, MembershipBenefitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MembershipBenefit.
     * @param {MembershipBenefitCreateArgs} args - Arguments to create a MembershipBenefit.
     * @example
     * // Create one MembershipBenefit
     * const MembershipBenefit = await prisma.membershipBenefit.create({
     *   data: {
     *     // ... data to create a MembershipBenefit
     *   }
     * })
     * 
     */
    create<T extends MembershipBenefitCreateArgs>(args: SelectSubset<T, MembershipBenefitCreateArgs<ExtArgs>>): Prisma__MembershipBenefitClient<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MembershipBenefits.
     * @param {MembershipBenefitCreateManyArgs} args - Arguments to create many MembershipBenefits.
     * @example
     * // Create many MembershipBenefits
     * const membershipBenefit = await prisma.membershipBenefit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipBenefitCreateManyArgs>(args?: SelectSubset<T, MembershipBenefitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MembershipBenefits and returns the data saved in the database.
     * @param {MembershipBenefitCreateManyAndReturnArgs} args - Arguments to create many MembershipBenefits.
     * @example
     * // Create many MembershipBenefits
     * const membershipBenefit = await prisma.membershipBenefit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MembershipBenefits and only return the `id`
     * const membershipBenefitWithIdOnly = await prisma.membershipBenefit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipBenefitCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipBenefitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MembershipBenefit.
     * @param {MembershipBenefitDeleteArgs} args - Arguments to delete one MembershipBenefit.
     * @example
     * // Delete one MembershipBenefit
     * const MembershipBenefit = await prisma.membershipBenefit.delete({
     *   where: {
     *     // ... filter to delete one MembershipBenefit
     *   }
     * })
     * 
     */
    delete<T extends MembershipBenefitDeleteArgs>(args: SelectSubset<T, MembershipBenefitDeleteArgs<ExtArgs>>): Prisma__MembershipBenefitClient<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MembershipBenefit.
     * @param {MembershipBenefitUpdateArgs} args - Arguments to update one MembershipBenefit.
     * @example
     * // Update one MembershipBenefit
     * const membershipBenefit = await prisma.membershipBenefit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipBenefitUpdateArgs>(args: SelectSubset<T, MembershipBenefitUpdateArgs<ExtArgs>>): Prisma__MembershipBenefitClient<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MembershipBenefits.
     * @param {MembershipBenefitDeleteManyArgs} args - Arguments to filter MembershipBenefits to delete.
     * @example
     * // Delete a few MembershipBenefits
     * const { count } = await prisma.membershipBenefit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipBenefitDeleteManyArgs>(args?: SelectSubset<T, MembershipBenefitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipBenefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipBenefitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembershipBenefits
     * const membershipBenefit = await prisma.membershipBenefit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipBenefitUpdateManyArgs>(args: SelectSubset<T, MembershipBenefitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipBenefits and returns the data updated in the database.
     * @param {MembershipBenefitUpdateManyAndReturnArgs} args - Arguments to update many MembershipBenefits.
     * @example
     * // Update many MembershipBenefits
     * const membershipBenefit = await prisma.membershipBenefit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MembershipBenefits and only return the `id`
     * const membershipBenefitWithIdOnly = await prisma.membershipBenefit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipBenefitUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipBenefitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MembershipBenefit.
     * @param {MembershipBenefitUpsertArgs} args - Arguments to update or create a MembershipBenefit.
     * @example
     * // Update or create a MembershipBenefit
     * const membershipBenefit = await prisma.membershipBenefit.upsert({
     *   create: {
     *     // ... data to create a MembershipBenefit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembershipBenefit we want to update
     *   }
     * })
     */
    upsert<T extends MembershipBenefitUpsertArgs>(args: SelectSubset<T, MembershipBenefitUpsertArgs<ExtArgs>>): Prisma__MembershipBenefitClient<$Result.GetResult<Prisma.$MembershipBenefitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MembershipBenefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipBenefitCountArgs} args - Arguments to filter MembershipBenefits to count.
     * @example
     * // Count the number of MembershipBenefits
     * const count = await prisma.membershipBenefit.count({
     *   where: {
     *     // ... the filter for the MembershipBenefits we want to count
     *   }
     * })
    **/
    count<T extends MembershipBenefitCountArgs>(
      args?: Subset<T, MembershipBenefitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipBenefitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembershipBenefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipBenefitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipBenefitAggregateArgs>(args: Subset<T, MembershipBenefitAggregateArgs>): Prisma.PrismaPromise<GetMembershipBenefitAggregateType<T>>

    /**
     * Group by MembershipBenefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipBenefitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipBenefitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipBenefitGroupByArgs['orderBy'] }
        : { orderBy?: MembershipBenefitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipBenefitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipBenefitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MembershipBenefit model
   */
  readonly fields: MembershipBenefitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MembershipBenefit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipBenefitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    membership<T extends MembershipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MembershipDefaultArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MembershipBenefit model
   */
  interface MembershipBenefitFieldRefs {
    readonly id: FieldRef<"MembershipBenefit", 'String'>
    readonly membershipId: FieldRef<"MembershipBenefit", 'String'>
    readonly benefit: FieldRef<"MembershipBenefit", 'String'>
    readonly createdAt: FieldRef<"MembershipBenefit", 'DateTime'>
    readonly updatedAt: FieldRef<"MembershipBenefit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MembershipBenefit findUnique
   */
  export type MembershipBenefitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    /**
     * Filter, which MembershipBenefit to fetch.
     */
    where: MembershipBenefitWhereUniqueInput
  }

  /**
   * MembershipBenefit findUniqueOrThrow
   */
  export type MembershipBenefitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    /**
     * Filter, which MembershipBenefit to fetch.
     */
    where: MembershipBenefitWhereUniqueInput
  }

  /**
   * MembershipBenefit findFirst
   */
  export type MembershipBenefitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    /**
     * Filter, which MembershipBenefit to fetch.
     */
    where?: MembershipBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipBenefits to fetch.
     */
    orderBy?: MembershipBenefitOrderByWithRelationInput | MembershipBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipBenefits.
     */
    cursor?: MembershipBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipBenefits.
     */
    distinct?: MembershipBenefitScalarFieldEnum | MembershipBenefitScalarFieldEnum[]
  }

  /**
   * MembershipBenefit findFirstOrThrow
   */
  export type MembershipBenefitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    /**
     * Filter, which MembershipBenefit to fetch.
     */
    where?: MembershipBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipBenefits to fetch.
     */
    orderBy?: MembershipBenefitOrderByWithRelationInput | MembershipBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipBenefits.
     */
    cursor?: MembershipBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipBenefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipBenefits.
     */
    distinct?: MembershipBenefitScalarFieldEnum | MembershipBenefitScalarFieldEnum[]
  }

  /**
   * MembershipBenefit findMany
   */
  export type MembershipBenefitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    /**
     * Filter, which MembershipBenefits to fetch.
     */
    where?: MembershipBenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipBenefits to fetch.
     */
    orderBy?: MembershipBenefitOrderByWithRelationInput | MembershipBenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MembershipBenefits.
     */
    cursor?: MembershipBenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipBenefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipBenefits.
     */
    skip?: number
    distinct?: MembershipBenefitScalarFieldEnum | MembershipBenefitScalarFieldEnum[]
  }

  /**
   * MembershipBenefit create
   */
  export type MembershipBenefitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    /**
     * The data needed to create a MembershipBenefit.
     */
    data: XOR<MembershipBenefitCreateInput, MembershipBenefitUncheckedCreateInput>
  }

  /**
   * MembershipBenefit createMany
   */
  export type MembershipBenefitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MembershipBenefits.
     */
    data: MembershipBenefitCreateManyInput | MembershipBenefitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MembershipBenefit createManyAndReturn
   */
  export type MembershipBenefitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * The data used to create many MembershipBenefits.
     */
    data: MembershipBenefitCreateManyInput | MembershipBenefitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MembershipBenefit update
   */
  export type MembershipBenefitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    /**
     * The data needed to update a MembershipBenefit.
     */
    data: XOR<MembershipBenefitUpdateInput, MembershipBenefitUncheckedUpdateInput>
    /**
     * Choose, which MembershipBenefit to update.
     */
    where: MembershipBenefitWhereUniqueInput
  }

  /**
   * MembershipBenefit updateMany
   */
  export type MembershipBenefitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MembershipBenefits.
     */
    data: XOR<MembershipBenefitUpdateManyMutationInput, MembershipBenefitUncheckedUpdateManyInput>
    /**
     * Filter which MembershipBenefits to update
     */
    where?: MembershipBenefitWhereInput
    /**
     * Limit how many MembershipBenefits to update.
     */
    limit?: number
  }

  /**
   * MembershipBenefit updateManyAndReturn
   */
  export type MembershipBenefitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * The data used to update MembershipBenefits.
     */
    data: XOR<MembershipBenefitUpdateManyMutationInput, MembershipBenefitUncheckedUpdateManyInput>
    /**
     * Filter which MembershipBenefits to update
     */
    where?: MembershipBenefitWhereInput
    /**
     * Limit how many MembershipBenefits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MembershipBenefit upsert
   */
  export type MembershipBenefitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    /**
     * The filter to search for the MembershipBenefit to update in case it exists.
     */
    where: MembershipBenefitWhereUniqueInput
    /**
     * In case the MembershipBenefit found by the `where` argument doesn't exist, create a new MembershipBenefit with this data.
     */
    create: XOR<MembershipBenefitCreateInput, MembershipBenefitUncheckedCreateInput>
    /**
     * In case the MembershipBenefit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipBenefitUpdateInput, MembershipBenefitUncheckedUpdateInput>
  }

  /**
   * MembershipBenefit delete
   */
  export type MembershipBenefitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
    /**
     * Filter which MembershipBenefit to delete.
     */
    where: MembershipBenefitWhereUniqueInput
  }

  /**
   * MembershipBenefit deleteMany
   */
  export type MembershipBenefitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipBenefits to delete
     */
    where?: MembershipBenefitWhereInput
    /**
     * Limit how many MembershipBenefits to delete.
     */
    limit?: number
  }

  /**
   * MembershipBenefit without action
   */
  export type MembershipBenefitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipBenefit
     */
    select?: MembershipBenefitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipBenefit
     */
    omit?: MembershipBenefitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipBenefitInclude<ExtArgs> | null
  }


  /**
   * Model MembershipUser
   */

  export type AggregateMembershipUser = {
    _count: MembershipUserCountAggregateOutputType | null
    _avg: MembershipUserAvgAggregateOutputType | null
    _sum: MembershipUserSumAggregateOutputType | null
    _min: MembershipUserMinAggregateOutputType | null
    _max: MembershipUserMaxAggregateOutputType | null
  }

  export type MembershipUserAvgAggregateOutputType = {
    remainingSessions: number | null
    remainingDuration: number | null
  }

  export type MembershipUserSumAggregateOutputType = {
    remainingSessions: number | null
    remainingDuration: number | null
  }

  export type MembershipUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    membershipId: string | null
    startDate: Date | null
    endDate: Date | null
    remainingSessions: number | null
    remainingDuration: number | null
    isExpired: boolean | null
    isSuspended: boolean | null
    suspensionReason: string | null
    suspensionEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    membershipId: string | null
    startDate: Date | null
    endDate: Date | null
    remainingSessions: number | null
    remainingDuration: number | null
    isExpired: boolean | null
    isSuspended: boolean | null
    suspensionReason: string | null
    suspensionEndDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipUserCountAggregateOutputType = {
    id: number
    userId: number
    membershipId: number
    startDate: number
    endDate: number
    remainingSessions: number
    remainingDuration: number
    isExpired: number
    isSuspended: number
    suspensionReason: number
    suspensionEndDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipUserAvgAggregateInputType = {
    remainingSessions?: true
    remainingDuration?: true
  }

  export type MembershipUserSumAggregateInputType = {
    remainingSessions?: true
    remainingDuration?: true
  }

  export type MembershipUserMinAggregateInputType = {
    id?: true
    userId?: true
    membershipId?: true
    startDate?: true
    endDate?: true
    remainingSessions?: true
    remainingDuration?: true
    isExpired?: true
    isSuspended?: true
    suspensionReason?: true
    suspensionEndDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipUserMaxAggregateInputType = {
    id?: true
    userId?: true
    membershipId?: true
    startDate?: true
    endDate?: true
    remainingSessions?: true
    remainingDuration?: true
    isExpired?: true
    isSuspended?: true
    suspensionReason?: true
    suspensionEndDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipUserCountAggregateInputType = {
    id?: true
    userId?: true
    membershipId?: true
    startDate?: true
    endDate?: true
    remainingSessions?: true
    remainingDuration?: true
    isExpired?: true
    isSuspended?: true
    suspensionReason?: true
    suspensionEndDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipUser to aggregate.
     */
    where?: MembershipUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipUsers to fetch.
     */
    orderBy?: MembershipUserOrderByWithRelationInput | MembershipUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MembershipUsers
    **/
    _count?: true | MembershipUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipUserMaxAggregateInputType
  }

  export type GetMembershipUserAggregateType<T extends MembershipUserAggregateArgs> = {
        [P in keyof T & keyof AggregateMembershipUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembershipUser[P]>
      : GetScalarType<T[P], AggregateMembershipUser[P]>
  }




  export type MembershipUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipUserWhereInput
    orderBy?: MembershipUserOrderByWithAggregationInput | MembershipUserOrderByWithAggregationInput[]
    by: MembershipUserScalarFieldEnum[] | MembershipUserScalarFieldEnum
    having?: MembershipUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipUserCountAggregateInputType | true
    _avg?: MembershipUserAvgAggregateInputType
    _sum?: MembershipUserSumAggregateInputType
    _min?: MembershipUserMinAggregateInputType
    _max?: MembershipUserMaxAggregateInputType
  }

  export type MembershipUserGroupByOutputType = {
    id: string
    userId: string
    membershipId: string
    startDate: Date
    endDate: Date
    remainingSessions: number
    remainingDuration: number
    isExpired: boolean
    isSuspended: boolean
    suspensionReason: string | null
    suspensionEndDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MembershipUserCountAggregateOutputType | null
    _avg: MembershipUserAvgAggregateOutputType | null
    _sum: MembershipUserSumAggregateOutputType | null
    _min: MembershipUserMinAggregateOutputType | null
    _max: MembershipUserMaxAggregateOutputType | null
  }

  type GetMembershipUserGroupByPayload<T extends MembershipUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipUserGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipUserGroupByOutputType[P]>
        }
      >
    >


  export type MembershipUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    membershipId?: boolean
    startDate?: boolean
    endDate?: boolean
    remainingSessions?: boolean
    remainingDuration?: boolean
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: boolean
    suspensionEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
    invoice?: boolean | MembershipUser$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["membershipUser"]>

  export type MembershipUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    membershipId?: boolean
    startDate?: boolean
    endDate?: boolean
    remainingSessions?: boolean
    remainingDuration?: boolean
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: boolean
    suspensionEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipUser"]>

  export type MembershipUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    membershipId?: boolean
    startDate?: boolean
    endDate?: boolean
    remainingSessions?: boolean
    remainingDuration?: boolean
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: boolean
    suspensionEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipUser"]>

  export type MembershipUserSelectScalar = {
    id?: boolean
    userId?: boolean
    membershipId?: boolean
    startDate?: boolean
    endDate?: boolean
    remainingSessions?: boolean
    remainingDuration?: boolean
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: boolean
    suspensionEndDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "membershipId" | "startDate" | "endDate" | "remainingSessions" | "remainingDuration" | "isExpired" | "isSuspended" | "suspensionReason" | "suspensionEndDate" | "createdAt" | "updatedAt", ExtArgs["result"]["membershipUser"]>
  export type MembershipUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
    invoice?: boolean | MembershipUser$invoiceArgs<ExtArgs>
  }
  export type MembershipUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }
  export type MembershipUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
  }

  export type $MembershipUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MembershipUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      membership: Prisma.$MembershipPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      membershipId: string
      startDate: Date
      endDate: Date
      remainingSessions: number
      remainingDuration: number
      isExpired: boolean
      isSuspended: boolean
      suspensionReason: string | null
      suspensionEndDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membershipUser"]>
    composites: {}
  }

  type MembershipUserGetPayload<S extends boolean | null | undefined | MembershipUserDefaultArgs> = $Result.GetResult<Prisma.$MembershipUserPayload, S>

  type MembershipUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipUserCountAggregateInputType | true
    }

  export interface MembershipUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MembershipUser'], meta: { name: 'MembershipUser' } }
    /**
     * Find zero or one MembershipUser that matches the filter.
     * @param {MembershipUserFindUniqueArgs} args - Arguments to find a MembershipUser
     * @example
     * // Get one MembershipUser
     * const membershipUser = await prisma.membershipUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipUserFindUniqueArgs>(args: SelectSubset<T, MembershipUserFindUniqueArgs<ExtArgs>>): Prisma__MembershipUserClient<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MembershipUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipUserFindUniqueOrThrowArgs} args - Arguments to find a MembershipUser
     * @example
     * // Get one MembershipUser
     * const membershipUser = await prisma.membershipUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipUserFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipUserClient<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUserFindFirstArgs} args - Arguments to find a MembershipUser
     * @example
     * // Get one MembershipUser
     * const membershipUser = await prisma.membershipUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipUserFindFirstArgs>(args?: SelectSubset<T, MembershipUserFindFirstArgs<ExtArgs>>): Prisma__MembershipUserClient<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUserFindFirstOrThrowArgs} args - Arguments to find a MembershipUser
     * @example
     * // Get one MembershipUser
     * const membershipUser = await prisma.membershipUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipUserFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipUserClient<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MembershipUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembershipUsers
     * const membershipUsers = await prisma.membershipUser.findMany()
     * 
     * // Get first 10 MembershipUsers
     * const membershipUsers = await prisma.membershipUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipUserWithIdOnly = await prisma.membershipUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipUserFindManyArgs>(args?: SelectSubset<T, MembershipUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MembershipUser.
     * @param {MembershipUserCreateArgs} args - Arguments to create a MembershipUser.
     * @example
     * // Create one MembershipUser
     * const MembershipUser = await prisma.membershipUser.create({
     *   data: {
     *     // ... data to create a MembershipUser
     *   }
     * })
     * 
     */
    create<T extends MembershipUserCreateArgs>(args: SelectSubset<T, MembershipUserCreateArgs<ExtArgs>>): Prisma__MembershipUserClient<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MembershipUsers.
     * @param {MembershipUserCreateManyArgs} args - Arguments to create many MembershipUsers.
     * @example
     * // Create many MembershipUsers
     * const membershipUser = await prisma.membershipUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipUserCreateManyArgs>(args?: SelectSubset<T, MembershipUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MembershipUsers and returns the data saved in the database.
     * @param {MembershipUserCreateManyAndReturnArgs} args - Arguments to create many MembershipUsers.
     * @example
     * // Create many MembershipUsers
     * const membershipUser = await prisma.membershipUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MembershipUsers and only return the `id`
     * const membershipUserWithIdOnly = await prisma.membershipUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipUserCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MembershipUser.
     * @param {MembershipUserDeleteArgs} args - Arguments to delete one MembershipUser.
     * @example
     * // Delete one MembershipUser
     * const MembershipUser = await prisma.membershipUser.delete({
     *   where: {
     *     // ... filter to delete one MembershipUser
     *   }
     * })
     * 
     */
    delete<T extends MembershipUserDeleteArgs>(args: SelectSubset<T, MembershipUserDeleteArgs<ExtArgs>>): Prisma__MembershipUserClient<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MembershipUser.
     * @param {MembershipUserUpdateArgs} args - Arguments to update one MembershipUser.
     * @example
     * // Update one MembershipUser
     * const membershipUser = await prisma.membershipUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipUserUpdateArgs>(args: SelectSubset<T, MembershipUserUpdateArgs<ExtArgs>>): Prisma__MembershipUserClient<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MembershipUsers.
     * @param {MembershipUserDeleteManyArgs} args - Arguments to filter MembershipUsers to delete.
     * @example
     * // Delete a few MembershipUsers
     * const { count } = await prisma.membershipUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipUserDeleteManyArgs>(args?: SelectSubset<T, MembershipUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembershipUsers
     * const membershipUser = await prisma.membershipUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipUserUpdateManyArgs>(args: SelectSubset<T, MembershipUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipUsers and returns the data updated in the database.
     * @param {MembershipUserUpdateManyAndReturnArgs} args - Arguments to update many MembershipUsers.
     * @example
     * // Update many MembershipUsers
     * const membershipUser = await prisma.membershipUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MembershipUsers and only return the `id`
     * const membershipUserWithIdOnly = await prisma.membershipUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipUserUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MembershipUser.
     * @param {MembershipUserUpsertArgs} args - Arguments to update or create a MembershipUser.
     * @example
     * // Update or create a MembershipUser
     * const membershipUser = await prisma.membershipUser.upsert({
     *   create: {
     *     // ... data to create a MembershipUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembershipUser we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUserUpsertArgs>(args: SelectSubset<T, MembershipUserUpsertArgs<ExtArgs>>): Prisma__MembershipUserClient<$Result.GetResult<Prisma.$MembershipUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MembershipUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUserCountArgs} args - Arguments to filter MembershipUsers to count.
     * @example
     * // Count the number of MembershipUsers
     * const count = await prisma.membershipUser.count({
     *   where: {
     *     // ... the filter for the MembershipUsers we want to count
     *   }
     * })
    **/
    count<T extends MembershipUserCountArgs>(
      args?: Subset<T, MembershipUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembershipUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipUserAggregateArgs>(args: Subset<T, MembershipUserAggregateArgs>): Prisma.PrismaPromise<GetMembershipUserAggregateType<T>>

    /**
     * Group by MembershipUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipUserGroupByArgs['orderBy'] }
        : { orderBy?: MembershipUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MembershipUser model
   */
  readonly fields: MembershipUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MembershipUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    membership<T extends MembershipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MembershipDefaultArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends MembershipUser$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, MembershipUser$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MembershipUser model
   */
  interface MembershipUserFieldRefs {
    readonly id: FieldRef<"MembershipUser", 'String'>
    readonly userId: FieldRef<"MembershipUser", 'String'>
    readonly membershipId: FieldRef<"MembershipUser", 'String'>
    readonly startDate: FieldRef<"MembershipUser", 'DateTime'>
    readonly endDate: FieldRef<"MembershipUser", 'DateTime'>
    readonly remainingSessions: FieldRef<"MembershipUser", 'Int'>
    readonly remainingDuration: FieldRef<"MembershipUser", 'Int'>
    readonly isExpired: FieldRef<"MembershipUser", 'Boolean'>
    readonly isSuspended: FieldRef<"MembershipUser", 'Boolean'>
    readonly suspensionReason: FieldRef<"MembershipUser", 'String'>
    readonly suspensionEndDate: FieldRef<"MembershipUser", 'DateTime'>
    readonly createdAt: FieldRef<"MembershipUser", 'DateTime'>
    readonly updatedAt: FieldRef<"MembershipUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MembershipUser findUnique
   */
  export type MembershipUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUser to fetch.
     */
    where: MembershipUserWhereUniqueInput
  }

  /**
   * MembershipUser findUniqueOrThrow
   */
  export type MembershipUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUser to fetch.
     */
    where: MembershipUserWhereUniqueInput
  }

  /**
   * MembershipUser findFirst
   */
  export type MembershipUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUser to fetch.
     */
    where?: MembershipUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipUsers to fetch.
     */
    orderBy?: MembershipUserOrderByWithRelationInput | MembershipUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipUsers.
     */
    cursor?: MembershipUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipUsers.
     */
    distinct?: MembershipUserScalarFieldEnum | MembershipUserScalarFieldEnum[]
  }

  /**
   * MembershipUser findFirstOrThrow
   */
  export type MembershipUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUser to fetch.
     */
    where?: MembershipUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipUsers to fetch.
     */
    orderBy?: MembershipUserOrderByWithRelationInput | MembershipUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MembershipUsers.
     */
    cursor?: MembershipUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MembershipUsers.
     */
    distinct?: MembershipUserScalarFieldEnum | MembershipUserScalarFieldEnum[]
  }

  /**
   * MembershipUser findMany
   */
  export type MembershipUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    /**
     * Filter, which MembershipUsers to fetch.
     */
    where?: MembershipUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MembershipUsers to fetch.
     */
    orderBy?: MembershipUserOrderByWithRelationInput | MembershipUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MembershipUsers.
     */
    cursor?: MembershipUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MembershipUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MembershipUsers.
     */
    skip?: number
    distinct?: MembershipUserScalarFieldEnum | MembershipUserScalarFieldEnum[]
  }

  /**
   * MembershipUser create
   */
  export type MembershipUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    /**
     * The data needed to create a MembershipUser.
     */
    data: XOR<MembershipUserCreateInput, MembershipUserUncheckedCreateInput>
  }

  /**
   * MembershipUser createMany
   */
  export type MembershipUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MembershipUsers.
     */
    data: MembershipUserCreateManyInput | MembershipUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MembershipUser createManyAndReturn
   */
  export type MembershipUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * The data used to create many MembershipUsers.
     */
    data: MembershipUserCreateManyInput | MembershipUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MembershipUser update
   */
  export type MembershipUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    /**
     * The data needed to update a MembershipUser.
     */
    data: XOR<MembershipUserUpdateInput, MembershipUserUncheckedUpdateInput>
    /**
     * Choose, which MembershipUser to update.
     */
    where: MembershipUserWhereUniqueInput
  }

  /**
   * MembershipUser updateMany
   */
  export type MembershipUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MembershipUsers.
     */
    data: XOR<MembershipUserUpdateManyMutationInput, MembershipUserUncheckedUpdateManyInput>
    /**
     * Filter which MembershipUsers to update
     */
    where?: MembershipUserWhereInput
    /**
     * Limit how many MembershipUsers to update.
     */
    limit?: number
  }

  /**
   * MembershipUser updateManyAndReturn
   */
  export type MembershipUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * The data used to update MembershipUsers.
     */
    data: XOR<MembershipUserUpdateManyMutationInput, MembershipUserUncheckedUpdateManyInput>
    /**
     * Filter which MembershipUsers to update
     */
    where?: MembershipUserWhereInput
    /**
     * Limit how many MembershipUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MembershipUser upsert
   */
  export type MembershipUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    /**
     * The filter to search for the MembershipUser to update in case it exists.
     */
    where: MembershipUserWhereUniqueInput
    /**
     * In case the MembershipUser found by the `where` argument doesn't exist, create a new MembershipUser with this data.
     */
    create: XOR<MembershipUserCreateInput, MembershipUserUncheckedCreateInput>
    /**
     * In case the MembershipUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUserUpdateInput, MembershipUserUncheckedUpdateInput>
  }

  /**
   * MembershipUser delete
   */
  export type MembershipUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
    /**
     * Filter which MembershipUser to delete.
     */
    where: MembershipUserWhereUniqueInput
  }

  /**
   * MembershipUser deleteMany
   */
  export type MembershipUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MembershipUsers to delete
     */
    where?: MembershipUserWhereInput
    /**
     * Limit how many MembershipUsers to delete.
     */
    limit?: number
  }

  /**
   * MembershipUser.invoice
   */
  export type MembershipUser$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * MembershipUser without action
   */
  export type MembershipUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipUser
     */
    select?: MembershipUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MembershipUser
     */
    omit?: MembershipUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipUserInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    price: number | null
    sessions: number | null
    capacity: number | null
    remaining: number | null
    maxBookingPax: number | null
    ageMin: number | null
  }

  export type ClassSumAggregateOutputType = {
    price: number | null
    sessions: number | null
    capacity: number | null
    remaining: number | null
    maxBookingPax: number | null
    ageMin: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    content: string | null
    organizerName: string | null
    speakerName: string | null
    image: string | null
    startDate: Date | null
    endDate: Date | null
    startTime: string | null
    endTime: string | null
    price: number | null
    sessions: number | null
    capacity: number | null
    remaining: number | null
    maxBookingPax: number | null
    gender: $Enums.Gender | null
    ageMin: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    content: string | null
    organizerName: string | null
    speakerName: string | null
    image: string | null
    startDate: Date | null
    endDate: Date | null
    startTime: string | null
    endTime: string | null
    price: number | null
    sessions: number | null
    capacity: number | null
    remaining: number | null
    maxBookingPax: number | null
    gender: $Enums.Gender | null
    ageMin: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    description: number
    content: number
    organizerName: number
    speakerName: number
    image: number
    startDate: number
    endDate: number
    startTime: number
    endTime: number
    price: number
    sessions: number
    capacity: number
    remaining: number
    maxBookingPax: number
    gender: number
    ageMin: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    price?: true
    sessions?: true
    capacity?: true
    remaining?: true
    maxBookingPax?: true
    ageMin?: true
  }

  export type ClassSumAggregateInputType = {
    price?: true
    sessions?: true
    capacity?: true
    remaining?: true
    maxBookingPax?: true
    ageMin?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    content?: true
    organizerName?: true
    speakerName?: true
    image?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    price?: true
    sessions?: true
    capacity?: true
    remaining?: true
    maxBookingPax?: true
    gender?: true
    ageMin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    content?: true
    organizerName?: true
    speakerName?: true
    image?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    price?: true
    sessions?: true
    capacity?: true
    remaining?: true
    maxBookingPax?: true
    gender?: true
    ageMin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    content?: true
    organizerName?: true
    speakerName?: true
    image?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    price?: true
    sessions?: true
    capacity?: true
    remaining?: true
    maxBookingPax?: true
    gender?: true
    ageMin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    description: string | null
    content: string | null
    organizerName: string | null
    speakerName: string | null
    image: string | null
    startDate: Date
    endDate: Date
    startTime: string
    endTime: string
    price: number
    sessions: number
    capacity: number
    remaining: number
    maxBookingPax: number
    gender: $Enums.Gender
    ageMin: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    organizerName?: boolean
    speakerName?: boolean
    image?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    price?: boolean
    sessions?: boolean
    capacity?: boolean
    remaining?: boolean
    maxBookingPax?: boolean
    gender?: boolean
    ageMin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classBookings?: boolean | Class$classBookingsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    organizerName?: boolean
    speakerName?: boolean
    image?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    price?: boolean
    sessions?: boolean
    capacity?: boolean
    remaining?: boolean
    maxBookingPax?: boolean
    gender?: boolean
    ageMin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    organizerName?: boolean
    speakerName?: boolean
    image?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    price?: boolean
    sessions?: boolean
    capacity?: boolean
    remaining?: boolean
    maxBookingPax?: boolean
    gender?: boolean
    ageMin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    content?: boolean
    organizerName?: boolean
    speakerName?: boolean
    image?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    price?: boolean
    sessions?: boolean
    capacity?: boolean
    remaining?: boolean
    maxBookingPax?: boolean
    gender?: boolean
    ageMin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "content" | "organizerName" | "speakerName" | "image" | "startDate" | "endDate" | "startTime" | "endTime" | "price" | "sessions" | "capacity" | "remaining" | "maxBookingPax" | "gender" | "ageMin" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classBookings?: boolean | Class$classBookingsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      classBookings: Prisma.$ClassBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      content: string | null
      organizerName: string | null
      speakerName: string | null
      image: string | null
      startDate: Date
      endDate: Date
      startTime: string
      endTime: string
      price: number
      sessions: number
      capacity: number
      remaining: number
      maxBookingPax: number
      gender: $Enums.Gender
      ageMin: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classBookings<T extends Class$classBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Class$classBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly description: FieldRef<"Class", 'String'>
    readonly content: FieldRef<"Class", 'String'>
    readonly organizerName: FieldRef<"Class", 'String'>
    readonly speakerName: FieldRef<"Class", 'String'>
    readonly image: FieldRef<"Class", 'String'>
    readonly startDate: FieldRef<"Class", 'DateTime'>
    readonly endDate: FieldRef<"Class", 'DateTime'>
    readonly startTime: FieldRef<"Class", 'String'>
    readonly endTime: FieldRef<"Class", 'String'>
    readonly price: FieldRef<"Class", 'Int'>
    readonly sessions: FieldRef<"Class", 'Int'>
    readonly capacity: FieldRef<"Class", 'Int'>
    readonly remaining: FieldRef<"Class", 'Int'>
    readonly maxBookingPax: FieldRef<"Class", 'Int'>
    readonly gender: FieldRef<"Class", 'Gender'>
    readonly ageMin: FieldRef<"Class", 'Int'>
    readonly isActive: FieldRef<"Class", 'Boolean'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.classBookings
   */
  export type Class$classBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    where?: ClassBookingWhereInput
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    cursor?: ClassBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassBookingScalarFieldEnum | ClassBookingScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model ClassBooking
   */

  export type AggregateClassBooking = {
    _count: ClassBookingCountAggregateOutputType | null
    _avg: ClassBookingAvgAggregateOutputType | null
    _sum: ClassBookingSumAggregateOutputType | null
    _min: ClassBookingMinAggregateOutputType | null
    _max: ClassBookingMaxAggregateOutputType | null
  }

  export type ClassBookingAvgAggregateOutputType = {
    totalPrice: number | null
    processingFee: number | null
  }

  export type ClassBookingSumAggregateOutputType = {
    totalPrice: number | null
    processingFee: number | null
  }

  export type ClassBookingMinAggregateOutputType = {
    id: string | null
    classId: string | null
    userId: string | null
    status: $Enums.BookingStatus | null
    totalPrice: number | null
    processingFee: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
  }

  export type ClassBookingMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    userId: string | null
    status: $Enums.BookingStatus | null
    totalPrice: number | null
    processingFee: number | null
    createdAt: Date | null
    updatedAt: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
  }

  export type ClassBookingCountAggregateOutputType = {
    id: number
    classId: number
    userId: number
    status: number
    totalPrice: number
    processingFee: number
    createdAt: number
    updatedAt: number
    cancelledAt: number
    cancellationReason: number
    _all: number
  }


  export type ClassBookingAvgAggregateInputType = {
    totalPrice?: true
    processingFee?: true
  }

  export type ClassBookingSumAggregateInputType = {
    totalPrice?: true
    processingFee?: true
  }

  export type ClassBookingMinAggregateInputType = {
    id?: true
    classId?: true
    userId?: true
    status?: true
    totalPrice?: true
    processingFee?: true
    createdAt?: true
    updatedAt?: true
    cancelledAt?: true
    cancellationReason?: true
  }

  export type ClassBookingMaxAggregateInputType = {
    id?: true
    classId?: true
    userId?: true
    status?: true
    totalPrice?: true
    processingFee?: true
    createdAt?: true
    updatedAt?: true
    cancelledAt?: true
    cancellationReason?: true
  }

  export type ClassBookingCountAggregateInputType = {
    id?: true
    classId?: true
    userId?: true
    status?: true
    totalPrice?: true
    processingFee?: true
    createdAt?: true
    updatedAt?: true
    cancelledAt?: true
    cancellationReason?: true
    _all?: true
  }

  export type ClassBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassBooking to aggregate.
     */
    where?: ClassBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookings to fetch.
     */
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassBookings
    **/
    _count?: true | ClassBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassBookingMaxAggregateInputType
  }

  export type GetClassBookingAggregateType<T extends ClassBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateClassBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassBooking[P]>
      : GetScalarType<T[P], AggregateClassBooking[P]>
  }




  export type ClassBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassBookingWhereInput
    orderBy?: ClassBookingOrderByWithAggregationInput | ClassBookingOrderByWithAggregationInput[]
    by: ClassBookingScalarFieldEnum[] | ClassBookingScalarFieldEnum
    having?: ClassBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassBookingCountAggregateInputType | true
    _avg?: ClassBookingAvgAggregateInputType
    _sum?: ClassBookingSumAggregateInputType
    _min?: ClassBookingMinAggregateInputType
    _max?: ClassBookingMaxAggregateInputType
  }

  export type ClassBookingGroupByOutputType = {
    id: string
    classId: string
    userId: string
    status: $Enums.BookingStatus
    totalPrice: number
    processingFee: number
    createdAt: Date
    updatedAt: Date
    cancelledAt: Date | null
    cancellationReason: string | null
    _count: ClassBookingCountAggregateOutputType | null
    _avg: ClassBookingAvgAggregateOutputType | null
    _sum: ClassBookingSumAggregateOutputType | null
    _min: ClassBookingMinAggregateOutputType | null
    _max: ClassBookingMaxAggregateOutputType | null
  }

  type GetClassBookingGroupByPayload<T extends ClassBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassBookingGroupByOutputType[P]>
            : GetScalarType<T[P], ClassBookingGroupByOutputType[P]>
        }
      >
    >


  export type ClassBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    userId?: boolean
    status?: boolean
    totalPrice?: boolean
    processingFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    details?: boolean | ClassBooking$detailsArgs<ExtArgs>
    invoice?: boolean | ClassBooking$invoiceArgs<ExtArgs>
    _count?: boolean | ClassBookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classBooking"]>

  export type ClassBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    userId?: boolean
    status?: boolean
    totalPrice?: boolean
    processingFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classBooking"]>

  export type ClassBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    userId?: boolean
    status?: boolean
    totalPrice?: boolean
    processingFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classBooking"]>

  export type ClassBookingSelectScalar = {
    id?: boolean
    classId?: boolean
    userId?: boolean
    status?: boolean
    totalPrice?: boolean
    processingFee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
  }

  export type ClassBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "userId" | "status" | "totalPrice" | "processingFee" | "createdAt" | "updatedAt" | "cancelledAt" | "cancellationReason", ExtArgs["result"]["classBooking"]>
  export type ClassBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    details?: boolean | ClassBooking$detailsArgs<ExtArgs>
    invoice?: boolean | ClassBooking$invoiceArgs<ExtArgs>
    _count?: boolean | ClassBookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassBooking"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      details: Prisma.$ClassBookingDetailPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      userId: string
      status: $Enums.BookingStatus
      totalPrice: number
      processingFee: number
      createdAt: Date
      updatedAt: Date
      cancelledAt: Date | null
      cancellationReason: string | null
    }, ExtArgs["result"]["classBooking"]>
    composites: {}
  }

  type ClassBookingGetPayload<S extends boolean | null | undefined | ClassBookingDefaultArgs> = $Result.GetResult<Prisma.$ClassBookingPayload, S>

  type ClassBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassBookingCountAggregateInputType | true
    }

  export interface ClassBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassBooking'], meta: { name: 'ClassBooking' } }
    /**
     * Find zero or one ClassBooking that matches the filter.
     * @param {ClassBookingFindUniqueArgs} args - Arguments to find a ClassBooking
     * @example
     * // Get one ClassBooking
     * const classBooking = await prisma.classBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassBookingFindUniqueArgs>(args: SelectSubset<T, ClassBookingFindUniqueArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassBookingFindUniqueOrThrowArgs} args - Arguments to find a ClassBooking
     * @example
     * // Get one ClassBooking
     * const classBooking = await prisma.classBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingFindFirstArgs} args - Arguments to find a ClassBooking
     * @example
     * // Get one ClassBooking
     * const classBooking = await prisma.classBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassBookingFindFirstArgs>(args?: SelectSubset<T, ClassBookingFindFirstArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingFindFirstOrThrowArgs} args - Arguments to find a ClassBooking
     * @example
     * // Get one ClassBooking
     * const classBooking = await prisma.classBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassBookings
     * const classBookings = await prisma.classBooking.findMany()
     * 
     * // Get first 10 ClassBookings
     * const classBookings = await prisma.classBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classBookingWithIdOnly = await prisma.classBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassBookingFindManyArgs>(args?: SelectSubset<T, ClassBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassBooking.
     * @param {ClassBookingCreateArgs} args - Arguments to create a ClassBooking.
     * @example
     * // Create one ClassBooking
     * const ClassBooking = await prisma.classBooking.create({
     *   data: {
     *     // ... data to create a ClassBooking
     *   }
     * })
     * 
     */
    create<T extends ClassBookingCreateArgs>(args: SelectSubset<T, ClassBookingCreateArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassBookings.
     * @param {ClassBookingCreateManyArgs} args - Arguments to create many ClassBookings.
     * @example
     * // Create many ClassBookings
     * const classBooking = await prisma.classBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassBookingCreateManyArgs>(args?: SelectSubset<T, ClassBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassBookings and returns the data saved in the database.
     * @param {ClassBookingCreateManyAndReturnArgs} args - Arguments to create many ClassBookings.
     * @example
     * // Create many ClassBookings
     * const classBooking = await prisma.classBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassBookings and only return the `id`
     * const classBookingWithIdOnly = await prisma.classBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassBooking.
     * @param {ClassBookingDeleteArgs} args - Arguments to delete one ClassBooking.
     * @example
     * // Delete one ClassBooking
     * const ClassBooking = await prisma.classBooking.delete({
     *   where: {
     *     // ... filter to delete one ClassBooking
     *   }
     * })
     * 
     */
    delete<T extends ClassBookingDeleteArgs>(args: SelectSubset<T, ClassBookingDeleteArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassBooking.
     * @param {ClassBookingUpdateArgs} args - Arguments to update one ClassBooking.
     * @example
     * // Update one ClassBooking
     * const classBooking = await prisma.classBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassBookingUpdateArgs>(args: SelectSubset<T, ClassBookingUpdateArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassBookings.
     * @param {ClassBookingDeleteManyArgs} args - Arguments to filter ClassBookings to delete.
     * @example
     * // Delete a few ClassBookings
     * const { count } = await prisma.classBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassBookingDeleteManyArgs>(args?: SelectSubset<T, ClassBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassBookings
     * const classBooking = await prisma.classBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassBookingUpdateManyArgs>(args: SelectSubset<T, ClassBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassBookings and returns the data updated in the database.
     * @param {ClassBookingUpdateManyAndReturnArgs} args - Arguments to update many ClassBookings.
     * @example
     * // Update many ClassBookings
     * const classBooking = await prisma.classBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassBookings and only return the `id`
     * const classBookingWithIdOnly = await prisma.classBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassBooking.
     * @param {ClassBookingUpsertArgs} args - Arguments to update or create a ClassBooking.
     * @example
     * // Update or create a ClassBooking
     * const classBooking = await prisma.classBooking.upsert({
     *   create: {
     *     // ... data to create a ClassBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassBooking we want to update
     *   }
     * })
     */
    upsert<T extends ClassBookingUpsertArgs>(args: SelectSubset<T, ClassBookingUpsertArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingCountArgs} args - Arguments to filter ClassBookings to count.
     * @example
     * // Count the number of ClassBookings
     * const count = await prisma.classBooking.count({
     *   where: {
     *     // ... the filter for the ClassBookings we want to count
     *   }
     * })
    **/
    count<T extends ClassBookingCountArgs>(
      args?: Subset<T, ClassBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassBookingAggregateArgs>(args: Subset<T, ClassBookingAggregateArgs>): Prisma.PrismaPromise<GetClassBookingAggregateType<T>>

    /**
     * Group by ClassBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassBookingGroupByArgs['orderBy'] }
        : { orderBy?: ClassBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassBooking model
   */
  readonly fields: ClassBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    details<T extends ClassBooking$detailsArgs<ExtArgs> = {}>(args?: Subset<T, ClassBooking$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends ClassBooking$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, ClassBooking$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassBooking model
   */
  interface ClassBookingFieldRefs {
    readonly id: FieldRef<"ClassBooking", 'String'>
    readonly classId: FieldRef<"ClassBooking", 'String'>
    readonly userId: FieldRef<"ClassBooking", 'String'>
    readonly status: FieldRef<"ClassBooking", 'BookingStatus'>
    readonly totalPrice: FieldRef<"ClassBooking", 'Int'>
    readonly processingFee: FieldRef<"ClassBooking", 'Int'>
    readonly createdAt: FieldRef<"ClassBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassBooking", 'DateTime'>
    readonly cancelledAt: FieldRef<"ClassBooking", 'DateTime'>
    readonly cancellationReason: FieldRef<"ClassBooking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassBooking findUnique
   */
  export type ClassBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBooking to fetch.
     */
    where: ClassBookingWhereUniqueInput
  }

  /**
   * ClassBooking findUniqueOrThrow
   */
  export type ClassBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBooking to fetch.
     */
    where: ClassBookingWhereUniqueInput
  }

  /**
   * ClassBooking findFirst
   */
  export type ClassBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBooking to fetch.
     */
    where?: ClassBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookings to fetch.
     */
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassBookings.
     */
    cursor?: ClassBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassBookings.
     */
    distinct?: ClassBookingScalarFieldEnum | ClassBookingScalarFieldEnum[]
  }

  /**
   * ClassBooking findFirstOrThrow
   */
  export type ClassBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBooking to fetch.
     */
    where?: ClassBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookings to fetch.
     */
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassBookings.
     */
    cursor?: ClassBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassBookings.
     */
    distinct?: ClassBookingScalarFieldEnum | ClassBookingScalarFieldEnum[]
  }

  /**
   * ClassBooking findMany
   */
  export type ClassBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter, which ClassBookings to fetch.
     */
    where?: ClassBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookings to fetch.
     */
    orderBy?: ClassBookingOrderByWithRelationInput | ClassBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassBookings.
     */
    cursor?: ClassBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookings.
     */
    skip?: number
    distinct?: ClassBookingScalarFieldEnum | ClassBookingScalarFieldEnum[]
  }

  /**
   * ClassBooking create
   */
  export type ClassBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassBooking.
     */
    data: XOR<ClassBookingCreateInput, ClassBookingUncheckedCreateInput>
  }

  /**
   * ClassBooking createMany
   */
  export type ClassBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassBookings.
     */
    data: ClassBookingCreateManyInput | ClassBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassBooking createManyAndReturn
   */
  export type ClassBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * The data used to create many ClassBookings.
     */
    data: ClassBookingCreateManyInput | ClassBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassBooking update
   */
  export type ClassBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassBooking.
     */
    data: XOR<ClassBookingUpdateInput, ClassBookingUncheckedUpdateInput>
    /**
     * Choose, which ClassBooking to update.
     */
    where: ClassBookingWhereUniqueInput
  }

  /**
   * ClassBooking updateMany
   */
  export type ClassBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassBookings.
     */
    data: XOR<ClassBookingUpdateManyMutationInput, ClassBookingUncheckedUpdateManyInput>
    /**
     * Filter which ClassBookings to update
     */
    where?: ClassBookingWhereInput
    /**
     * Limit how many ClassBookings to update.
     */
    limit?: number
  }

  /**
   * ClassBooking updateManyAndReturn
   */
  export type ClassBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * The data used to update ClassBookings.
     */
    data: XOR<ClassBookingUpdateManyMutationInput, ClassBookingUncheckedUpdateManyInput>
    /**
     * Filter which ClassBookings to update
     */
    where?: ClassBookingWhereInput
    /**
     * Limit how many ClassBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassBooking upsert
   */
  export type ClassBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassBooking to update in case it exists.
     */
    where: ClassBookingWhereUniqueInput
    /**
     * In case the ClassBooking found by the `where` argument doesn't exist, create a new ClassBooking with this data.
     */
    create: XOR<ClassBookingCreateInput, ClassBookingUncheckedCreateInput>
    /**
     * In case the ClassBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassBookingUpdateInput, ClassBookingUncheckedUpdateInput>
  }

  /**
   * ClassBooking delete
   */
  export type ClassBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
    /**
     * Filter which ClassBooking to delete.
     */
    where: ClassBookingWhereUniqueInput
  }

  /**
   * ClassBooking deleteMany
   */
  export type ClassBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassBookings to delete
     */
    where?: ClassBookingWhereInput
    /**
     * Limit how many ClassBookings to delete.
     */
    limit?: number
  }

  /**
   * ClassBooking.details
   */
  export type ClassBooking$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    where?: ClassBookingDetailWhereInput
    orderBy?: ClassBookingDetailOrderByWithRelationInput | ClassBookingDetailOrderByWithRelationInput[]
    cursor?: ClassBookingDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassBookingDetailScalarFieldEnum | ClassBookingDetailScalarFieldEnum[]
  }

  /**
   * ClassBooking.invoice
   */
  export type ClassBooking$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * ClassBooking without action
   */
  export type ClassBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBooking
     */
    select?: ClassBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBooking
     */
    omit?: ClassBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingInclude<ExtArgs> | null
  }


  /**
   * Model ClassBookingDetail
   */

  export type AggregateClassBookingDetail = {
    _count: ClassBookingDetailCountAggregateOutputType | null
    _avg: ClassBookingDetailAvgAggregateOutputType | null
    _sum: ClassBookingDetailSumAggregateOutputType | null
    _min: ClassBookingDetailMinAggregateOutputType | null
    _max: ClassBookingDetailMaxAggregateOutputType | null
  }

  export type ClassBookingDetailAvgAggregateOutputType = {
    price: number | null
  }

  export type ClassBookingDetailSumAggregateOutputType = {
    price: number | null
  }

  export type ClassBookingDetailMinAggregateOutputType = {
    id: string | null
    classBookingId: string | null
    date: Date | null
    time: string | null
    price: number | null
    attendance: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassBookingDetailMaxAggregateOutputType = {
    id: string | null
    classBookingId: string | null
    date: Date | null
    time: string | null
    price: number | null
    attendance: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassBookingDetailCountAggregateOutputType = {
    id: number
    classBookingId: number
    date: number
    time: number
    price: number
    attendance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassBookingDetailAvgAggregateInputType = {
    price?: true
  }

  export type ClassBookingDetailSumAggregateInputType = {
    price?: true
  }

  export type ClassBookingDetailMinAggregateInputType = {
    id?: true
    classBookingId?: true
    date?: true
    time?: true
    price?: true
    attendance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassBookingDetailMaxAggregateInputType = {
    id?: true
    classBookingId?: true
    date?: true
    time?: true
    price?: true
    attendance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassBookingDetailCountAggregateInputType = {
    id?: true
    classBookingId?: true
    date?: true
    time?: true
    price?: true
    attendance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassBookingDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassBookingDetail to aggregate.
     */
    where?: ClassBookingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookingDetails to fetch.
     */
    orderBy?: ClassBookingDetailOrderByWithRelationInput | ClassBookingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassBookingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassBookingDetails
    **/
    _count?: true | ClassBookingDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassBookingDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassBookingDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassBookingDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassBookingDetailMaxAggregateInputType
  }

  export type GetClassBookingDetailAggregateType<T extends ClassBookingDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateClassBookingDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassBookingDetail[P]>
      : GetScalarType<T[P], AggregateClassBookingDetail[P]>
  }




  export type ClassBookingDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassBookingDetailWhereInput
    orderBy?: ClassBookingDetailOrderByWithAggregationInput | ClassBookingDetailOrderByWithAggregationInput[]
    by: ClassBookingDetailScalarFieldEnum[] | ClassBookingDetailScalarFieldEnum
    having?: ClassBookingDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassBookingDetailCountAggregateInputType | true
    _avg?: ClassBookingDetailAvgAggregateInputType
    _sum?: ClassBookingDetailSumAggregateInputType
    _min?: ClassBookingDetailMinAggregateInputType
    _max?: ClassBookingDetailMaxAggregateInputType
  }

  export type ClassBookingDetailGroupByOutputType = {
    id: string
    classBookingId: string
    date: Date
    time: string
    price: number
    attendance: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClassBookingDetailCountAggregateOutputType | null
    _avg: ClassBookingDetailAvgAggregateOutputType | null
    _sum: ClassBookingDetailSumAggregateOutputType | null
    _min: ClassBookingDetailMinAggregateOutputType | null
    _max: ClassBookingDetailMaxAggregateOutputType | null
  }

  type GetClassBookingDetailGroupByPayload<T extends ClassBookingDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassBookingDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassBookingDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassBookingDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ClassBookingDetailGroupByOutputType[P]>
        }
      >
    >


  export type ClassBookingDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classBookingId?: boolean
    date?: boolean
    time?: boolean
    price?: boolean
    attendance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classBooking?: boolean | ClassBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classBookingDetail"]>

  export type ClassBookingDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classBookingId?: boolean
    date?: boolean
    time?: boolean
    price?: boolean
    attendance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classBooking?: boolean | ClassBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classBookingDetail"]>

  export type ClassBookingDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classBookingId?: boolean
    date?: boolean
    time?: boolean
    price?: boolean
    attendance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classBooking?: boolean | ClassBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classBookingDetail"]>

  export type ClassBookingDetailSelectScalar = {
    id?: boolean
    classBookingId?: boolean
    date?: boolean
    time?: boolean
    price?: boolean
    attendance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassBookingDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classBookingId" | "date" | "time" | "price" | "attendance" | "createdAt" | "updatedAt", ExtArgs["result"]["classBookingDetail"]>
  export type ClassBookingDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classBooking?: boolean | ClassBookingDefaultArgs<ExtArgs>
  }
  export type ClassBookingDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classBooking?: boolean | ClassBookingDefaultArgs<ExtArgs>
  }
  export type ClassBookingDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classBooking?: boolean | ClassBookingDefaultArgs<ExtArgs>
  }

  export type $ClassBookingDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassBookingDetail"
    objects: {
      classBooking: Prisma.$ClassBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classBookingId: string
      date: Date
      time: string
      price: number
      attendance: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classBookingDetail"]>
    composites: {}
  }

  type ClassBookingDetailGetPayload<S extends boolean | null | undefined | ClassBookingDetailDefaultArgs> = $Result.GetResult<Prisma.$ClassBookingDetailPayload, S>

  type ClassBookingDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassBookingDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassBookingDetailCountAggregateInputType | true
    }

  export interface ClassBookingDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassBookingDetail'], meta: { name: 'ClassBookingDetail' } }
    /**
     * Find zero or one ClassBookingDetail that matches the filter.
     * @param {ClassBookingDetailFindUniqueArgs} args - Arguments to find a ClassBookingDetail
     * @example
     * // Get one ClassBookingDetail
     * const classBookingDetail = await prisma.classBookingDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassBookingDetailFindUniqueArgs>(args: SelectSubset<T, ClassBookingDetailFindUniqueArgs<ExtArgs>>): Prisma__ClassBookingDetailClient<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassBookingDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassBookingDetailFindUniqueOrThrowArgs} args - Arguments to find a ClassBookingDetail
     * @example
     * // Get one ClassBookingDetail
     * const classBookingDetail = await prisma.classBookingDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassBookingDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassBookingDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassBookingDetailClient<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassBookingDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingDetailFindFirstArgs} args - Arguments to find a ClassBookingDetail
     * @example
     * // Get one ClassBookingDetail
     * const classBookingDetail = await prisma.classBookingDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassBookingDetailFindFirstArgs>(args?: SelectSubset<T, ClassBookingDetailFindFirstArgs<ExtArgs>>): Prisma__ClassBookingDetailClient<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassBookingDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingDetailFindFirstOrThrowArgs} args - Arguments to find a ClassBookingDetail
     * @example
     * // Get one ClassBookingDetail
     * const classBookingDetail = await prisma.classBookingDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassBookingDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassBookingDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassBookingDetailClient<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassBookingDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassBookingDetails
     * const classBookingDetails = await prisma.classBookingDetail.findMany()
     * 
     * // Get first 10 ClassBookingDetails
     * const classBookingDetails = await prisma.classBookingDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classBookingDetailWithIdOnly = await prisma.classBookingDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassBookingDetailFindManyArgs>(args?: SelectSubset<T, ClassBookingDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassBookingDetail.
     * @param {ClassBookingDetailCreateArgs} args - Arguments to create a ClassBookingDetail.
     * @example
     * // Create one ClassBookingDetail
     * const ClassBookingDetail = await prisma.classBookingDetail.create({
     *   data: {
     *     // ... data to create a ClassBookingDetail
     *   }
     * })
     * 
     */
    create<T extends ClassBookingDetailCreateArgs>(args: SelectSubset<T, ClassBookingDetailCreateArgs<ExtArgs>>): Prisma__ClassBookingDetailClient<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassBookingDetails.
     * @param {ClassBookingDetailCreateManyArgs} args - Arguments to create many ClassBookingDetails.
     * @example
     * // Create many ClassBookingDetails
     * const classBookingDetail = await prisma.classBookingDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassBookingDetailCreateManyArgs>(args?: SelectSubset<T, ClassBookingDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassBookingDetails and returns the data saved in the database.
     * @param {ClassBookingDetailCreateManyAndReturnArgs} args - Arguments to create many ClassBookingDetails.
     * @example
     * // Create many ClassBookingDetails
     * const classBookingDetail = await prisma.classBookingDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassBookingDetails and only return the `id`
     * const classBookingDetailWithIdOnly = await prisma.classBookingDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassBookingDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassBookingDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassBookingDetail.
     * @param {ClassBookingDetailDeleteArgs} args - Arguments to delete one ClassBookingDetail.
     * @example
     * // Delete one ClassBookingDetail
     * const ClassBookingDetail = await prisma.classBookingDetail.delete({
     *   where: {
     *     // ... filter to delete one ClassBookingDetail
     *   }
     * })
     * 
     */
    delete<T extends ClassBookingDetailDeleteArgs>(args: SelectSubset<T, ClassBookingDetailDeleteArgs<ExtArgs>>): Prisma__ClassBookingDetailClient<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassBookingDetail.
     * @param {ClassBookingDetailUpdateArgs} args - Arguments to update one ClassBookingDetail.
     * @example
     * // Update one ClassBookingDetail
     * const classBookingDetail = await prisma.classBookingDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassBookingDetailUpdateArgs>(args: SelectSubset<T, ClassBookingDetailUpdateArgs<ExtArgs>>): Prisma__ClassBookingDetailClient<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassBookingDetails.
     * @param {ClassBookingDetailDeleteManyArgs} args - Arguments to filter ClassBookingDetails to delete.
     * @example
     * // Delete a few ClassBookingDetails
     * const { count } = await prisma.classBookingDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassBookingDetailDeleteManyArgs>(args?: SelectSubset<T, ClassBookingDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassBookingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassBookingDetails
     * const classBookingDetail = await prisma.classBookingDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassBookingDetailUpdateManyArgs>(args: SelectSubset<T, ClassBookingDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassBookingDetails and returns the data updated in the database.
     * @param {ClassBookingDetailUpdateManyAndReturnArgs} args - Arguments to update many ClassBookingDetails.
     * @example
     * // Update many ClassBookingDetails
     * const classBookingDetail = await prisma.classBookingDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassBookingDetails and only return the `id`
     * const classBookingDetailWithIdOnly = await prisma.classBookingDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassBookingDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassBookingDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassBookingDetail.
     * @param {ClassBookingDetailUpsertArgs} args - Arguments to update or create a ClassBookingDetail.
     * @example
     * // Update or create a ClassBookingDetail
     * const classBookingDetail = await prisma.classBookingDetail.upsert({
     *   create: {
     *     // ... data to create a ClassBookingDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassBookingDetail we want to update
     *   }
     * })
     */
    upsert<T extends ClassBookingDetailUpsertArgs>(args: SelectSubset<T, ClassBookingDetailUpsertArgs<ExtArgs>>): Prisma__ClassBookingDetailClient<$Result.GetResult<Prisma.$ClassBookingDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassBookingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingDetailCountArgs} args - Arguments to filter ClassBookingDetails to count.
     * @example
     * // Count the number of ClassBookingDetails
     * const count = await prisma.classBookingDetail.count({
     *   where: {
     *     // ... the filter for the ClassBookingDetails we want to count
     *   }
     * })
    **/
    count<T extends ClassBookingDetailCountArgs>(
      args?: Subset<T, ClassBookingDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassBookingDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassBookingDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassBookingDetailAggregateArgs>(args: Subset<T, ClassBookingDetailAggregateArgs>): Prisma.PrismaPromise<GetClassBookingDetailAggregateType<T>>

    /**
     * Group by ClassBookingDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassBookingDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassBookingDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassBookingDetailGroupByArgs['orderBy'] }
        : { orderBy?: ClassBookingDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassBookingDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassBookingDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassBookingDetail model
   */
  readonly fields: ClassBookingDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassBookingDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassBookingDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classBooking<T extends ClassBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassBookingDefaultArgs<ExtArgs>>): Prisma__ClassBookingClient<$Result.GetResult<Prisma.$ClassBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassBookingDetail model
   */
  interface ClassBookingDetailFieldRefs {
    readonly id: FieldRef<"ClassBookingDetail", 'String'>
    readonly classBookingId: FieldRef<"ClassBookingDetail", 'String'>
    readonly date: FieldRef<"ClassBookingDetail", 'DateTime'>
    readonly time: FieldRef<"ClassBookingDetail", 'String'>
    readonly price: FieldRef<"ClassBookingDetail", 'Int'>
    readonly attendance: FieldRef<"ClassBookingDetail", 'Boolean'>
    readonly createdAt: FieldRef<"ClassBookingDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassBookingDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassBookingDetail findUnique
   */
  export type ClassBookingDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which ClassBookingDetail to fetch.
     */
    where: ClassBookingDetailWhereUniqueInput
  }

  /**
   * ClassBookingDetail findUniqueOrThrow
   */
  export type ClassBookingDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which ClassBookingDetail to fetch.
     */
    where: ClassBookingDetailWhereUniqueInput
  }

  /**
   * ClassBookingDetail findFirst
   */
  export type ClassBookingDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which ClassBookingDetail to fetch.
     */
    where?: ClassBookingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookingDetails to fetch.
     */
    orderBy?: ClassBookingDetailOrderByWithRelationInput | ClassBookingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassBookingDetails.
     */
    cursor?: ClassBookingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassBookingDetails.
     */
    distinct?: ClassBookingDetailScalarFieldEnum | ClassBookingDetailScalarFieldEnum[]
  }

  /**
   * ClassBookingDetail findFirstOrThrow
   */
  export type ClassBookingDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which ClassBookingDetail to fetch.
     */
    where?: ClassBookingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookingDetails to fetch.
     */
    orderBy?: ClassBookingDetailOrderByWithRelationInput | ClassBookingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassBookingDetails.
     */
    cursor?: ClassBookingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassBookingDetails.
     */
    distinct?: ClassBookingDetailScalarFieldEnum | ClassBookingDetailScalarFieldEnum[]
  }

  /**
   * ClassBookingDetail findMany
   */
  export type ClassBookingDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    /**
     * Filter, which ClassBookingDetails to fetch.
     */
    where?: ClassBookingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassBookingDetails to fetch.
     */
    orderBy?: ClassBookingDetailOrderByWithRelationInput | ClassBookingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassBookingDetails.
     */
    cursor?: ClassBookingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassBookingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassBookingDetails.
     */
    skip?: number
    distinct?: ClassBookingDetailScalarFieldEnum | ClassBookingDetailScalarFieldEnum[]
  }

  /**
   * ClassBookingDetail create
   */
  export type ClassBookingDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassBookingDetail.
     */
    data: XOR<ClassBookingDetailCreateInput, ClassBookingDetailUncheckedCreateInput>
  }

  /**
   * ClassBookingDetail createMany
   */
  export type ClassBookingDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassBookingDetails.
     */
    data: ClassBookingDetailCreateManyInput | ClassBookingDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassBookingDetail createManyAndReturn
   */
  export type ClassBookingDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * The data used to create many ClassBookingDetails.
     */
    data: ClassBookingDetailCreateManyInput | ClassBookingDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassBookingDetail update
   */
  export type ClassBookingDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassBookingDetail.
     */
    data: XOR<ClassBookingDetailUpdateInput, ClassBookingDetailUncheckedUpdateInput>
    /**
     * Choose, which ClassBookingDetail to update.
     */
    where: ClassBookingDetailWhereUniqueInput
  }

  /**
   * ClassBookingDetail updateMany
   */
  export type ClassBookingDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassBookingDetails.
     */
    data: XOR<ClassBookingDetailUpdateManyMutationInput, ClassBookingDetailUncheckedUpdateManyInput>
    /**
     * Filter which ClassBookingDetails to update
     */
    where?: ClassBookingDetailWhereInput
    /**
     * Limit how many ClassBookingDetails to update.
     */
    limit?: number
  }

  /**
   * ClassBookingDetail updateManyAndReturn
   */
  export type ClassBookingDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * The data used to update ClassBookingDetails.
     */
    data: XOR<ClassBookingDetailUpdateManyMutationInput, ClassBookingDetailUncheckedUpdateManyInput>
    /**
     * Filter which ClassBookingDetails to update
     */
    where?: ClassBookingDetailWhereInput
    /**
     * Limit how many ClassBookingDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassBookingDetail upsert
   */
  export type ClassBookingDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassBookingDetail to update in case it exists.
     */
    where: ClassBookingDetailWhereUniqueInput
    /**
     * In case the ClassBookingDetail found by the `where` argument doesn't exist, create a new ClassBookingDetail with this data.
     */
    create: XOR<ClassBookingDetailCreateInput, ClassBookingDetailUncheckedCreateInput>
    /**
     * In case the ClassBookingDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassBookingDetailUpdateInput, ClassBookingDetailUncheckedUpdateInput>
  }

  /**
   * ClassBookingDetail delete
   */
  export type ClassBookingDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
    /**
     * Filter which ClassBookingDetail to delete.
     */
    where: ClassBookingDetailWhereUniqueInput
  }

  /**
   * ClassBookingDetail deleteMany
   */
  export type ClassBookingDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassBookingDetails to delete
     */
    where?: ClassBookingDetailWhereInput
    /**
     * Limit how many ClassBookingDetails to delete.
     */
    limit?: number
  }

  /**
   * ClassBookingDetail without action
   */
  export type ClassBookingDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassBookingDetail
     */
    select?: ClassBookingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassBookingDetail
     */
    omit?: ClassBookingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassBookingDetailInclude<ExtArgs> | null
  }


  /**
   * Model Club
   */

  export type AggregateClub = {
    _count: ClubCountAggregateOutputType | null
    _min: ClubMinAggregateOutputType | null
    _max: ClubMaxAggregateOutputType | null
  }

  export type ClubMinAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    description: string | null
    rules: string | null
    leaderId: string | null
    visibility: $Enums.ClubVisibility | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClubMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logo: string | null
    description: string | null
    rules: string | null
    leaderId: string | null
    visibility: $Enums.ClubVisibility | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClubCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    description: number
    rules: number
    leaderId: number
    visibility: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClubMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    description?: true
    rules?: true
    leaderId?: true
    visibility?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClubMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    description?: true
    rules?: true
    leaderId?: true
    visibility?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClubCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    description?: true
    rules?: true
    leaderId?: true
    visibility?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClubAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Club to aggregate.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clubs
    **/
    _count?: true | ClubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubMaxAggregateInputType
  }

  export type GetClubAggregateType<T extends ClubAggregateArgs> = {
        [P in keyof T & keyof AggregateClub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClub[P]>
      : GetScalarType<T[P], AggregateClub[P]>
  }




  export type ClubGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubWhereInput
    orderBy?: ClubOrderByWithAggregationInput | ClubOrderByWithAggregationInput[]
    by: ClubScalarFieldEnum[] | ClubScalarFieldEnum
    having?: ClubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubCountAggregateInputType | true
    _min?: ClubMinAggregateInputType
    _max?: ClubMaxAggregateInputType
  }

  export type ClubGroupByOutputType = {
    id: string
    name: string
    logo: string | null
    description: string | null
    rules: string | null
    leaderId: string
    visibility: $Enums.ClubVisibility
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClubCountAggregateOutputType | null
    _min: ClubMinAggregateOutputType | null
    _max: ClubMaxAggregateOutputType | null
  }

  type GetClubGroupByPayload<T extends ClubGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubGroupByOutputType[P]>
            : GetScalarType<T[P], ClubGroupByOutputType[P]>
        }
      >
    >


  export type ClubSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    description?: boolean
    rules?: boolean
    leaderId?: boolean
    visibility?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leader?: boolean | UserDefaultArgs<ExtArgs>
    clubMember?: boolean | Club$clubMemberArgs<ExtArgs>
    tournamentRegistration?: boolean | Club$tournamentRegistrationArgs<ExtArgs>
    _count?: boolean | ClubCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["club"]>

  export type ClubSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    description?: boolean
    rules?: boolean
    leaderId?: boolean
    visibility?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["club"]>

  export type ClubSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logo?: boolean
    description?: boolean
    rules?: boolean
    leaderId?: boolean
    visibility?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["club"]>

  export type ClubSelectScalar = {
    id?: boolean
    name?: boolean
    logo?: boolean
    description?: boolean
    rules?: boolean
    leaderId?: boolean
    visibility?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClubOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "logo" | "description" | "rules" | "leaderId" | "visibility" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["club"]>
  export type ClubInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leader?: boolean | UserDefaultArgs<ExtArgs>
    clubMember?: boolean | Club$clubMemberArgs<ExtArgs>
    tournamentRegistration?: boolean | Club$tournamentRegistrationArgs<ExtArgs>
    _count?: boolean | ClubCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClubIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClubIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClubPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Club"
    objects: {
      leader: Prisma.$UserPayload<ExtArgs>
      clubMember: Prisma.$ClubMemberPayload<ExtArgs>[]
      tournamentRegistration: Prisma.$TournamentRegistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      logo: string | null
      description: string | null
      rules: string | null
      leaderId: string
      visibility: $Enums.ClubVisibility
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["club"]>
    composites: {}
  }

  type ClubGetPayload<S extends boolean | null | undefined | ClubDefaultArgs> = $Result.GetResult<Prisma.$ClubPayload, S>

  type ClubCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubCountAggregateInputType | true
    }

  export interface ClubDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Club'], meta: { name: 'Club' } }
    /**
     * Find zero or one Club that matches the filter.
     * @param {ClubFindUniqueArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubFindUniqueArgs>(args: SelectSubset<T, ClubFindUniqueArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Club that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubFindUniqueOrThrowArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Club that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubFindFirstArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubFindFirstArgs>(args?: SelectSubset<T, ClubFindFirstArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Club that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubFindFirstOrThrowArgs} args - Arguments to find a Club
     * @example
     * // Get one Club
     * const club = await prisma.club.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clubs
     * const clubs = await prisma.club.findMany()
     * 
     * // Get first 10 Clubs
     * const clubs = await prisma.club.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubWithIdOnly = await prisma.club.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClubFindManyArgs>(args?: SelectSubset<T, ClubFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Club.
     * @param {ClubCreateArgs} args - Arguments to create a Club.
     * @example
     * // Create one Club
     * const Club = await prisma.club.create({
     *   data: {
     *     // ... data to create a Club
     *   }
     * })
     * 
     */
    create<T extends ClubCreateArgs>(args: SelectSubset<T, ClubCreateArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clubs.
     * @param {ClubCreateManyArgs} args - Arguments to create many Clubs.
     * @example
     * // Create many Clubs
     * const club = await prisma.club.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubCreateManyArgs>(args?: SelectSubset<T, ClubCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clubs and returns the data saved in the database.
     * @param {ClubCreateManyAndReturnArgs} args - Arguments to create many Clubs.
     * @example
     * // Create many Clubs
     * const club = await prisma.club.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clubs and only return the `id`
     * const clubWithIdOnly = await prisma.club.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Club.
     * @param {ClubDeleteArgs} args - Arguments to delete one Club.
     * @example
     * // Delete one Club
     * const Club = await prisma.club.delete({
     *   where: {
     *     // ... filter to delete one Club
     *   }
     * })
     * 
     */
    delete<T extends ClubDeleteArgs>(args: SelectSubset<T, ClubDeleteArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Club.
     * @param {ClubUpdateArgs} args - Arguments to update one Club.
     * @example
     * // Update one Club
     * const club = await prisma.club.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubUpdateArgs>(args: SelectSubset<T, ClubUpdateArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clubs.
     * @param {ClubDeleteManyArgs} args - Arguments to filter Clubs to delete.
     * @example
     * // Delete a few Clubs
     * const { count } = await prisma.club.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubDeleteManyArgs>(args?: SelectSubset<T, ClubDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clubs
     * const club = await prisma.club.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubUpdateManyArgs>(args: SelectSubset<T, ClubUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clubs and returns the data updated in the database.
     * @param {ClubUpdateManyAndReturnArgs} args - Arguments to update many Clubs.
     * @example
     * // Update many Clubs
     * const club = await prisma.club.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clubs and only return the `id`
     * const clubWithIdOnly = await prisma.club.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Club.
     * @param {ClubUpsertArgs} args - Arguments to update or create a Club.
     * @example
     * // Update or create a Club
     * const club = await prisma.club.upsert({
     *   create: {
     *     // ... data to create a Club
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Club we want to update
     *   }
     * })
     */
    upsert<T extends ClubUpsertArgs>(args: SelectSubset<T, ClubUpsertArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubCountArgs} args - Arguments to filter Clubs to count.
     * @example
     * // Count the number of Clubs
     * const count = await prisma.club.count({
     *   where: {
     *     // ... the filter for the Clubs we want to count
     *   }
     * })
    **/
    count<T extends ClubCountArgs>(
      args?: Subset<T, ClubCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Club.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubAggregateArgs>(args: Subset<T, ClubAggregateArgs>): Prisma.PrismaPromise<GetClubAggregateType<T>>

    /**
     * Group by Club.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubGroupByArgs['orderBy'] }
        : { orderBy?: ClubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Club model
   */
  readonly fields: ClubFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Club.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clubMember<T extends Club$clubMemberArgs<ExtArgs> = {}>(args?: Subset<T, Club$clubMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournamentRegistration<T extends Club$tournamentRegistrationArgs<ExtArgs> = {}>(args?: Subset<T, Club$tournamentRegistrationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Club model
   */
  interface ClubFieldRefs {
    readonly id: FieldRef<"Club", 'String'>
    readonly name: FieldRef<"Club", 'String'>
    readonly logo: FieldRef<"Club", 'String'>
    readonly description: FieldRef<"Club", 'String'>
    readonly rules: FieldRef<"Club", 'String'>
    readonly leaderId: FieldRef<"Club", 'String'>
    readonly visibility: FieldRef<"Club", 'ClubVisibility'>
    readonly isActive: FieldRef<"Club", 'Boolean'>
    readonly createdAt: FieldRef<"Club", 'DateTime'>
    readonly updatedAt: FieldRef<"Club", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Club findUnique
   */
  export type ClubFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club findUniqueOrThrow
   */
  export type ClubFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club findFirst
   */
  export type ClubFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clubs.
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clubs.
     */
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * Club findFirstOrThrow
   */
  export type ClubFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Club to fetch.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clubs.
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clubs.
     */
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * Club findMany
   */
  export type ClubFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter, which Clubs to fetch.
     */
    where?: ClubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clubs to fetch.
     */
    orderBy?: ClubOrderByWithRelationInput | ClubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clubs.
     */
    cursor?: ClubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clubs.
     */
    skip?: number
    distinct?: ClubScalarFieldEnum | ClubScalarFieldEnum[]
  }

  /**
   * Club create
   */
  export type ClubCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * The data needed to create a Club.
     */
    data: XOR<ClubCreateInput, ClubUncheckedCreateInput>
  }

  /**
   * Club createMany
   */
  export type ClubCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clubs.
     */
    data: ClubCreateManyInput | ClubCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Club createManyAndReturn
   */
  export type ClubCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * The data used to create many Clubs.
     */
    data: ClubCreateManyInput | ClubCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Club update
   */
  export type ClubUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * The data needed to update a Club.
     */
    data: XOR<ClubUpdateInput, ClubUncheckedUpdateInput>
    /**
     * Choose, which Club to update.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club updateMany
   */
  export type ClubUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clubs.
     */
    data: XOR<ClubUpdateManyMutationInput, ClubUncheckedUpdateManyInput>
    /**
     * Filter which Clubs to update
     */
    where?: ClubWhereInput
    /**
     * Limit how many Clubs to update.
     */
    limit?: number
  }

  /**
   * Club updateManyAndReturn
   */
  export type ClubUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * The data used to update Clubs.
     */
    data: XOR<ClubUpdateManyMutationInput, ClubUncheckedUpdateManyInput>
    /**
     * Filter which Clubs to update
     */
    where?: ClubWhereInput
    /**
     * Limit how many Clubs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Club upsert
   */
  export type ClubUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * The filter to search for the Club to update in case it exists.
     */
    where: ClubWhereUniqueInput
    /**
     * In case the Club found by the `where` argument doesn't exist, create a new Club with this data.
     */
    create: XOR<ClubCreateInput, ClubUncheckedCreateInput>
    /**
     * In case the Club was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubUpdateInput, ClubUncheckedUpdateInput>
  }

  /**
   * Club delete
   */
  export type ClubDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
    /**
     * Filter which Club to delete.
     */
    where: ClubWhereUniqueInput
  }

  /**
   * Club deleteMany
   */
  export type ClubDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clubs to delete
     */
    where?: ClubWhereInput
    /**
     * Limit how many Clubs to delete.
     */
    limit?: number
  }

  /**
   * Club.clubMember
   */
  export type Club$clubMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    where?: ClubMemberWhereInput
    orderBy?: ClubMemberOrderByWithRelationInput | ClubMemberOrderByWithRelationInput[]
    cursor?: ClubMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClubMemberScalarFieldEnum | ClubMemberScalarFieldEnum[]
  }

  /**
   * Club.tournamentRegistration
   */
  export type Club$tournamentRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    where?: TournamentRegistrationWhereInput
    orderBy?: TournamentRegistrationOrderByWithRelationInput | TournamentRegistrationOrderByWithRelationInput[]
    cursor?: TournamentRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentRegistrationScalarFieldEnum | TournamentRegistrationScalarFieldEnum[]
  }

  /**
   * Club without action
   */
  export type ClubDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Club
     */
    select?: ClubSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Club
     */
    omit?: ClubOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubInclude<ExtArgs> | null
  }


  /**
   * Model ClubMember
   */

  export type AggregateClubMember = {
    _count: ClubMemberCountAggregateOutputType | null
    _min: ClubMemberMinAggregateOutputType | null
    _max: ClubMemberMaxAggregateOutputType | null
  }

  export type ClubMemberMinAggregateOutputType = {
    id: string | null
    clubId: string | null
    userId: string | null
    joinedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClubMemberMaxAggregateOutputType = {
    id: string | null
    clubId: string | null
    userId: string | null
    joinedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClubMemberCountAggregateOutputType = {
    id: number
    clubId: number
    userId: number
    joinedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClubMemberMinAggregateInputType = {
    id?: true
    clubId?: true
    userId?: true
    joinedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClubMemberMaxAggregateInputType = {
    id?: true
    clubId?: true
    userId?: true
    joinedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClubMemberCountAggregateInputType = {
    id?: true
    clubId?: true
    userId?: true
    joinedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClubMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubMember to aggregate.
     */
    where?: ClubMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubMembers to fetch.
     */
    orderBy?: ClubMemberOrderByWithRelationInput | ClubMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClubMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClubMembers
    **/
    _count?: true | ClubMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClubMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClubMemberMaxAggregateInputType
  }

  export type GetClubMemberAggregateType<T extends ClubMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateClubMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClubMember[P]>
      : GetScalarType<T[P], AggregateClubMember[P]>
  }




  export type ClubMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClubMemberWhereInput
    orderBy?: ClubMemberOrderByWithAggregationInput | ClubMemberOrderByWithAggregationInput[]
    by: ClubMemberScalarFieldEnum[] | ClubMemberScalarFieldEnum
    having?: ClubMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClubMemberCountAggregateInputType | true
    _min?: ClubMemberMinAggregateInputType
    _max?: ClubMemberMaxAggregateInputType
  }

  export type ClubMemberGroupByOutputType = {
    id: string
    clubId: string
    userId: string
    joinedAt: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClubMemberCountAggregateOutputType | null
    _min: ClubMemberMinAggregateOutputType | null
    _max: ClubMemberMaxAggregateOutputType | null
  }

  type GetClubMemberGroupByPayload<T extends ClubMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClubMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClubMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClubMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ClubMemberGroupByOutputType[P]>
        }
      >
    >


  export type ClubMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubId?: boolean
    userId?: boolean
    joinedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubMember"]>

  export type ClubMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubId?: boolean
    userId?: boolean
    joinedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubMember"]>

  export type ClubMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clubId?: boolean
    userId?: boolean
    joinedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    club?: boolean | ClubDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clubMember"]>

  export type ClubMemberSelectScalar = {
    id?: boolean
    clubId?: boolean
    userId?: boolean
    joinedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClubMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clubId" | "userId" | "joinedAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["clubMember"]>
  export type ClubMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClubMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClubMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    club?: boolean | ClubDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClubMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClubMember"
    objects: {
      club: Prisma.$ClubPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clubId: string
      userId: string
      joinedAt: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clubMember"]>
    composites: {}
  }

  type ClubMemberGetPayload<S extends boolean | null | undefined | ClubMemberDefaultArgs> = $Result.GetResult<Prisma.$ClubMemberPayload, S>

  type ClubMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClubMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClubMemberCountAggregateInputType | true
    }

  export interface ClubMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClubMember'], meta: { name: 'ClubMember' } }
    /**
     * Find zero or one ClubMember that matches the filter.
     * @param {ClubMemberFindUniqueArgs} args - Arguments to find a ClubMember
     * @example
     * // Get one ClubMember
     * const clubMember = await prisma.clubMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClubMemberFindUniqueArgs>(args: SelectSubset<T, ClubMemberFindUniqueArgs<ExtArgs>>): Prisma__ClubMemberClient<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClubMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClubMemberFindUniqueOrThrowArgs} args - Arguments to find a ClubMember
     * @example
     * // Get one ClubMember
     * const clubMember = await prisma.clubMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClubMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ClubMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClubMemberClient<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubMemberFindFirstArgs} args - Arguments to find a ClubMember
     * @example
     * // Get one ClubMember
     * const clubMember = await prisma.clubMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClubMemberFindFirstArgs>(args?: SelectSubset<T, ClubMemberFindFirstArgs<ExtArgs>>): Prisma__ClubMemberClient<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClubMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubMemberFindFirstOrThrowArgs} args - Arguments to find a ClubMember
     * @example
     * // Get one ClubMember
     * const clubMember = await prisma.clubMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClubMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ClubMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClubMemberClient<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClubMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClubMembers
     * const clubMembers = await prisma.clubMember.findMany()
     * 
     * // Get first 10 ClubMembers
     * const clubMembers = await prisma.clubMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clubMemberWithIdOnly = await prisma.clubMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClubMemberFindManyArgs>(args?: SelectSubset<T, ClubMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClubMember.
     * @param {ClubMemberCreateArgs} args - Arguments to create a ClubMember.
     * @example
     * // Create one ClubMember
     * const ClubMember = await prisma.clubMember.create({
     *   data: {
     *     // ... data to create a ClubMember
     *   }
     * })
     * 
     */
    create<T extends ClubMemberCreateArgs>(args: SelectSubset<T, ClubMemberCreateArgs<ExtArgs>>): Prisma__ClubMemberClient<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClubMembers.
     * @param {ClubMemberCreateManyArgs} args - Arguments to create many ClubMembers.
     * @example
     * // Create many ClubMembers
     * const clubMember = await prisma.clubMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClubMemberCreateManyArgs>(args?: SelectSubset<T, ClubMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClubMembers and returns the data saved in the database.
     * @param {ClubMemberCreateManyAndReturnArgs} args - Arguments to create many ClubMembers.
     * @example
     * // Create many ClubMembers
     * const clubMember = await prisma.clubMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClubMembers and only return the `id`
     * const clubMemberWithIdOnly = await prisma.clubMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClubMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ClubMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClubMember.
     * @param {ClubMemberDeleteArgs} args - Arguments to delete one ClubMember.
     * @example
     * // Delete one ClubMember
     * const ClubMember = await prisma.clubMember.delete({
     *   where: {
     *     // ... filter to delete one ClubMember
     *   }
     * })
     * 
     */
    delete<T extends ClubMemberDeleteArgs>(args: SelectSubset<T, ClubMemberDeleteArgs<ExtArgs>>): Prisma__ClubMemberClient<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClubMember.
     * @param {ClubMemberUpdateArgs} args - Arguments to update one ClubMember.
     * @example
     * // Update one ClubMember
     * const clubMember = await prisma.clubMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClubMemberUpdateArgs>(args: SelectSubset<T, ClubMemberUpdateArgs<ExtArgs>>): Prisma__ClubMemberClient<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClubMembers.
     * @param {ClubMemberDeleteManyArgs} args - Arguments to filter ClubMembers to delete.
     * @example
     * // Delete a few ClubMembers
     * const { count } = await prisma.clubMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClubMemberDeleteManyArgs>(args?: SelectSubset<T, ClubMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClubMembers
     * const clubMember = await prisma.clubMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClubMemberUpdateManyArgs>(args: SelectSubset<T, ClubMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClubMembers and returns the data updated in the database.
     * @param {ClubMemberUpdateManyAndReturnArgs} args - Arguments to update many ClubMembers.
     * @example
     * // Update many ClubMembers
     * const clubMember = await prisma.clubMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClubMembers and only return the `id`
     * const clubMemberWithIdOnly = await prisma.clubMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClubMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ClubMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClubMember.
     * @param {ClubMemberUpsertArgs} args - Arguments to update or create a ClubMember.
     * @example
     * // Update or create a ClubMember
     * const clubMember = await prisma.clubMember.upsert({
     *   create: {
     *     // ... data to create a ClubMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClubMember we want to update
     *   }
     * })
     */
    upsert<T extends ClubMemberUpsertArgs>(args: SelectSubset<T, ClubMemberUpsertArgs<ExtArgs>>): Prisma__ClubMemberClient<$Result.GetResult<Prisma.$ClubMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClubMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubMemberCountArgs} args - Arguments to filter ClubMembers to count.
     * @example
     * // Count the number of ClubMembers
     * const count = await prisma.clubMember.count({
     *   where: {
     *     // ... the filter for the ClubMembers we want to count
     *   }
     * })
    **/
    count<T extends ClubMemberCountArgs>(
      args?: Subset<T, ClubMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClubMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClubMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClubMemberAggregateArgs>(args: Subset<T, ClubMemberAggregateArgs>): Prisma.PrismaPromise<GetClubMemberAggregateType<T>>

    /**
     * Group by ClubMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClubMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClubMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClubMemberGroupByArgs['orderBy'] }
        : { orderBy?: ClubMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClubMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClubMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClubMember model
   */
  readonly fields: ClubMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClubMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClubMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    club<T extends ClubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubDefaultArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClubMember model
   */
  interface ClubMemberFieldRefs {
    readonly id: FieldRef<"ClubMember", 'String'>
    readonly clubId: FieldRef<"ClubMember", 'String'>
    readonly userId: FieldRef<"ClubMember", 'String'>
    readonly joinedAt: FieldRef<"ClubMember", 'DateTime'>
    readonly isActive: FieldRef<"ClubMember", 'Boolean'>
    readonly createdAt: FieldRef<"ClubMember", 'DateTime'>
    readonly updatedAt: FieldRef<"ClubMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClubMember findUnique
   */
  export type ClubMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClubMember to fetch.
     */
    where: ClubMemberWhereUniqueInput
  }

  /**
   * ClubMember findUniqueOrThrow
   */
  export type ClubMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClubMember to fetch.
     */
    where: ClubMemberWhereUniqueInput
  }

  /**
   * ClubMember findFirst
   */
  export type ClubMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClubMember to fetch.
     */
    where?: ClubMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubMembers to fetch.
     */
    orderBy?: ClubMemberOrderByWithRelationInput | ClubMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubMembers.
     */
    cursor?: ClubMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubMembers.
     */
    distinct?: ClubMemberScalarFieldEnum | ClubMemberScalarFieldEnum[]
  }

  /**
   * ClubMember findFirstOrThrow
   */
  export type ClubMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClubMember to fetch.
     */
    where?: ClubMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubMembers to fetch.
     */
    orderBy?: ClubMemberOrderByWithRelationInput | ClubMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClubMembers.
     */
    cursor?: ClubMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClubMembers.
     */
    distinct?: ClubMemberScalarFieldEnum | ClubMemberScalarFieldEnum[]
  }

  /**
   * ClubMember findMany
   */
  export type ClubMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    /**
     * Filter, which ClubMembers to fetch.
     */
    where?: ClubMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClubMembers to fetch.
     */
    orderBy?: ClubMemberOrderByWithRelationInput | ClubMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClubMembers.
     */
    cursor?: ClubMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClubMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClubMembers.
     */
    skip?: number
    distinct?: ClubMemberScalarFieldEnum | ClubMemberScalarFieldEnum[]
  }

  /**
   * ClubMember create
   */
  export type ClubMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ClubMember.
     */
    data: XOR<ClubMemberCreateInput, ClubMemberUncheckedCreateInput>
  }

  /**
   * ClubMember createMany
   */
  export type ClubMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClubMembers.
     */
    data: ClubMemberCreateManyInput | ClubMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClubMember createManyAndReturn
   */
  export type ClubMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ClubMembers.
     */
    data: ClubMemberCreateManyInput | ClubMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubMember update
   */
  export type ClubMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ClubMember.
     */
    data: XOR<ClubMemberUpdateInput, ClubMemberUncheckedUpdateInput>
    /**
     * Choose, which ClubMember to update.
     */
    where: ClubMemberWhereUniqueInput
  }

  /**
   * ClubMember updateMany
   */
  export type ClubMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClubMembers.
     */
    data: XOR<ClubMemberUpdateManyMutationInput, ClubMemberUncheckedUpdateManyInput>
    /**
     * Filter which ClubMembers to update
     */
    where?: ClubMemberWhereInput
    /**
     * Limit how many ClubMembers to update.
     */
    limit?: number
  }

  /**
   * ClubMember updateManyAndReturn
   */
  export type ClubMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * The data used to update ClubMembers.
     */
    data: XOR<ClubMemberUpdateManyMutationInput, ClubMemberUncheckedUpdateManyInput>
    /**
     * Filter which ClubMembers to update
     */
    where?: ClubMemberWhereInput
    /**
     * Limit how many ClubMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClubMember upsert
   */
  export type ClubMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ClubMember to update in case it exists.
     */
    where: ClubMemberWhereUniqueInput
    /**
     * In case the ClubMember found by the `where` argument doesn't exist, create a new ClubMember with this data.
     */
    create: XOR<ClubMemberCreateInput, ClubMemberUncheckedCreateInput>
    /**
     * In case the ClubMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClubMemberUpdateInput, ClubMemberUncheckedUpdateInput>
  }

  /**
   * ClubMember delete
   */
  export type ClubMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
    /**
     * Filter which ClubMember to delete.
     */
    where: ClubMemberWhereUniqueInput
  }

  /**
   * ClubMember deleteMany
   */
  export type ClubMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClubMembers to delete
     */
    where?: ClubMemberWhereInput
    /**
     * Limit how many ClubMembers to delete.
     */
    limit?: number
  }

  /**
   * ClubMember without action
   */
  export type ClubMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClubMember
     */
    select?: ClubMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClubMember
     */
    omit?: ClubMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClubMemberInclude<ExtArgs> | null
  }


  /**
   * Model Tournament
   */

  export type AggregateTournament = {
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  export type TournamentAvgAggregateOutputType = {
    maxTeams: number | null
    teamSize: number | null
    entryFee: number | null
  }

  export type TournamentSumAggregateOutputType = {
    maxTeams: number | null
    teamSize: number | null
    entryFee: number | null
  }

  export type TournamentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rules: string | null
    image: string | null
    startDate: Date | null
    endDate: Date | null
    startTime: string | null
    endTime: string | null
    maxTeams: number | null
    teamSize: number | null
    entryFee: number | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TournamentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    rules: string | null
    image: string | null
    startDate: Date | null
    endDate: Date | null
    startTime: string | null
    endTime: string | null
    maxTeams: number | null
    teamSize: number | null
    entryFee: number | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TournamentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    rules: number
    image: number
    startDate: number
    endDate: number
    startTime: number
    endTime: number
    maxTeams: number
    teamSize: number
    entryFee: number
    location: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TournamentAvgAggregateInputType = {
    maxTeams?: true
    teamSize?: true
    entryFee?: true
  }

  export type TournamentSumAggregateInputType = {
    maxTeams?: true
    teamSize?: true
    entryFee?: true
  }

  export type TournamentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rules?: true
    image?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    maxTeams?: true
    teamSize?: true
    entryFee?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TournamentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rules?: true
    image?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    maxTeams?: true
    teamSize?: true
    entryFee?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TournamentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rules?: true
    image?: true
    startDate?: true
    endDate?: true
    startTime?: true
    endTime?: true
    maxTeams?: true
    teamSize?: true
    entryFee?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TournamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournament to aggregate.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tournaments
    **/
    _count?: true | TournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentMaxAggregateInputType
  }

  export type GetTournamentAggregateType<T extends TournamentAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament[P]>
      : GetScalarType<T[P], AggregateTournament[P]>
  }




  export type TournamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentWhereInput
    orderBy?: TournamentOrderByWithAggregationInput | TournamentOrderByWithAggregationInput[]
    by: TournamentScalarFieldEnum[] | TournamentScalarFieldEnum
    having?: TournamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentCountAggregateInputType | true
    _avg?: TournamentAvgAggregateInputType
    _sum?: TournamentSumAggregateInputType
    _min?: TournamentMinAggregateInputType
    _max?: TournamentMaxAggregateInputType
  }

  export type TournamentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    rules: string | null
    image: string | null
    startDate: Date
    endDate: Date
    startTime: string
    endTime: string
    maxTeams: number
    teamSize: number
    entryFee: number
    location: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  type GetTournamentGroupByPayload<T extends TournamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentGroupByOutputType[P]>
        }
      >
    >


  export type TournamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    image?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxTeams?: boolean
    teamSize?: boolean
    entryFee?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tournamentRegistration?: boolean | Tournament$tournamentRegistrationArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    image?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxTeams?: boolean
    teamSize?: boolean
    entryFee?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    image?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxTeams?: boolean
    teamSize?: boolean
    entryFee?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    image?: boolean
    startDate?: boolean
    endDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxTeams?: boolean
    teamSize?: boolean
    entryFee?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TournamentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "rules" | "image" | "startDate" | "endDate" | "startTime" | "endTime" | "maxTeams" | "teamSize" | "entryFee" | "location" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["tournament"]>
  export type TournamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournamentRegistration?: boolean | Tournament$tournamentRegistrationArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TournamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TournamentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TournamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tournament"
    objects: {
      tournamentRegistration: Prisma.$TournamentRegistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      rules: string | null
      image: string | null
      startDate: Date
      endDate: Date
      startTime: string
      endTime: string
      maxTeams: number
      teamSize: number
      entryFee: number
      location: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tournament"]>
    composites: {}
  }

  type TournamentGetPayload<S extends boolean | null | undefined | TournamentDefaultArgs> = $Result.GetResult<Prisma.$TournamentPayload, S>

  type TournamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TournamentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentCountAggregateInputType | true
    }

  export interface TournamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tournament'], meta: { name: 'Tournament' } }
    /**
     * Find zero or one Tournament that matches the filter.
     * @param {TournamentFindUniqueArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentFindUniqueArgs>(args: SelectSubset<T, TournamentFindUniqueArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournament that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TournamentFindUniqueOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentFindFirstArgs>(args?: SelectSubset<T, TournamentFindFirstArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournament.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentWithIdOnly = await prisma.tournament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamentFindManyArgs>(args?: SelectSubset<T, TournamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournament.
     * @param {TournamentCreateArgs} args - Arguments to create a Tournament.
     * @example
     * // Create one Tournament
     * const Tournament = await prisma.tournament.create({
     *   data: {
     *     // ... data to create a Tournament
     *   }
     * })
     * 
     */
    create<T extends TournamentCreateArgs>(args: SelectSubset<T, TournamentCreateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournaments.
     * @param {TournamentCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentCreateManyArgs>(args?: SelectSubset<T, TournamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {TournamentCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournament.
     * @param {TournamentDeleteArgs} args - Arguments to delete one Tournament.
     * @example
     * // Delete one Tournament
     * const Tournament = await prisma.tournament.delete({
     *   where: {
     *     // ... filter to delete one Tournament
     *   }
     * })
     * 
     */
    delete<T extends TournamentDeleteArgs>(args: SelectSubset<T, TournamentDeleteArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournament.
     * @param {TournamentUpdateArgs} args - Arguments to update one Tournament.
     * @example
     * // Update one Tournament
     * const tournament = await prisma.tournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentUpdateArgs>(args: SelectSubset<T, TournamentUpdateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournaments.
     * @param {TournamentDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentDeleteManyArgs>(args?: SelectSubset<T, TournamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentUpdateManyArgs>(args: SelectSubset<T, TournamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments and returns the data updated in the database.
     * @param {TournamentUpdateManyAndReturnArgs} args - Arguments to update many Tournaments.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TournamentUpdateManyAndReturnArgs>(args: SelectSubset<T, TournamentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournament.
     * @param {TournamentUpsertArgs} args - Arguments to update or create a Tournament.
     * @example
     * // Update or create a Tournament
     * const tournament = await prisma.tournament.upsert({
     *   create: {
     *     // ... data to create a Tournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament we want to update
     *   }
     * })
     */
    upsert<T extends TournamentUpsertArgs>(args: SelectSubset<T, TournamentUpsertArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournament.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends TournamentCountArgs>(
      args?: Subset<T, TournamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentAggregateArgs>(args: Subset<T, TournamentAggregateArgs>): Prisma.PrismaPromise<GetTournamentAggregateType<T>>

    /**
     * Group by Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentGroupByArgs['orderBy'] }
        : { orderBy?: TournamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tournament model
   */
  readonly fields: TournamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournamentRegistration<T extends Tournament$tournamentRegistrationArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$tournamentRegistrationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tournament model
   */
  interface TournamentFieldRefs {
    readonly id: FieldRef<"Tournament", 'String'>
    readonly name: FieldRef<"Tournament", 'String'>
    readonly description: FieldRef<"Tournament", 'String'>
    readonly rules: FieldRef<"Tournament", 'String'>
    readonly image: FieldRef<"Tournament", 'String'>
    readonly startDate: FieldRef<"Tournament", 'DateTime'>
    readonly endDate: FieldRef<"Tournament", 'DateTime'>
    readonly startTime: FieldRef<"Tournament", 'String'>
    readonly endTime: FieldRef<"Tournament", 'String'>
    readonly maxTeams: FieldRef<"Tournament", 'Int'>
    readonly teamSize: FieldRef<"Tournament", 'Int'>
    readonly entryFee: FieldRef<"Tournament", 'Int'>
    readonly location: FieldRef<"Tournament", 'String'>
    readonly isActive: FieldRef<"Tournament", 'Boolean'>
    readonly createdAt: FieldRef<"Tournament", 'DateTime'>
    readonly updatedAt: FieldRef<"Tournament", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tournament findUnique
   */
  export type TournamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findUniqueOrThrow
   */
  export type TournamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findFirst
   */
  export type TournamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findFirstOrThrow
   */
  export type TournamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findMany
   */
  export type TournamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournaments to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament create
   */
  export type TournamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to create a Tournament.
     */
    data: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
  }

  /**
   * Tournament createMany
   */
  export type TournamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tournament createManyAndReturn
   */
  export type TournamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tournament update
   */
  export type TournamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to update a Tournament.
     */
    data: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
    /**
     * Choose, which Tournament to update.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament updateMany
   */
  export type TournamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tournaments.
     */
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyInput>
    /**
     * Filter which Tournaments to update
     */
    where?: TournamentWhereInput
    /**
     * Limit how many Tournaments to update.
     */
    limit?: number
  }

  /**
   * Tournament updateManyAndReturn
   */
  export type TournamentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * The data used to update Tournaments.
     */
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyInput>
    /**
     * Filter which Tournaments to update
     */
    where?: TournamentWhereInput
    /**
     * Limit how many Tournaments to update.
     */
    limit?: number
  }

  /**
   * Tournament upsert
   */
  export type TournamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The filter to search for the Tournament to update in case it exists.
     */
    where: TournamentWhereUniqueInput
    /**
     * In case the Tournament found by the `where` argument doesn't exist, create a new Tournament with this data.
     */
    create: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
    /**
     * In case the Tournament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
  }

  /**
   * Tournament delete
   */
  export type TournamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter which Tournament to delete.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament deleteMany
   */
  export type TournamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournaments to delete
     */
    where?: TournamentWhereInput
    /**
     * Limit how many Tournaments to delete.
     */
    limit?: number
  }

  /**
   * Tournament.tournamentRegistration
   */
  export type Tournament$tournamentRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    where?: TournamentRegistrationWhereInput
    orderBy?: TournamentRegistrationOrderByWithRelationInput | TournamentRegistrationOrderByWithRelationInput[]
    cursor?: TournamentRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentRegistrationScalarFieldEnum | TournamentRegistrationScalarFieldEnum[]
  }

  /**
   * Tournament without action
   */
  export type TournamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
  }


  /**
   * Model TournamentRegistration
   */

  export type AggregateTournamentRegistration = {
    _count: TournamentRegistrationCountAggregateOutputType | null
    _avg: TournamentRegistrationAvgAggregateOutputType | null
    _sum: TournamentRegistrationSumAggregateOutputType | null
    _min: TournamentRegistrationMinAggregateOutputType | null
    _max: TournamentRegistrationMaxAggregateOutputType | null
  }

  export type TournamentRegistrationAvgAggregateOutputType = {
    members: number | null
    totalFee: number | null
  }

  export type TournamentRegistrationSumAggregateOutputType = {
    members: number | null
    totalFee: number | null
  }

  export type TournamentRegistrationMinAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    clubId: string | null
    members: number | null
    totalFee: number | null
    status: $Enums.BookingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentLockedUntil: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
  }

  export type TournamentRegistrationMaxAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    clubId: string | null
    members: number | null
    totalFee: number | null
    status: $Enums.BookingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentLockedUntil: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
  }

  export type TournamentRegistrationCountAggregateOutputType = {
    id: number
    tournamentId: number
    clubId: number
    members: number
    totalFee: number
    status: number
    createdAt: number
    updatedAt: number
    paymentLockedUntil: number
    cancelledAt: number
    cancellationReason: number
    _all: number
  }


  export type TournamentRegistrationAvgAggregateInputType = {
    members?: true
    totalFee?: true
  }

  export type TournamentRegistrationSumAggregateInputType = {
    members?: true
    totalFee?: true
  }

  export type TournamentRegistrationMinAggregateInputType = {
    id?: true
    tournamentId?: true
    clubId?: true
    members?: true
    totalFee?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentLockedUntil?: true
    cancelledAt?: true
    cancellationReason?: true
  }

  export type TournamentRegistrationMaxAggregateInputType = {
    id?: true
    tournamentId?: true
    clubId?: true
    members?: true
    totalFee?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentLockedUntil?: true
    cancelledAt?: true
    cancellationReason?: true
  }

  export type TournamentRegistrationCountAggregateInputType = {
    id?: true
    tournamentId?: true
    clubId?: true
    members?: true
    totalFee?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paymentLockedUntil?: true
    cancelledAt?: true
    cancellationReason?: true
    _all?: true
  }

  export type TournamentRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentRegistration to aggregate.
     */
    where?: TournamentRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentRegistrations to fetch.
     */
    orderBy?: TournamentRegistrationOrderByWithRelationInput | TournamentRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentRegistrations
    **/
    _count?: true | TournamentRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentRegistrationMaxAggregateInputType
  }

  export type GetTournamentRegistrationAggregateType<T extends TournamentRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamentRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentRegistration[P]>
      : GetScalarType<T[P], AggregateTournamentRegistration[P]>
  }




  export type TournamentRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentRegistrationWhereInput
    orderBy?: TournamentRegistrationOrderByWithAggregationInput | TournamentRegistrationOrderByWithAggregationInput[]
    by: TournamentRegistrationScalarFieldEnum[] | TournamentRegistrationScalarFieldEnum
    having?: TournamentRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentRegistrationCountAggregateInputType | true
    _avg?: TournamentRegistrationAvgAggregateInputType
    _sum?: TournamentRegistrationSumAggregateInputType
    _min?: TournamentRegistrationMinAggregateInputType
    _max?: TournamentRegistrationMaxAggregateInputType
  }

  export type TournamentRegistrationGroupByOutputType = {
    id: string
    tournamentId: string
    clubId: string
    members: number
    totalFee: number
    status: $Enums.BookingStatus
    createdAt: Date
    updatedAt: Date
    paymentLockedUntil: Date | null
    cancelledAt: Date | null
    cancellationReason: string | null
    _count: TournamentRegistrationCountAggregateOutputType | null
    _avg: TournamentRegistrationAvgAggregateOutputType | null
    _sum: TournamentRegistrationSumAggregateOutputType | null
    _min: TournamentRegistrationMinAggregateOutputType | null
    _max: TournamentRegistrationMaxAggregateOutputType | null
  }

  type GetTournamentRegistrationGroupByPayload<T extends TournamentRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type TournamentRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    clubId?: boolean
    members?: boolean
    totalFee?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentLockedUntil?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    membersRef?: boolean | TournamentRegistration$membersRefArgs<ExtArgs>
    invoice?: boolean | TournamentRegistration$invoiceArgs<ExtArgs>
    _count?: boolean | TournamentRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentRegistration"]>

  export type TournamentRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    clubId?: boolean
    members?: boolean
    totalFee?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentLockedUntil?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentRegistration"]>

  export type TournamentRegistrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    clubId?: boolean
    members?: boolean
    totalFee?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentLockedUntil?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentRegistration"]>

  export type TournamentRegistrationSelectScalar = {
    id?: boolean
    tournamentId?: boolean
    clubId?: boolean
    members?: boolean
    totalFee?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentLockedUntil?: boolean
    cancelledAt?: boolean
    cancellationReason?: boolean
  }

  export type TournamentRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tournamentId" | "clubId" | "members" | "totalFee" | "status" | "createdAt" | "updatedAt" | "paymentLockedUntil" | "cancelledAt" | "cancellationReason", ExtArgs["result"]["tournamentRegistration"]>
  export type TournamentRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
    membersRef?: boolean | TournamentRegistration$membersRefArgs<ExtArgs>
    invoice?: boolean | TournamentRegistration$invoiceArgs<ExtArgs>
    _count?: boolean | TournamentRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TournamentRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }
  export type TournamentRegistrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    club?: boolean | ClubDefaultArgs<ExtArgs>
  }

  export type $TournamentRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TournamentRegistration"
    objects: {
      tournament: Prisma.$TournamentPayload<ExtArgs>
      club: Prisma.$ClubPayload<ExtArgs>
      membersRef: Prisma.$TournamentRegistrationMemberPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tournamentId: string
      clubId: string
      members: number
      totalFee: number
      status: $Enums.BookingStatus
      createdAt: Date
      updatedAt: Date
      paymentLockedUntil: Date | null
      cancelledAt: Date | null
      cancellationReason: string | null
    }, ExtArgs["result"]["tournamentRegistration"]>
    composites: {}
  }

  type TournamentRegistrationGetPayload<S extends boolean | null | undefined | TournamentRegistrationDefaultArgs> = $Result.GetResult<Prisma.$TournamentRegistrationPayload, S>

  type TournamentRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TournamentRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentRegistrationCountAggregateInputType | true
    }

  export interface TournamentRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TournamentRegistration'], meta: { name: 'TournamentRegistration' } }
    /**
     * Find zero or one TournamentRegistration that matches the filter.
     * @param {TournamentRegistrationFindUniqueArgs} args - Arguments to find a TournamentRegistration
     * @example
     * // Get one TournamentRegistration
     * const tournamentRegistration = await prisma.tournamentRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentRegistrationFindUniqueArgs>(args: SelectSubset<T, TournamentRegistrationFindUniqueArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TournamentRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TournamentRegistrationFindUniqueOrThrowArgs} args - Arguments to find a TournamentRegistration
     * @example
     * // Get one TournamentRegistration
     * const tournamentRegistration = await prisma.tournamentRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationFindFirstArgs} args - Arguments to find a TournamentRegistration
     * @example
     * // Get one TournamentRegistration
     * const tournamentRegistration = await prisma.tournamentRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentRegistrationFindFirstArgs>(args?: SelectSubset<T, TournamentRegistrationFindFirstArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationFindFirstOrThrowArgs} args - Arguments to find a TournamentRegistration
     * @example
     * // Get one TournamentRegistration
     * const tournamentRegistration = await prisma.tournamentRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TournamentRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentRegistrations
     * const tournamentRegistrations = await prisma.tournamentRegistration.findMany()
     * 
     * // Get first 10 TournamentRegistrations
     * const tournamentRegistrations = await prisma.tournamentRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentRegistrationWithIdOnly = await prisma.tournamentRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamentRegistrationFindManyArgs>(args?: SelectSubset<T, TournamentRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TournamentRegistration.
     * @param {TournamentRegistrationCreateArgs} args - Arguments to create a TournamentRegistration.
     * @example
     * // Create one TournamentRegistration
     * const TournamentRegistration = await prisma.tournamentRegistration.create({
     *   data: {
     *     // ... data to create a TournamentRegistration
     *   }
     * })
     * 
     */
    create<T extends TournamentRegistrationCreateArgs>(args: SelectSubset<T, TournamentRegistrationCreateArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TournamentRegistrations.
     * @param {TournamentRegistrationCreateManyArgs} args - Arguments to create many TournamentRegistrations.
     * @example
     * // Create many TournamentRegistrations
     * const tournamentRegistration = await prisma.tournamentRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentRegistrationCreateManyArgs>(args?: SelectSubset<T, TournamentRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TournamentRegistrations and returns the data saved in the database.
     * @param {TournamentRegistrationCreateManyAndReturnArgs} args - Arguments to create many TournamentRegistrations.
     * @example
     * // Create many TournamentRegistrations
     * const tournamentRegistration = await prisma.tournamentRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TournamentRegistrations and only return the `id`
     * const tournamentRegistrationWithIdOnly = await prisma.tournamentRegistration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TournamentRegistration.
     * @param {TournamentRegistrationDeleteArgs} args - Arguments to delete one TournamentRegistration.
     * @example
     * // Delete one TournamentRegistration
     * const TournamentRegistration = await prisma.tournamentRegistration.delete({
     *   where: {
     *     // ... filter to delete one TournamentRegistration
     *   }
     * })
     * 
     */
    delete<T extends TournamentRegistrationDeleteArgs>(args: SelectSubset<T, TournamentRegistrationDeleteArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TournamentRegistration.
     * @param {TournamentRegistrationUpdateArgs} args - Arguments to update one TournamentRegistration.
     * @example
     * // Update one TournamentRegistration
     * const tournamentRegistration = await prisma.tournamentRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentRegistrationUpdateArgs>(args: SelectSubset<T, TournamentRegistrationUpdateArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TournamentRegistrations.
     * @param {TournamentRegistrationDeleteManyArgs} args - Arguments to filter TournamentRegistrations to delete.
     * @example
     * // Delete a few TournamentRegistrations
     * const { count } = await prisma.tournamentRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentRegistrationDeleteManyArgs>(args?: SelectSubset<T, TournamentRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentRegistrations
     * const tournamentRegistration = await prisma.tournamentRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentRegistrationUpdateManyArgs>(args: SelectSubset<T, TournamentRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentRegistrations and returns the data updated in the database.
     * @param {TournamentRegistrationUpdateManyAndReturnArgs} args - Arguments to update many TournamentRegistrations.
     * @example
     * // Update many TournamentRegistrations
     * const tournamentRegistration = await prisma.tournamentRegistration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TournamentRegistrations and only return the `id`
     * const tournamentRegistrationWithIdOnly = await prisma.tournamentRegistration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TournamentRegistrationUpdateManyAndReturnArgs>(args: SelectSubset<T, TournamentRegistrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TournamentRegistration.
     * @param {TournamentRegistrationUpsertArgs} args - Arguments to update or create a TournamentRegistration.
     * @example
     * // Update or create a TournamentRegistration
     * const tournamentRegistration = await prisma.tournamentRegistration.upsert({
     *   create: {
     *     // ... data to create a TournamentRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentRegistration we want to update
     *   }
     * })
     */
    upsert<T extends TournamentRegistrationUpsertArgs>(args: SelectSubset<T, TournamentRegistrationUpsertArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TournamentRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationCountArgs} args - Arguments to filter TournamentRegistrations to count.
     * @example
     * // Count the number of TournamentRegistrations
     * const count = await prisma.tournamentRegistration.count({
     *   where: {
     *     // ... the filter for the TournamentRegistrations we want to count
     *   }
     * })
    **/
    count<T extends TournamentRegistrationCountArgs>(
      args?: Subset<T, TournamentRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentRegistrationAggregateArgs>(args: Subset<T, TournamentRegistrationAggregateArgs>): Prisma.PrismaPromise<GetTournamentRegistrationAggregateType<T>>

    /**
     * Group by TournamentRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: TournamentRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TournamentRegistration model
   */
  readonly fields: TournamentRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournament<T extends TournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentDefaultArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    club<T extends ClubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClubDefaultArgs<ExtArgs>>): Prisma__ClubClient<$Result.GetResult<Prisma.$ClubPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    membersRef<T extends TournamentRegistration$membersRefArgs<ExtArgs> = {}>(args?: Subset<T, TournamentRegistration$membersRefArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends TournamentRegistration$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, TournamentRegistration$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TournamentRegistration model
   */
  interface TournamentRegistrationFieldRefs {
    readonly id: FieldRef<"TournamentRegistration", 'String'>
    readonly tournamentId: FieldRef<"TournamentRegistration", 'String'>
    readonly clubId: FieldRef<"TournamentRegistration", 'String'>
    readonly members: FieldRef<"TournamentRegistration", 'Int'>
    readonly totalFee: FieldRef<"TournamentRegistration", 'Int'>
    readonly status: FieldRef<"TournamentRegistration", 'BookingStatus'>
    readonly createdAt: FieldRef<"TournamentRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"TournamentRegistration", 'DateTime'>
    readonly paymentLockedUntil: FieldRef<"TournamentRegistration", 'DateTime'>
    readonly cancelledAt: FieldRef<"TournamentRegistration", 'DateTime'>
    readonly cancellationReason: FieldRef<"TournamentRegistration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TournamentRegistration findUnique
   */
  export type TournamentRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistration to fetch.
     */
    where: TournamentRegistrationWhereUniqueInput
  }

  /**
   * TournamentRegistration findUniqueOrThrow
   */
  export type TournamentRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistration to fetch.
     */
    where: TournamentRegistrationWhereUniqueInput
  }

  /**
   * TournamentRegistration findFirst
   */
  export type TournamentRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistration to fetch.
     */
    where?: TournamentRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentRegistrations to fetch.
     */
    orderBy?: TournamentRegistrationOrderByWithRelationInput | TournamentRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentRegistrations.
     */
    cursor?: TournamentRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentRegistrations.
     */
    distinct?: TournamentRegistrationScalarFieldEnum | TournamentRegistrationScalarFieldEnum[]
  }

  /**
   * TournamentRegistration findFirstOrThrow
   */
  export type TournamentRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistration to fetch.
     */
    where?: TournamentRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentRegistrations to fetch.
     */
    orderBy?: TournamentRegistrationOrderByWithRelationInput | TournamentRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentRegistrations.
     */
    cursor?: TournamentRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentRegistrations.
     */
    distinct?: TournamentRegistrationScalarFieldEnum | TournamentRegistrationScalarFieldEnum[]
  }

  /**
   * TournamentRegistration findMany
   */
  export type TournamentRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistrations to fetch.
     */
    where?: TournamentRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentRegistrations to fetch.
     */
    orderBy?: TournamentRegistrationOrderByWithRelationInput | TournamentRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentRegistrations.
     */
    cursor?: TournamentRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentRegistrations.
     */
    skip?: number
    distinct?: TournamentRegistrationScalarFieldEnum | TournamentRegistrationScalarFieldEnum[]
  }

  /**
   * TournamentRegistration create
   */
  export type TournamentRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a TournamentRegistration.
     */
    data: XOR<TournamentRegistrationCreateInput, TournamentRegistrationUncheckedCreateInput>
  }

  /**
   * TournamentRegistration createMany
   */
  export type TournamentRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TournamentRegistrations.
     */
    data: TournamentRegistrationCreateManyInput | TournamentRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TournamentRegistration createManyAndReturn
   */
  export type TournamentRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * The data used to create many TournamentRegistrations.
     */
    data: TournamentRegistrationCreateManyInput | TournamentRegistrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentRegistration update
   */
  export type TournamentRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a TournamentRegistration.
     */
    data: XOR<TournamentRegistrationUpdateInput, TournamentRegistrationUncheckedUpdateInput>
    /**
     * Choose, which TournamentRegistration to update.
     */
    where: TournamentRegistrationWhereUniqueInput
  }

  /**
   * TournamentRegistration updateMany
   */
  export type TournamentRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TournamentRegistrations.
     */
    data: XOR<TournamentRegistrationUpdateManyMutationInput, TournamentRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which TournamentRegistrations to update
     */
    where?: TournamentRegistrationWhereInput
    /**
     * Limit how many TournamentRegistrations to update.
     */
    limit?: number
  }

  /**
   * TournamentRegistration updateManyAndReturn
   */
  export type TournamentRegistrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * The data used to update TournamentRegistrations.
     */
    data: XOR<TournamentRegistrationUpdateManyMutationInput, TournamentRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which TournamentRegistrations to update
     */
    where?: TournamentRegistrationWhereInput
    /**
     * Limit how many TournamentRegistrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentRegistration upsert
   */
  export type TournamentRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the TournamentRegistration to update in case it exists.
     */
    where: TournamentRegistrationWhereUniqueInput
    /**
     * In case the TournamentRegistration found by the `where` argument doesn't exist, create a new TournamentRegistration with this data.
     */
    create: XOR<TournamentRegistrationCreateInput, TournamentRegistrationUncheckedCreateInput>
    /**
     * In case the TournamentRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentRegistrationUpdateInput, TournamentRegistrationUncheckedUpdateInput>
  }

  /**
   * TournamentRegistration delete
   */
  export type TournamentRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
    /**
     * Filter which TournamentRegistration to delete.
     */
    where: TournamentRegistrationWhereUniqueInput
  }

  /**
   * TournamentRegistration deleteMany
   */
  export type TournamentRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentRegistrations to delete
     */
    where?: TournamentRegistrationWhereInput
    /**
     * Limit how many TournamentRegistrations to delete.
     */
    limit?: number
  }

  /**
   * TournamentRegistration.membersRef
   */
  export type TournamentRegistration$membersRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    where?: TournamentRegistrationMemberWhereInput
    orderBy?: TournamentRegistrationMemberOrderByWithRelationInput | TournamentRegistrationMemberOrderByWithRelationInput[]
    cursor?: TournamentRegistrationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentRegistrationMemberScalarFieldEnum | TournamentRegistrationMemberScalarFieldEnum[]
  }

  /**
   * TournamentRegistration.invoice
   */
  export type TournamentRegistration$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * TournamentRegistration without action
   */
  export type TournamentRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistration
     */
    select?: TournamentRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistration
     */
    omit?: TournamentRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model TournamentRegistrationMember
   */

  export type AggregateTournamentRegistrationMember = {
    _count: TournamentRegistrationMemberCountAggregateOutputType | null
    _min: TournamentRegistrationMemberMinAggregateOutputType | null
    _max: TournamentRegistrationMemberMaxAggregateOutputType | null
  }

  export type TournamentRegistrationMemberMinAggregateOutputType = {
    id: string | null
    tournamentRegistrationId: string | null
    userId: string | null
    isHost: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TournamentRegistrationMemberMaxAggregateOutputType = {
    id: string | null
    tournamentRegistrationId: string | null
    userId: string | null
    isHost: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TournamentRegistrationMemberCountAggregateOutputType = {
    id: number
    tournamentRegistrationId: number
    userId: number
    isHost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TournamentRegistrationMemberMinAggregateInputType = {
    id?: true
    tournamentRegistrationId?: true
    userId?: true
    isHost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TournamentRegistrationMemberMaxAggregateInputType = {
    id?: true
    tournamentRegistrationId?: true
    userId?: true
    isHost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TournamentRegistrationMemberCountAggregateInputType = {
    id?: true
    tournamentRegistrationId?: true
    userId?: true
    isHost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TournamentRegistrationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentRegistrationMember to aggregate.
     */
    where?: TournamentRegistrationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentRegistrationMembers to fetch.
     */
    orderBy?: TournamentRegistrationMemberOrderByWithRelationInput | TournamentRegistrationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentRegistrationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentRegistrationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentRegistrationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentRegistrationMembers
    **/
    _count?: true | TournamentRegistrationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentRegistrationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentRegistrationMemberMaxAggregateInputType
  }

  export type GetTournamentRegistrationMemberAggregateType<T extends TournamentRegistrationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamentRegistrationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentRegistrationMember[P]>
      : GetScalarType<T[P], AggregateTournamentRegistrationMember[P]>
  }




  export type TournamentRegistrationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentRegistrationMemberWhereInput
    orderBy?: TournamentRegistrationMemberOrderByWithAggregationInput | TournamentRegistrationMemberOrderByWithAggregationInput[]
    by: TournamentRegistrationMemberScalarFieldEnum[] | TournamentRegistrationMemberScalarFieldEnum
    having?: TournamentRegistrationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentRegistrationMemberCountAggregateInputType | true
    _min?: TournamentRegistrationMemberMinAggregateInputType
    _max?: TournamentRegistrationMemberMaxAggregateInputType
  }

  export type TournamentRegistrationMemberGroupByOutputType = {
    id: string
    tournamentRegistrationId: string
    userId: string
    isHost: boolean
    createdAt: Date
    updatedAt: Date
    _count: TournamentRegistrationMemberCountAggregateOutputType | null
    _min: TournamentRegistrationMemberMinAggregateOutputType | null
    _max: TournamentRegistrationMemberMaxAggregateOutputType | null
  }

  type GetTournamentRegistrationMemberGroupByPayload<T extends TournamentRegistrationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentRegistrationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentRegistrationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentRegistrationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentRegistrationMemberGroupByOutputType[P]>
        }
      >
    >


  export type TournamentRegistrationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentRegistrationId?: boolean
    userId?: boolean
    isHost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tournamentRegistration?: boolean | TournamentRegistrationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentRegistrationMember"]>

  export type TournamentRegistrationMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentRegistrationId?: boolean
    userId?: boolean
    isHost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tournamentRegistration?: boolean | TournamentRegistrationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentRegistrationMember"]>

  export type TournamentRegistrationMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentRegistrationId?: boolean
    userId?: boolean
    isHost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tournamentRegistration?: boolean | TournamentRegistrationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentRegistrationMember"]>

  export type TournamentRegistrationMemberSelectScalar = {
    id?: boolean
    tournamentRegistrationId?: boolean
    userId?: boolean
    isHost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TournamentRegistrationMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tournamentRegistrationId" | "userId" | "isHost" | "createdAt" | "updatedAt", ExtArgs["result"]["tournamentRegistrationMember"]>
  export type TournamentRegistrationMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournamentRegistration?: boolean | TournamentRegistrationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TournamentRegistrationMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournamentRegistration?: boolean | TournamentRegistrationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TournamentRegistrationMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournamentRegistration?: boolean | TournamentRegistrationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TournamentRegistrationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TournamentRegistrationMember"
    objects: {
      tournamentRegistration: Prisma.$TournamentRegistrationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tournamentRegistrationId: string
      userId: string
      isHost: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tournamentRegistrationMember"]>
    composites: {}
  }

  type TournamentRegistrationMemberGetPayload<S extends boolean | null | undefined | TournamentRegistrationMemberDefaultArgs> = $Result.GetResult<Prisma.$TournamentRegistrationMemberPayload, S>

  type TournamentRegistrationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TournamentRegistrationMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentRegistrationMemberCountAggregateInputType | true
    }

  export interface TournamentRegistrationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TournamentRegistrationMember'], meta: { name: 'TournamentRegistrationMember' } }
    /**
     * Find zero or one TournamentRegistrationMember that matches the filter.
     * @param {TournamentRegistrationMemberFindUniqueArgs} args - Arguments to find a TournamentRegistrationMember
     * @example
     * // Get one TournamentRegistrationMember
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentRegistrationMemberFindUniqueArgs>(args: SelectSubset<T, TournamentRegistrationMemberFindUniqueArgs<ExtArgs>>): Prisma__TournamentRegistrationMemberClient<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TournamentRegistrationMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TournamentRegistrationMemberFindUniqueOrThrowArgs} args - Arguments to find a TournamentRegistrationMember
     * @example
     * // Get one TournamentRegistrationMember
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentRegistrationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentRegistrationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentRegistrationMemberClient<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentRegistrationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationMemberFindFirstArgs} args - Arguments to find a TournamentRegistrationMember
     * @example
     * // Get one TournamentRegistrationMember
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentRegistrationMemberFindFirstArgs>(args?: SelectSubset<T, TournamentRegistrationMemberFindFirstArgs<ExtArgs>>): Prisma__TournamentRegistrationMemberClient<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentRegistrationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationMemberFindFirstOrThrowArgs} args - Arguments to find a TournamentRegistrationMember
     * @example
     * // Get one TournamentRegistrationMember
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentRegistrationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentRegistrationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentRegistrationMemberClient<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TournamentRegistrationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentRegistrationMembers
     * const tournamentRegistrationMembers = await prisma.tournamentRegistrationMember.findMany()
     * 
     * // Get first 10 TournamentRegistrationMembers
     * const tournamentRegistrationMembers = await prisma.tournamentRegistrationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentRegistrationMemberWithIdOnly = await prisma.tournamentRegistrationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TournamentRegistrationMemberFindManyArgs>(args?: SelectSubset<T, TournamentRegistrationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TournamentRegistrationMember.
     * @param {TournamentRegistrationMemberCreateArgs} args - Arguments to create a TournamentRegistrationMember.
     * @example
     * // Create one TournamentRegistrationMember
     * const TournamentRegistrationMember = await prisma.tournamentRegistrationMember.create({
     *   data: {
     *     // ... data to create a TournamentRegistrationMember
     *   }
     * })
     * 
     */
    create<T extends TournamentRegistrationMemberCreateArgs>(args: SelectSubset<T, TournamentRegistrationMemberCreateArgs<ExtArgs>>): Prisma__TournamentRegistrationMemberClient<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TournamentRegistrationMembers.
     * @param {TournamentRegistrationMemberCreateManyArgs} args - Arguments to create many TournamentRegistrationMembers.
     * @example
     * // Create many TournamentRegistrationMembers
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentRegistrationMemberCreateManyArgs>(args?: SelectSubset<T, TournamentRegistrationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TournamentRegistrationMembers and returns the data saved in the database.
     * @param {TournamentRegistrationMemberCreateManyAndReturnArgs} args - Arguments to create many TournamentRegistrationMembers.
     * @example
     * // Create many TournamentRegistrationMembers
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TournamentRegistrationMembers and only return the `id`
     * const tournamentRegistrationMemberWithIdOnly = await prisma.tournamentRegistrationMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentRegistrationMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentRegistrationMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TournamentRegistrationMember.
     * @param {TournamentRegistrationMemberDeleteArgs} args - Arguments to delete one TournamentRegistrationMember.
     * @example
     * // Delete one TournamentRegistrationMember
     * const TournamentRegistrationMember = await prisma.tournamentRegistrationMember.delete({
     *   where: {
     *     // ... filter to delete one TournamentRegistrationMember
     *   }
     * })
     * 
     */
    delete<T extends TournamentRegistrationMemberDeleteArgs>(args: SelectSubset<T, TournamentRegistrationMemberDeleteArgs<ExtArgs>>): Prisma__TournamentRegistrationMemberClient<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TournamentRegistrationMember.
     * @param {TournamentRegistrationMemberUpdateArgs} args - Arguments to update one TournamentRegistrationMember.
     * @example
     * // Update one TournamentRegistrationMember
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentRegistrationMemberUpdateArgs>(args: SelectSubset<T, TournamentRegistrationMemberUpdateArgs<ExtArgs>>): Prisma__TournamentRegistrationMemberClient<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TournamentRegistrationMembers.
     * @param {TournamentRegistrationMemberDeleteManyArgs} args - Arguments to filter TournamentRegistrationMembers to delete.
     * @example
     * // Delete a few TournamentRegistrationMembers
     * const { count } = await prisma.tournamentRegistrationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentRegistrationMemberDeleteManyArgs>(args?: SelectSubset<T, TournamentRegistrationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentRegistrationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentRegistrationMembers
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentRegistrationMemberUpdateManyArgs>(args: SelectSubset<T, TournamentRegistrationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentRegistrationMembers and returns the data updated in the database.
     * @param {TournamentRegistrationMemberUpdateManyAndReturnArgs} args - Arguments to update many TournamentRegistrationMembers.
     * @example
     * // Update many TournamentRegistrationMembers
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TournamentRegistrationMembers and only return the `id`
     * const tournamentRegistrationMemberWithIdOnly = await prisma.tournamentRegistrationMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TournamentRegistrationMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TournamentRegistrationMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TournamentRegistrationMember.
     * @param {TournamentRegistrationMemberUpsertArgs} args - Arguments to update or create a TournamentRegistrationMember.
     * @example
     * // Update or create a TournamentRegistrationMember
     * const tournamentRegistrationMember = await prisma.tournamentRegistrationMember.upsert({
     *   create: {
     *     // ... data to create a TournamentRegistrationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentRegistrationMember we want to update
     *   }
     * })
     */
    upsert<T extends TournamentRegistrationMemberUpsertArgs>(args: SelectSubset<T, TournamentRegistrationMemberUpsertArgs<ExtArgs>>): Prisma__TournamentRegistrationMemberClient<$Result.GetResult<Prisma.$TournamentRegistrationMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TournamentRegistrationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationMemberCountArgs} args - Arguments to filter TournamentRegistrationMembers to count.
     * @example
     * // Count the number of TournamentRegistrationMembers
     * const count = await prisma.tournamentRegistrationMember.count({
     *   where: {
     *     // ... the filter for the TournamentRegistrationMembers we want to count
     *   }
     * })
    **/
    count<T extends TournamentRegistrationMemberCountArgs>(
      args?: Subset<T, TournamentRegistrationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentRegistrationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentRegistrationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentRegistrationMemberAggregateArgs>(args: Subset<T, TournamentRegistrationMemberAggregateArgs>): Prisma.PrismaPromise<GetTournamentRegistrationMemberAggregateType<T>>

    /**
     * Group by TournamentRegistrationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentRegistrationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentRegistrationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentRegistrationMemberGroupByArgs['orderBy'] }
        : { orderBy?: TournamentRegistrationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentRegistrationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentRegistrationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TournamentRegistrationMember model
   */
  readonly fields: TournamentRegistrationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentRegistrationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentRegistrationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournamentRegistration<T extends TournamentRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentRegistrationDefaultArgs<ExtArgs>>): Prisma__TournamentRegistrationClient<$Result.GetResult<Prisma.$TournamentRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TournamentRegistrationMember model
   */
  interface TournamentRegistrationMemberFieldRefs {
    readonly id: FieldRef<"TournamentRegistrationMember", 'String'>
    readonly tournamentRegistrationId: FieldRef<"TournamentRegistrationMember", 'String'>
    readonly userId: FieldRef<"TournamentRegistrationMember", 'String'>
    readonly isHost: FieldRef<"TournamentRegistrationMember", 'Boolean'>
    readonly createdAt: FieldRef<"TournamentRegistrationMember", 'DateTime'>
    readonly updatedAt: FieldRef<"TournamentRegistrationMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TournamentRegistrationMember findUnique
   */
  export type TournamentRegistrationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistrationMember to fetch.
     */
    where: TournamentRegistrationMemberWhereUniqueInput
  }

  /**
   * TournamentRegistrationMember findUniqueOrThrow
   */
  export type TournamentRegistrationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistrationMember to fetch.
     */
    where: TournamentRegistrationMemberWhereUniqueInput
  }

  /**
   * TournamentRegistrationMember findFirst
   */
  export type TournamentRegistrationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistrationMember to fetch.
     */
    where?: TournamentRegistrationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentRegistrationMembers to fetch.
     */
    orderBy?: TournamentRegistrationMemberOrderByWithRelationInput | TournamentRegistrationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentRegistrationMembers.
     */
    cursor?: TournamentRegistrationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentRegistrationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentRegistrationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentRegistrationMembers.
     */
    distinct?: TournamentRegistrationMemberScalarFieldEnum | TournamentRegistrationMemberScalarFieldEnum[]
  }

  /**
   * TournamentRegistrationMember findFirstOrThrow
   */
  export type TournamentRegistrationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistrationMember to fetch.
     */
    where?: TournamentRegistrationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentRegistrationMembers to fetch.
     */
    orderBy?: TournamentRegistrationMemberOrderByWithRelationInput | TournamentRegistrationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentRegistrationMembers.
     */
    cursor?: TournamentRegistrationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentRegistrationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentRegistrationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentRegistrationMembers.
     */
    distinct?: TournamentRegistrationMemberScalarFieldEnum | TournamentRegistrationMemberScalarFieldEnum[]
  }

  /**
   * TournamentRegistrationMember findMany
   */
  export type TournamentRegistrationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    /**
     * Filter, which TournamentRegistrationMembers to fetch.
     */
    where?: TournamentRegistrationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentRegistrationMembers to fetch.
     */
    orderBy?: TournamentRegistrationMemberOrderByWithRelationInput | TournamentRegistrationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentRegistrationMembers.
     */
    cursor?: TournamentRegistrationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentRegistrationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentRegistrationMembers.
     */
    skip?: number
    distinct?: TournamentRegistrationMemberScalarFieldEnum | TournamentRegistrationMemberScalarFieldEnum[]
  }

  /**
   * TournamentRegistrationMember create
   */
  export type TournamentRegistrationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TournamentRegistrationMember.
     */
    data: XOR<TournamentRegistrationMemberCreateInput, TournamentRegistrationMemberUncheckedCreateInput>
  }

  /**
   * TournamentRegistrationMember createMany
   */
  export type TournamentRegistrationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TournamentRegistrationMembers.
     */
    data: TournamentRegistrationMemberCreateManyInput | TournamentRegistrationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TournamentRegistrationMember createManyAndReturn
   */
  export type TournamentRegistrationMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TournamentRegistrationMembers.
     */
    data: TournamentRegistrationMemberCreateManyInput | TournamentRegistrationMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentRegistrationMember update
   */
  export type TournamentRegistrationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TournamentRegistrationMember.
     */
    data: XOR<TournamentRegistrationMemberUpdateInput, TournamentRegistrationMemberUncheckedUpdateInput>
    /**
     * Choose, which TournamentRegistrationMember to update.
     */
    where: TournamentRegistrationMemberWhereUniqueInput
  }

  /**
   * TournamentRegistrationMember updateMany
   */
  export type TournamentRegistrationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TournamentRegistrationMembers.
     */
    data: XOR<TournamentRegistrationMemberUpdateManyMutationInput, TournamentRegistrationMemberUncheckedUpdateManyInput>
    /**
     * Filter which TournamentRegistrationMembers to update
     */
    where?: TournamentRegistrationMemberWhereInput
    /**
     * Limit how many TournamentRegistrationMembers to update.
     */
    limit?: number
  }

  /**
   * TournamentRegistrationMember updateManyAndReturn
   */
  export type TournamentRegistrationMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * The data used to update TournamentRegistrationMembers.
     */
    data: XOR<TournamentRegistrationMemberUpdateManyMutationInput, TournamentRegistrationMemberUncheckedUpdateManyInput>
    /**
     * Filter which TournamentRegistrationMembers to update
     */
    where?: TournamentRegistrationMemberWhereInput
    /**
     * Limit how many TournamentRegistrationMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentRegistrationMember upsert
   */
  export type TournamentRegistrationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TournamentRegistrationMember to update in case it exists.
     */
    where: TournamentRegistrationMemberWhereUniqueInput
    /**
     * In case the TournamentRegistrationMember found by the `where` argument doesn't exist, create a new TournamentRegistrationMember with this data.
     */
    create: XOR<TournamentRegistrationMemberCreateInput, TournamentRegistrationMemberUncheckedCreateInput>
    /**
     * In case the TournamentRegistrationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentRegistrationMemberUpdateInput, TournamentRegistrationMemberUncheckedUpdateInput>
  }

  /**
   * TournamentRegistrationMember delete
   */
  export type TournamentRegistrationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
    /**
     * Filter which TournamentRegistrationMember to delete.
     */
    where: TournamentRegistrationMemberWhereUniqueInput
  }

  /**
   * TournamentRegistrationMember deleteMany
   */
  export type TournamentRegistrationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentRegistrationMembers to delete
     */
    where?: TournamentRegistrationMemberWhereInput
    /**
     * Limit how many TournamentRegistrationMembers to delete.
     */
    limit?: number
  }

  /**
   * TournamentRegistrationMember without action
   */
  export type TournamentRegistrationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentRegistrationMember
     */
    select?: TournamentRegistrationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentRegistrationMember
     */
    omit?: TournamentRegistrationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentRegistrationMemberInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    password: 'password',
    image: 'image',
    googleId: 'googleId',
    phone: 'phone',
    phoneVerified: 'phoneVerified',
    banned: 'banned',
    banReason: 'banReason',
    banExpires: 'banExpires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PhoneVerificationScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    type: 'type',
    code: 'code',
    expiresAt: 'expiresAt',
    requestId: 'requestId',
    isUsed: 'isUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhoneVerificationScalarFieldEnum = (typeof PhoneVerificationScalarFieldEnum)[keyof typeof PhoneVerificationScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    image: 'image',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    isActive: 'isActive',
    joinedAt: 'joinedAt',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const AuthTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    staffId: 'staffId',
    type: 'type',
    refreshToken: 'refreshToken',
    refreshExpiresAt: 'refreshExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthTokenScalarFieldEnum = (typeof AuthTokenScalarFieldEnum)[keyof typeof AuthTokenScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    image: 'image',
    link: 'link',
    isActive: 'isActive',
    startAt: 'startAt',
    endAt: 'endAt',
    sequence: 'sequence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const CourtScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourtScalarFieldEnum = (typeof CourtScalarFieldEnum)[keyof typeof CourtScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const SlotScalarFieldEnum: {
    id: 'id',
    type: 'type',
    courtId: 'courtId',
    staffId: 'staffId',
    startAt: 'startAt',
    endAt: 'endAt',
    price: 'price',
    isAvailable: 'isAvailable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SlotScalarFieldEnum = (typeof SlotScalarFieldEnum)[keyof typeof SlotScalarFieldEnum]


  export const CourtCostScheduleScalarFieldEnum: {
    id: 'id',
    courtId: 'courtId',
    startAt: 'startAt',
    endAt: 'endAt',
    price: 'price',
    isAvailable: 'isAvailable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourtCostScheduleScalarFieldEnum = (typeof CourtCostScheduleScalarFieldEnum)[keyof typeof CourtCostScheduleScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    fees: 'fees',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    paymentMethodId: 'paymentMethodId',
    status: 'status',
    amount: 'amount',
    fees: 'fees',
    externalRef: 'externalRef',
    meta: 'meta',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    cancelledAt: 'cancelledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    classBookingId: 'classBookingId',
    membershipUserId: 'membershipUserId',
    tournamentRegistrationId: 'tournamentRegistrationId',
    number: 'number',
    userId: 'userId',
    paymentId: 'paymentId',
    subtotal: 'subtotal',
    processingFee: 'processingFee',
    total: 'total',
    status: 'status',
    issuedAt: 'issuedAt',
    dueDate: 'dueDate',
    paidAt: 'paidAt',
    cancelledAt: 'cancelledAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    totalPrice: 'totalPrice',
    processingFee: 'processingFee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    holdExpiresAt: 'holdExpiresAt',
    cancelledAt: 'cancelledAt',
    cancellationReason: 'cancellationReason'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const BookingDetailScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    slotId: 'slotId',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    courtId: 'courtId'
  };

  export type BookingDetailScalarFieldEnum = (typeof BookingDetailScalarFieldEnum)[keyof typeof BookingDetailScalarFieldEnum]


  export const BookingInventoryScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    inventoryId: 'inventoryId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingInventoryScalarFieldEnum = (typeof BookingInventoryScalarFieldEnum)[keyof typeof BookingInventoryScalarFieldEnum]


  export const BookingBallboyScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    slotId: 'slotId',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingBallboyScalarFieldEnum = (typeof BookingBallboyScalarFieldEnum)[keyof typeof BookingBallboyScalarFieldEnum]


  export const BookingCoachTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingCoachTypeScalarFieldEnum = (typeof BookingCoachTypeScalarFieldEnum)[keyof typeof BookingCoachTypeScalarFieldEnum]


  export const CoachTypeStaffPriceScalarFieldEnum: {
    id: 'id',
    staffId: 'staffId',
    coachTypeId: 'coachTypeId',
    basePrice: 'basePrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoachTypeStaffPriceScalarFieldEnum = (typeof CoachTypeStaffPriceScalarFieldEnum)[keyof typeof CoachTypeStaffPriceScalarFieldEnum]


  export const BookingCoachScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    slotId: 'slotId',
    bookingCoachTypeId: 'bookingCoachTypeId',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingCoachScalarFieldEnum = (typeof BookingCoachScalarFieldEnum)[keyof typeof BookingCoachScalarFieldEnum]


  export const MembershipScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    content: 'content',
    price: 'price',
    sessions: 'sessions',
    duration: 'duration',
    sequence: 'sequence',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipScalarFieldEnum = (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum]


  export const MembershipBenefitScalarFieldEnum: {
    id: 'id',
    membershipId: 'membershipId',
    benefit: 'benefit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipBenefitScalarFieldEnum = (typeof MembershipBenefitScalarFieldEnum)[keyof typeof MembershipBenefitScalarFieldEnum]


  export const MembershipUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    membershipId: 'membershipId',
    startDate: 'startDate',
    endDate: 'endDate',
    remainingSessions: 'remainingSessions',
    remainingDuration: 'remainingDuration',
    isExpired: 'isExpired',
    isSuspended: 'isSuspended',
    suspensionReason: 'suspensionReason',
    suspensionEndDate: 'suspensionEndDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipUserScalarFieldEnum = (typeof MembershipUserScalarFieldEnum)[keyof typeof MembershipUserScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    content: 'content',
    organizerName: 'organizerName',
    speakerName: 'speakerName',
    image: 'image',
    startDate: 'startDate',
    endDate: 'endDate',
    startTime: 'startTime',
    endTime: 'endTime',
    price: 'price',
    sessions: 'sessions',
    capacity: 'capacity',
    remaining: 'remaining',
    maxBookingPax: 'maxBookingPax',
    gender: 'gender',
    ageMin: 'ageMin',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const ClassBookingScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    userId: 'userId',
    status: 'status',
    totalPrice: 'totalPrice',
    processingFee: 'processingFee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cancelledAt: 'cancelledAt',
    cancellationReason: 'cancellationReason'
  };

  export type ClassBookingScalarFieldEnum = (typeof ClassBookingScalarFieldEnum)[keyof typeof ClassBookingScalarFieldEnum]


  export const ClassBookingDetailScalarFieldEnum: {
    id: 'id',
    classBookingId: 'classBookingId',
    date: 'date',
    time: 'time',
    price: 'price',
    attendance: 'attendance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassBookingDetailScalarFieldEnum = (typeof ClassBookingDetailScalarFieldEnum)[keyof typeof ClassBookingDetailScalarFieldEnum]


  export const ClubScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo',
    description: 'description',
    rules: 'rules',
    leaderId: 'leaderId',
    visibility: 'visibility',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClubScalarFieldEnum = (typeof ClubScalarFieldEnum)[keyof typeof ClubScalarFieldEnum]


  export const ClubMemberScalarFieldEnum: {
    id: 'id',
    clubId: 'clubId',
    userId: 'userId',
    joinedAt: 'joinedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClubMemberScalarFieldEnum = (typeof ClubMemberScalarFieldEnum)[keyof typeof ClubMemberScalarFieldEnum]


  export const TournamentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    rules: 'rules',
    image: 'image',
    startDate: 'startDate',
    endDate: 'endDate',
    startTime: 'startTime',
    endTime: 'endTime',
    maxTeams: 'maxTeams',
    teamSize: 'teamSize',
    entryFee: 'entryFee',
    location: 'location',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TournamentScalarFieldEnum = (typeof TournamentScalarFieldEnum)[keyof typeof TournamentScalarFieldEnum]


  export const TournamentRegistrationScalarFieldEnum: {
    id: 'id',
    tournamentId: 'tournamentId',
    clubId: 'clubId',
    members: 'members',
    totalFee: 'totalFee',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paymentLockedUntil: 'paymentLockedUntil',
    cancelledAt: 'cancelledAt',
    cancellationReason: 'cancellationReason'
  };

  export type TournamentRegistrationScalarFieldEnum = (typeof TournamentRegistrationScalarFieldEnum)[keyof typeof TournamentRegistrationScalarFieldEnum]


  export const TournamentRegistrationMemberScalarFieldEnum: {
    id: 'id',
    tournamentRegistrationId: 'tournamentRegistrationId',
    userId: 'userId',
    isHost: 'isHost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TournamentRegistrationMemberScalarFieldEnum = (typeof TournamentRegistrationMemberScalarFieldEnum)[keyof typeof TournamentRegistrationMemberScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PhoneVerificationType'
   */
  export type EnumPhoneVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhoneVerificationType'>
    


  /**
   * Reference to a field of type 'PhoneVerificationType[]'
   */
  export type ListEnumPhoneVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhoneVerificationType[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'AuthTokenType'
   */
  export type EnumAuthTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthTokenType'>
    


  /**
   * Reference to a field of type 'AuthTokenType[]'
   */
  export type ListEnumAuthTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthTokenType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'SlotType'
   */
  export type EnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType'>
    


  /**
   * Reference to a field of type 'SlotType[]'
   */
  export type ListEnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'ClubVisibility'
   */
  export type EnumClubVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClubVisibility'>
    


  /**
   * Reference to a field of type 'ClubVisibility[]'
   */
  export type ListEnumClubVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClubVisibility[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    phone?: StringFilter<"User"> | string
    phoneVerified?: BoolFilter<"User"> | boolean
    banned?: BoolFilter<"User"> | boolean
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    authTokens?: AuthTokenListRelationFilter
    bookings?: BookingListRelationFilter
    membershipUser?: MembershipUserListRelationFilter
    classBookings?: ClassBookingListRelationFilter
    clubsLed?: ClubListRelationFilter
    clubMember?: ClubMemberListRelationFilter
    tournamentRegistrationMember?: TournamentRegistrationMemberListRelationFilter
    invoice?: InvoiceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    banned?: SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authTokens?: AuthTokenOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    membershipUser?: MembershipUserOrderByRelationAggregateInput
    classBookings?: ClassBookingOrderByRelationAggregateInput
    clubsLed?: ClubOrderByRelationAggregateInput
    clubMember?: ClubMemberOrderByRelationAggregateInput
    tournamentRegistrationMember?: TournamentRegistrationMemberOrderByRelationAggregateInput
    invoice?: InvoiceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    googleId?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    phoneVerified?: BoolFilter<"User"> | boolean
    banned?: BoolFilter<"User"> | boolean
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    authTokens?: AuthTokenListRelationFilter
    bookings?: BookingListRelationFilter
    membershipUser?: MembershipUserListRelationFilter
    classBookings?: ClassBookingListRelationFilter
    clubsLed?: ClubListRelationFilter
    clubMember?: ClubMemberListRelationFilter
    tournamentRegistrationMember?: TournamentRegistrationMemberListRelationFilter
    invoice?: InvoiceListRelationFilter
  }, "id" | "email" | "googleId" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    banned?: SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringWithAggregatesFilter<"User"> | string
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    banned?: BoolWithAggregatesFilter<"User"> | boolean
    banReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    banExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PhoneVerificationWhereInput = {
    AND?: PhoneVerificationWhereInput | PhoneVerificationWhereInput[]
    OR?: PhoneVerificationWhereInput[]
    NOT?: PhoneVerificationWhereInput | PhoneVerificationWhereInput[]
    id?: StringFilter<"PhoneVerification"> | string
    phone?: StringFilter<"PhoneVerification"> | string
    type?: EnumPhoneVerificationTypeNullableFilter<"PhoneVerification"> | $Enums.PhoneVerificationType | null
    code?: StringFilter<"PhoneVerification"> | string
    expiresAt?: DateTimeFilter<"PhoneVerification"> | Date | string
    requestId?: StringFilter<"PhoneVerification"> | string
    isUsed?: BoolFilter<"PhoneVerification"> | boolean
    createdAt?: DateTimeFilter<"PhoneVerification"> | Date | string
    updatedAt?: DateTimeFilter<"PhoneVerification"> | Date | string
  }

  export type PhoneVerificationOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    type?: SortOrderInput | SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    requestId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhoneVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    AND?: PhoneVerificationWhereInput | PhoneVerificationWhereInput[]
    OR?: PhoneVerificationWhereInput[]
    NOT?: PhoneVerificationWhereInput | PhoneVerificationWhereInput[]
    type?: EnumPhoneVerificationTypeNullableFilter<"PhoneVerification"> | $Enums.PhoneVerificationType | null
    code?: StringFilter<"PhoneVerification"> | string
    expiresAt?: DateTimeFilter<"PhoneVerification"> | Date | string
    requestId?: StringFilter<"PhoneVerification"> | string
    isUsed?: BoolFilter<"PhoneVerification"> | boolean
    createdAt?: DateTimeFilter<"PhoneVerification"> | Date | string
    updatedAt?: DateTimeFilter<"PhoneVerification"> | Date | string
  }, "id" | "phone">

  export type PhoneVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    type?: SortOrderInput | SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    requestId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhoneVerificationCountOrderByAggregateInput
    _max?: PhoneVerificationMaxOrderByAggregateInput
    _min?: PhoneVerificationMinOrderByAggregateInput
  }

  export type PhoneVerificationScalarWhereWithAggregatesInput = {
    AND?: PhoneVerificationScalarWhereWithAggregatesInput | PhoneVerificationScalarWhereWithAggregatesInput[]
    OR?: PhoneVerificationScalarWhereWithAggregatesInput[]
    NOT?: PhoneVerificationScalarWhereWithAggregatesInput | PhoneVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhoneVerification"> | string
    phone?: StringWithAggregatesFilter<"PhoneVerification"> | string
    type?: EnumPhoneVerificationTypeNullableWithAggregatesFilter<"PhoneVerification"> | $Enums.PhoneVerificationType | null
    code?: StringWithAggregatesFilter<"PhoneVerification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PhoneVerification"> | Date | string
    requestId?: StringWithAggregatesFilter<"PhoneVerification"> | string
    isUsed?: BoolWithAggregatesFilter<"PhoneVerification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PhoneVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PhoneVerification"> | Date | string
  }

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: StringFilter<"Staff"> | string
    image?: StringNullableFilter<"Staff"> | string | null
    name?: StringFilter<"Staff"> | string
    email?: StringFilter<"Staff"> | string
    phone?: StringNullableFilter<"Staff"> | string | null
    password?: StringFilter<"Staff"> | string
    isActive?: BoolFilter<"Staff"> | boolean
    joinedAt?: DateTimeFilter<"Staff"> | Date | string
    role?: EnumRoleFilter<"Staff"> | $Enums.Role
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    authTokens?: AuthTokenListRelationFilter
    slot?: SlotListRelationFilter
    coachTypeStaffPrice?: CoachTypeStaffPriceListRelationFilter
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authTokens?: AuthTokenOrderByRelationAggregateInput
    slot?: SlotOrderByRelationAggregateInput
    coachTypeStaffPrice?: CoachTypeStaffPriceOrderByRelationAggregateInput
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    image?: StringNullableFilter<"Staff"> | string | null
    name?: StringFilter<"Staff"> | string
    password?: StringFilter<"Staff"> | string
    isActive?: BoolFilter<"Staff"> | boolean
    joinedAt?: DateTimeFilter<"Staff"> | Date | string
    role?: EnumRoleFilter<"Staff"> | $Enums.Role
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    authTokens?: AuthTokenListRelationFilter
    slot?: SlotListRelationFilter
    coachTypeStaffPrice?: CoachTypeStaffPriceListRelationFilter
  }, "id" | "email" | "phone">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Staff"> | string
    image?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    name?: StringWithAggregatesFilter<"Staff"> | string
    email?: StringWithAggregatesFilter<"Staff"> | string
    phone?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    password?: StringWithAggregatesFilter<"Staff"> | string
    isActive?: BoolWithAggregatesFilter<"Staff"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    role?: EnumRoleWithAggregatesFilter<"Staff"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type AuthTokenWhereInput = {
    AND?: AuthTokenWhereInput | AuthTokenWhereInput[]
    OR?: AuthTokenWhereInput[]
    NOT?: AuthTokenWhereInput | AuthTokenWhereInput[]
    id?: StringFilter<"AuthToken"> | string
    userId?: StringNullableFilter<"AuthToken"> | string | null
    staffId?: StringNullableFilter<"AuthToken"> | string | null
    type?: EnumAuthTokenTypeFilter<"AuthToken"> | $Enums.AuthTokenType
    refreshToken?: StringFilter<"AuthToken"> | string
    refreshExpiresAt?: DateTimeFilter<"AuthToken"> | Date | string
    createdAt?: DateTimeFilter<"AuthToken"> | Date | string
    updatedAt?: DateTimeFilter<"AuthToken"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
  }

  export type AuthTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    type?: SortOrder
    refreshToken?: SortOrder
    refreshExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
  }

  export type AuthTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: AuthTokenWhereInput | AuthTokenWhereInput[]
    OR?: AuthTokenWhereInput[]
    NOT?: AuthTokenWhereInput | AuthTokenWhereInput[]
    userId?: StringNullableFilter<"AuthToken"> | string | null
    staffId?: StringNullableFilter<"AuthToken"> | string | null
    type?: EnumAuthTokenTypeFilter<"AuthToken"> | $Enums.AuthTokenType
    refreshExpiresAt?: DateTimeFilter<"AuthToken"> | Date | string
    createdAt?: DateTimeFilter<"AuthToken"> | Date | string
    updatedAt?: DateTimeFilter<"AuthToken"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
  }, "id" | "refreshToken">

  export type AuthTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    type?: SortOrder
    refreshToken?: SortOrder
    refreshExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthTokenCountOrderByAggregateInput
    _max?: AuthTokenMaxOrderByAggregateInput
    _min?: AuthTokenMinOrderByAggregateInput
  }

  export type AuthTokenScalarWhereWithAggregatesInput = {
    AND?: AuthTokenScalarWhereWithAggregatesInput | AuthTokenScalarWhereWithAggregatesInput[]
    OR?: AuthTokenScalarWhereWithAggregatesInput[]
    NOT?: AuthTokenScalarWhereWithAggregatesInput | AuthTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuthToken"> | string
    userId?: StringNullableWithAggregatesFilter<"AuthToken"> | string | null
    staffId?: StringNullableWithAggregatesFilter<"AuthToken"> | string | null
    type?: EnumAuthTokenTypeWithAggregatesFilter<"AuthToken"> | $Enums.AuthTokenType
    refreshToken?: StringWithAggregatesFilter<"AuthToken"> | string
    refreshExpiresAt?: DateTimeWithAggregatesFilter<"AuthToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AuthToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuthToken"> | Date | string
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: StringFilter<"Banner"> | string
    image?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    isActive?: BoolFilter<"Banner"> | boolean
    startAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    sequence?: IntFilter<"Banner"> | number
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    link?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    image?: StringFilter<"Banner"> | string
    link?: StringNullableFilter<"Banner"> | string | null
    isActive?: BoolFilter<"Banner"> | boolean
    startAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    endAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    sequence?: IntFilter<"Banner"> | number
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    link?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _avg?: BannerAvgOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
    _sum?: BannerSumOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banner"> | string
    image?: StringWithAggregatesFilter<"Banner"> | string
    link?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    isActive?: BoolWithAggregatesFilter<"Banner"> | boolean
    startAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    endAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    sequence?: IntWithAggregatesFilter<"Banner"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
  }

  export type CourtWhereInput = {
    AND?: CourtWhereInput | CourtWhereInput[]
    OR?: CourtWhereInput[]
    NOT?: CourtWhereInput | CourtWhereInput[]
    id?: StringFilter<"Court"> | string
    name?: StringFilter<"Court"> | string
    description?: StringNullableFilter<"Court"> | string | null
    image?: StringNullableFilter<"Court"> | string | null
    isActive?: BoolFilter<"Court"> | boolean
    createdAt?: DateTimeFilter<"Court"> | Date | string
    updatedAt?: DateTimeFilter<"Court"> | Date | string
    costSchedules?: CourtCostScheduleListRelationFilter
    bookingDetail?: BookingDetailListRelationFilter
    slot?: SlotListRelationFilter
  }

  export type CourtOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    costSchedules?: CourtCostScheduleOrderByRelationAggregateInput
    bookingDetail?: BookingDetailOrderByRelationAggregateInput
    slot?: SlotOrderByRelationAggregateInput
  }

  export type CourtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CourtWhereInput | CourtWhereInput[]
    OR?: CourtWhereInput[]
    NOT?: CourtWhereInput | CourtWhereInput[]
    description?: StringNullableFilter<"Court"> | string | null
    image?: StringNullableFilter<"Court"> | string | null
    isActive?: BoolFilter<"Court"> | boolean
    createdAt?: DateTimeFilter<"Court"> | Date | string
    updatedAt?: DateTimeFilter<"Court"> | Date | string
    costSchedules?: CourtCostScheduleListRelationFilter
    bookingDetail?: BookingDetailListRelationFilter
    slot?: SlotListRelationFilter
  }, "id" | "name">

  export type CourtOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourtCountOrderByAggregateInput
    _max?: CourtMaxOrderByAggregateInput
    _min?: CourtMinOrderByAggregateInput
  }

  export type CourtScalarWhereWithAggregatesInput = {
    AND?: CourtScalarWhereWithAggregatesInput | CourtScalarWhereWithAggregatesInput[]
    OR?: CourtScalarWhereWithAggregatesInput[]
    NOT?: CourtScalarWhereWithAggregatesInput | CourtScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Court"> | string
    name?: StringWithAggregatesFilter<"Court"> | string
    description?: StringNullableWithAggregatesFilter<"Court"> | string | null
    image?: StringNullableWithAggregatesFilter<"Court"> | string | null
    isActive?: BoolWithAggregatesFilter<"Court"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Court"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Court"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: StringFilter<"Inventory"> | string
    name?: StringFilter<"Inventory"> | string
    description?: StringNullableFilter<"Inventory"> | string | null
    quantity?: IntFilter<"Inventory"> | number
    isActive?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    bookingInventory?: BookingInventoryListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingInventory?: BookingInventoryOrderByRelationAggregateInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    description?: StringNullableFilter<"Inventory"> | string | null
    quantity?: IntFilter<"Inventory"> | number
    isActive?: BoolFilter<"Inventory"> | boolean
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    bookingInventory?: BookingInventoryListRelationFilter
  }, "id" | "name">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inventory"> | string
    name?: StringWithAggregatesFilter<"Inventory"> | string
    description?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    quantity?: IntWithAggregatesFilter<"Inventory"> | number
    isActive?: BoolWithAggregatesFilter<"Inventory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type SlotWhereInput = {
    AND?: SlotWhereInput | SlotWhereInput[]
    OR?: SlotWhereInput[]
    NOT?: SlotWhereInput | SlotWhereInput[]
    id?: StringFilter<"Slot"> | string
    type?: EnumSlotTypeFilter<"Slot"> | $Enums.SlotType
    courtId?: StringNullableFilter<"Slot"> | string | null
    staffId?: StringNullableFilter<"Slot"> | string | null
    startAt?: DateTimeFilter<"Slot"> | Date | string
    endAt?: DateTimeFilter<"Slot"> | Date | string
    price?: IntFilter<"Slot"> | number
    isAvailable?: BoolFilter<"Slot"> | boolean
    createdAt?: DateTimeFilter<"Slot"> | Date | string
    updatedAt?: DateTimeFilter<"Slot"> | Date | string
    court?: XOR<CourtNullableScalarRelationFilter, CourtWhereInput> | null
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    bookingDetails?: BookingDetailListRelationFilter
    bookingCoaches?: BookingCoachListRelationFilter
    bookingBallboys?: BookingBallboyListRelationFilter
  }

  export type SlotOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    courtId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    court?: CourtOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
    bookingDetails?: BookingDetailOrderByRelationAggregateInput
    bookingCoaches?: BookingCoachOrderByRelationAggregateInput
    bookingBallboys?: BookingBallboyOrderByRelationAggregateInput
  }

  export type SlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courtId_startAt?: SlotCourtIdStartAtCompoundUniqueInput
    staffId_startAt?: SlotStaffIdStartAtCompoundUniqueInput
    AND?: SlotWhereInput | SlotWhereInput[]
    OR?: SlotWhereInput[]
    NOT?: SlotWhereInput | SlotWhereInput[]
    type?: EnumSlotTypeFilter<"Slot"> | $Enums.SlotType
    courtId?: StringNullableFilter<"Slot"> | string | null
    staffId?: StringNullableFilter<"Slot"> | string | null
    startAt?: DateTimeFilter<"Slot"> | Date | string
    endAt?: DateTimeFilter<"Slot"> | Date | string
    price?: IntFilter<"Slot"> | number
    isAvailable?: BoolFilter<"Slot"> | boolean
    createdAt?: DateTimeFilter<"Slot"> | Date | string
    updatedAt?: DateTimeFilter<"Slot"> | Date | string
    court?: XOR<CourtNullableScalarRelationFilter, CourtWhereInput> | null
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    bookingDetails?: BookingDetailListRelationFilter
    bookingCoaches?: BookingCoachListRelationFilter
    bookingBallboys?: BookingBallboyListRelationFilter
  }, "id" | "courtId_startAt" | "staffId_startAt">

  export type SlotOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    courtId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SlotCountOrderByAggregateInput
    _avg?: SlotAvgOrderByAggregateInput
    _max?: SlotMaxOrderByAggregateInput
    _min?: SlotMinOrderByAggregateInput
    _sum?: SlotSumOrderByAggregateInput
  }

  export type SlotScalarWhereWithAggregatesInput = {
    AND?: SlotScalarWhereWithAggregatesInput | SlotScalarWhereWithAggregatesInput[]
    OR?: SlotScalarWhereWithAggregatesInput[]
    NOT?: SlotScalarWhereWithAggregatesInput | SlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Slot"> | string
    type?: EnumSlotTypeWithAggregatesFilter<"Slot"> | $Enums.SlotType
    courtId?: StringNullableWithAggregatesFilter<"Slot"> | string | null
    staffId?: StringNullableWithAggregatesFilter<"Slot"> | string | null
    startAt?: DateTimeWithAggregatesFilter<"Slot"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"Slot"> | Date | string
    price?: IntWithAggregatesFilter<"Slot"> | number
    isAvailable?: BoolWithAggregatesFilter<"Slot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Slot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Slot"> | Date | string
  }

  export type CourtCostScheduleWhereInput = {
    AND?: CourtCostScheduleWhereInput | CourtCostScheduleWhereInput[]
    OR?: CourtCostScheduleWhereInput[]
    NOT?: CourtCostScheduleWhereInput | CourtCostScheduleWhereInput[]
    id?: StringFilter<"CourtCostSchedule"> | string
    courtId?: StringFilter<"CourtCostSchedule"> | string
    startAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    endAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    price?: IntFilter<"CourtCostSchedule"> | number
    isAvailable?: BoolFilter<"CourtCostSchedule"> | boolean
    createdAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    court?: XOR<CourtScalarRelationFilter, CourtWhereInput>
  }

  export type CourtCostScheduleOrderByWithRelationInput = {
    id?: SortOrder
    courtId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    court?: CourtOrderByWithRelationInput
  }

  export type CourtCostScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courtId_startAt?: CourtCostScheduleCourtIdStartAtCompoundUniqueInput
    AND?: CourtCostScheduleWhereInput | CourtCostScheduleWhereInput[]
    OR?: CourtCostScheduleWhereInput[]
    NOT?: CourtCostScheduleWhereInput | CourtCostScheduleWhereInput[]
    courtId?: StringFilter<"CourtCostSchedule"> | string
    startAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    endAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    price?: IntFilter<"CourtCostSchedule"> | number
    isAvailable?: BoolFilter<"CourtCostSchedule"> | boolean
    createdAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    court?: XOR<CourtScalarRelationFilter, CourtWhereInput>
  }, "id" | "courtId_startAt">

  export type CourtCostScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    courtId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourtCostScheduleCountOrderByAggregateInput
    _avg?: CourtCostScheduleAvgOrderByAggregateInput
    _max?: CourtCostScheduleMaxOrderByAggregateInput
    _min?: CourtCostScheduleMinOrderByAggregateInput
    _sum?: CourtCostScheduleSumOrderByAggregateInput
  }

  export type CourtCostScheduleScalarWhereWithAggregatesInput = {
    AND?: CourtCostScheduleScalarWhereWithAggregatesInput | CourtCostScheduleScalarWhereWithAggregatesInput[]
    OR?: CourtCostScheduleScalarWhereWithAggregatesInput[]
    NOT?: CourtCostScheduleScalarWhereWithAggregatesInput | CourtCostScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourtCostSchedule"> | string
    courtId?: StringWithAggregatesFilter<"CourtCostSchedule"> | string
    startAt?: DateTimeWithAggregatesFilter<"CourtCostSchedule"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"CourtCostSchedule"> | Date | string
    price?: IntWithAggregatesFilter<"CourtCostSchedule"> | number
    isAvailable?: BoolWithAggregatesFilter<"CourtCostSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CourtCostSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourtCostSchedule"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    name?: StringFilter<"PaymentMethod"> | string
    logo?: StringNullableFilter<"PaymentMethod"> | string | null
    fees?: IntFilter<"PaymentMethod"> | number
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    payments?: PaymentListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    fees?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    logo?: StringNullableFilter<"PaymentMethod"> | string | null
    fees?: IntFilter<"PaymentMethod"> | number
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    payments?: PaymentListRelationFilter
  }, "id" | "name">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    fees?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    name?: StringWithAggregatesFilter<"PaymentMethod"> | string
    logo?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    fees?: IntWithAggregatesFilter<"PaymentMethod"> | number
    isActive?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    paymentMethodId?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: IntFilter<"Payment"> | number
    fees?: IntFilter<"Payment"> | number
    externalRef?: StringNullableFilter<"Payment"> | string | null
    meta?: JsonNullableFilter<"Payment">
    dueDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    method?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentMethodId?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    externalRef?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    method?: PaymentMethodOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    externalRef?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    paymentMethodId?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: IntFilter<"Payment"> | number
    fees?: IntFilter<"Payment"> | number
    meta?: JsonNullableFilter<"Payment">
    dueDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    method?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id" | "externalRef">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentMethodId?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    externalRef?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethodId?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    amount?: IntWithAggregatesFilter<"Payment"> | number
    fees?: IntWithAggregatesFilter<"Payment"> | number
    externalRef?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"Payment">
    dueDate?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    bookingId?: StringNullableFilter<"Invoice"> | string | null
    classBookingId?: StringNullableFilter<"Invoice"> | string | null
    membershipUserId?: StringNullableFilter<"Invoice"> | string | null
    tournamentRegistrationId?: StringNullableFilter<"Invoice"> | string | null
    number?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    paymentId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: IntFilter<"Invoice"> | number
    processingFee?: IntFilter<"Invoice"> | number
    total?: IntFilter<"Invoice"> | number
    status?: EnumPaymentStatusFilter<"Invoice"> | $Enums.PaymentStatus
    issuedAt?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    classBooking?: XOR<ClassBookingNullableScalarRelationFilter, ClassBookingWhereInput> | null
    membershipUser?: XOR<MembershipUserNullableScalarRelationFilter, MembershipUserWhereInput> | null
    tournamentRegistration?: XOR<TournamentRegistrationNullableScalarRelationFilter, TournamentRegistrationWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    classBookingId?: SortOrderInput | SortOrder
    membershipUserId?: SortOrderInput | SortOrder
    tournamentRegistrationId?: SortOrderInput | SortOrder
    number?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    processingFee?: SortOrder
    total?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    classBooking?: ClassBookingOrderByWithRelationInput
    membershipUser?: MembershipUserOrderByWithRelationInput
    tournamentRegistration?: TournamentRegistrationOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId?: string
    classBookingId?: string
    membershipUserId?: string
    tournamentRegistrationId?: string
    number?: string
    paymentId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    userId?: StringFilter<"Invoice"> | string
    subtotal?: IntFilter<"Invoice"> | number
    processingFee?: IntFilter<"Invoice"> | number
    total?: IntFilter<"Invoice"> | number
    status?: EnumPaymentStatusFilter<"Invoice"> | $Enums.PaymentStatus
    issuedAt?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    classBooking?: XOR<ClassBookingNullableScalarRelationFilter, ClassBookingWhereInput> | null
    membershipUser?: XOR<MembershipUserNullableScalarRelationFilter, MembershipUserWhereInput> | null
    tournamentRegistration?: XOR<TournamentRegistrationNullableScalarRelationFilter, TournamentRegistrationWhereInput> | null
  }, "id" | "bookingId" | "classBookingId" | "membershipUserId" | "tournamentRegistrationId" | "number" | "paymentId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    classBookingId?: SortOrderInput | SortOrder
    membershipUserId?: SortOrderInput | SortOrder
    tournamentRegistrationId?: SortOrderInput | SortOrder
    number?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    processingFee?: SortOrder
    total?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    bookingId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    classBookingId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    membershipUserId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    tournamentRegistrationId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    number?: StringWithAggregatesFilter<"Invoice"> | string
    userId?: StringWithAggregatesFilter<"Invoice"> | string
    paymentId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    subtotal?: IntWithAggregatesFilter<"Invoice"> | number
    processingFee?: IntWithAggregatesFilter<"Invoice"> | number
    total?: IntWithAggregatesFilter<"Invoice"> | number
    status?: EnumPaymentStatusWithAggregatesFilter<"Invoice"> | $Enums.PaymentStatus
    issuedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    totalPrice?: IntFilter<"Booking"> | number
    processingFee?: IntFilter<"Booking"> | number
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    holdExpiresAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Booking"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    details?: BookingDetailListRelationFilter
    inventories?: BookingInventoryListRelationFilter
    ballboys?: BookingBallboyListRelationFilter
    coaches?: BookingCoachListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiresAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    details?: BookingDetailOrderByRelationAggregateInput
    inventories?: BookingInventoryOrderByRelationAggregateInput
    ballboys?: BookingBallboyOrderByRelationAggregateInput
    coaches?: BookingCoachOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    userId?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    totalPrice?: IntFilter<"Booking"> | number
    processingFee?: IntFilter<"Booking"> | number
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    holdExpiresAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Booking"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    details?: BookingDetailListRelationFilter
    inventories?: BookingInventoryListRelationFilter
    ballboys?: BookingBallboyListRelationFilter
    coaches?: BookingCoachListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiresAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    userId?: StringWithAggregatesFilter<"Booking"> | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    totalPrice?: IntWithAggregatesFilter<"Booking"> | number
    processingFee?: IntWithAggregatesFilter<"Booking"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    holdExpiresAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"Booking"> | string | null
  }

  export type BookingDetailWhereInput = {
    AND?: BookingDetailWhereInput | BookingDetailWhereInput[]
    OR?: BookingDetailWhereInput[]
    NOT?: BookingDetailWhereInput | BookingDetailWhereInput[]
    id?: StringFilter<"BookingDetail"> | string
    bookingId?: StringFilter<"BookingDetail"> | string
    slotId?: StringFilter<"BookingDetail"> | string
    price?: IntFilter<"BookingDetail"> | number
    createdAt?: DateTimeFilter<"BookingDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BookingDetail"> | Date | string
    courtId?: StringNullableFilter<"BookingDetail"> | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    slot?: XOR<SlotScalarRelationFilter, SlotWhereInput>
    court?: XOR<CourtNullableScalarRelationFilter, CourtWhereInput> | null
  }

  export type BookingDetailOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courtId?: SortOrderInput | SortOrder
    booking?: BookingOrderByWithRelationInput
    slot?: SlotOrderByWithRelationInput
    court?: CourtOrderByWithRelationInput
  }

  export type BookingDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slotId?: string
    AND?: BookingDetailWhereInput | BookingDetailWhereInput[]
    OR?: BookingDetailWhereInput[]
    NOT?: BookingDetailWhereInput | BookingDetailWhereInput[]
    bookingId?: StringFilter<"BookingDetail"> | string
    price?: IntFilter<"BookingDetail"> | number
    createdAt?: DateTimeFilter<"BookingDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BookingDetail"> | Date | string
    courtId?: StringNullableFilter<"BookingDetail"> | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    slot?: XOR<SlotScalarRelationFilter, SlotWhereInput>
    court?: XOR<CourtNullableScalarRelationFilter, CourtWhereInput> | null
  }, "id" | "slotId">

  export type BookingDetailOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courtId?: SortOrderInput | SortOrder
    _count?: BookingDetailCountOrderByAggregateInput
    _avg?: BookingDetailAvgOrderByAggregateInput
    _max?: BookingDetailMaxOrderByAggregateInput
    _min?: BookingDetailMinOrderByAggregateInput
    _sum?: BookingDetailSumOrderByAggregateInput
  }

  export type BookingDetailScalarWhereWithAggregatesInput = {
    AND?: BookingDetailScalarWhereWithAggregatesInput | BookingDetailScalarWhereWithAggregatesInput[]
    OR?: BookingDetailScalarWhereWithAggregatesInput[]
    NOT?: BookingDetailScalarWhereWithAggregatesInput | BookingDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingDetail"> | string
    bookingId?: StringWithAggregatesFilter<"BookingDetail"> | string
    slotId?: StringWithAggregatesFilter<"BookingDetail"> | string
    price?: IntWithAggregatesFilter<"BookingDetail"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BookingDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookingDetail"> | Date | string
    courtId?: StringNullableWithAggregatesFilter<"BookingDetail"> | string | null
  }

  export type BookingInventoryWhereInput = {
    AND?: BookingInventoryWhereInput | BookingInventoryWhereInput[]
    OR?: BookingInventoryWhereInput[]
    NOT?: BookingInventoryWhereInput | BookingInventoryWhereInput[]
    id?: StringFilter<"BookingInventory"> | string
    bookingId?: StringFilter<"BookingInventory"> | string
    inventoryId?: StringFilter<"BookingInventory"> | string
    quantity?: IntFilter<"BookingInventory"> | number
    price?: IntFilter<"BookingInventory"> | number
    createdAt?: DateTimeFilter<"BookingInventory"> | Date | string
    updatedAt?: DateTimeFilter<"BookingInventory"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
  }

  export type BookingInventoryOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    inventory?: InventoryOrderByWithRelationInput
  }

  export type BookingInventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingInventoryWhereInput | BookingInventoryWhereInput[]
    OR?: BookingInventoryWhereInput[]
    NOT?: BookingInventoryWhereInput | BookingInventoryWhereInput[]
    bookingId?: StringFilter<"BookingInventory"> | string
    inventoryId?: StringFilter<"BookingInventory"> | string
    quantity?: IntFilter<"BookingInventory"> | number
    price?: IntFilter<"BookingInventory"> | number
    createdAt?: DateTimeFilter<"BookingInventory"> | Date | string
    updatedAt?: DateTimeFilter<"BookingInventory"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
  }, "id">

  export type BookingInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingInventoryCountOrderByAggregateInput
    _avg?: BookingInventoryAvgOrderByAggregateInput
    _max?: BookingInventoryMaxOrderByAggregateInput
    _min?: BookingInventoryMinOrderByAggregateInput
    _sum?: BookingInventorySumOrderByAggregateInput
  }

  export type BookingInventoryScalarWhereWithAggregatesInput = {
    AND?: BookingInventoryScalarWhereWithAggregatesInput | BookingInventoryScalarWhereWithAggregatesInput[]
    OR?: BookingInventoryScalarWhereWithAggregatesInput[]
    NOT?: BookingInventoryScalarWhereWithAggregatesInput | BookingInventoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingInventory"> | string
    bookingId?: StringWithAggregatesFilter<"BookingInventory"> | string
    inventoryId?: StringWithAggregatesFilter<"BookingInventory"> | string
    quantity?: IntWithAggregatesFilter<"BookingInventory"> | number
    price?: IntWithAggregatesFilter<"BookingInventory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BookingInventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookingInventory"> | Date | string
  }

  export type BookingBallboyWhereInput = {
    AND?: BookingBallboyWhereInput | BookingBallboyWhereInput[]
    OR?: BookingBallboyWhereInput[]
    NOT?: BookingBallboyWhereInput | BookingBallboyWhereInput[]
    id?: StringFilter<"BookingBallboy"> | string
    bookingId?: StringFilter<"BookingBallboy"> | string
    slotId?: StringFilter<"BookingBallboy"> | string
    price?: IntFilter<"BookingBallboy"> | number
    createdAt?: DateTimeFilter<"BookingBallboy"> | Date | string
    updatedAt?: DateTimeFilter<"BookingBallboy"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    slot?: XOR<SlotScalarRelationFilter, SlotWhereInput>
  }

  export type BookingBallboyOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    slot?: SlotOrderByWithRelationInput
  }

  export type BookingBallboyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slotId?: string
    AND?: BookingBallboyWhereInput | BookingBallboyWhereInput[]
    OR?: BookingBallboyWhereInput[]
    NOT?: BookingBallboyWhereInput | BookingBallboyWhereInput[]
    bookingId?: StringFilter<"BookingBallboy"> | string
    price?: IntFilter<"BookingBallboy"> | number
    createdAt?: DateTimeFilter<"BookingBallboy"> | Date | string
    updatedAt?: DateTimeFilter<"BookingBallboy"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    slot?: XOR<SlotScalarRelationFilter, SlotWhereInput>
  }, "id" | "slotId">

  export type BookingBallboyOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingBallboyCountOrderByAggregateInput
    _avg?: BookingBallboyAvgOrderByAggregateInput
    _max?: BookingBallboyMaxOrderByAggregateInput
    _min?: BookingBallboyMinOrderByAggregateInput
    _sum?: BookingBallboySumOrderByAggregateInput
  }

  export type BookingBallboyScalarWhereWithAggregatesInput = {
    AND?: BookingBallboyScalarWhereWithAggregatesInput | BookingBallboyScalarWhereWithAggregatesInput[]
    OR?: BookingBallboyScalarWhereWithAggregatesInput[]
    NOT?: BookingBallboyScalarWhereWithAggregatesInput | BookingBallboyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingBallboy"> | string
    bookingId?: StringWithAggregatesFilter<"BookingBallboy"> | string
    slotId?: StringWithAggregatesFilter<"BookingBallboy"> | string
    price?: IntWithAggregatesFilter<"BookingBallboy"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BookingBallboy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookingBallboy"> | Date | string
  }

  export type BookingCoachTypeWhereInput = {
    AND?: BookingCoachTypeWhereInput | BookingCoachTypeWhereInput[]
    OR?: BookingCoachTypeWhereInput[]
    NOT?: BookingCoachTypeWhereInput | BookingCoachTypeWhereInput[]
    id?: StringFilter<"BookingCoachType"> | string
    name?: StringFilter<"BookingCoachType"> | string
    description?: StringNullableFilter<"BookingCoachType"> | string | null
    isActive?: BoolFilter<"BookingCoachType"> | boolean
    createdAt?: DateTimeFilter<"BookingCoachType"> | Date | string
    updatedAt?: DateTimeFilter<"BookingCoachType"> | Date | string
    bookingCoach?: BookingCoachListRelationFilter
    coachTypeStaffPrice?: CoachTypeStaffPriceListRelationFilter
  }

  export type BookingCoachTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingCoach?: BookingCoachOrderByRelationAggregateInput
    coachTypeStaffPrice?: CoachTypeStaffPriceOrderByRelationAggregateInput
  }

  export type BookingCoachTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BookingCoachTypeWhereInput | BookingCoachTypeWhereInput[]
    OR?: BookingCoachTypeWhereInput[]
    NOT?: BookingCoachTypeWhereInput | BookingCoachTypeWhereInput[]
    description?: StringNullableFilter<"BookingCoachType"> | string | null
    isActive?: BoolFilter<"BookingCoachType"> | boolean
    createdAt?: DateTimeFilter<"BookingCoachType"> | Date | string
    updatedAt?: DateTimeFilter<"BookingCoachType"> | Date | string
    bookingCoach?: BookingCoachListRelationFilter
    coachTypeStaffPrice?: CoachTypeStaffPriceListRelationFilter
  }, "id" | "name">

  export type BookingCoachTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCoachTypeCountOrderByAggregateInput
    _max?: BookingCoachTypeMaxOrderByAggregateInput
    _min?: BookingCoachTypeMinOrderByAggregateInput
  }

  export type BookingCoachTypeScalarWhereWithAggregatesInput = {
    AND?: BookingCoachTypeScalarWhereWithAggregatesInput | BookingCoachTypeScalarWhereWithAggregatesInput[]
    OR?: BookingCoachTypeScalarWhereWithAggregatesInput[]
    NOT?: BookingCoachTypeScalarWhereWithAggregatesInput | BookingCoachTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingCoachType"> | string
    name?: StringWithAggregatesFilter<"BookingCoachType"> | string
    description?: StringNullableWithAggregatesFilter<"BookingCoachType"> | string | null
    isActive?: BoolWithAggregatesFilter<"BookingCoachType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BookingCoachType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookingCoachType"> | Date | string
  }

  export type CoachTypeStaffPriceWhereInput = {
    AND?: CoachTypeStaffPriceWhereInput | CoachTypeStaffPriceWhereInput[]
    OR?: CoachTypeStaffPriceWhereInput[]
    NOT?: CoachTypeStaffPriceWhereInput | CoachTypeStaffPriceWhereInput[]
    id?: StringFilter<"CoachTypeStaffPrice"> | string
    staffId?: StringFilter<"CoachTypeStaffPrice"> | string
    coachTypeId?: StringFilter<"CoachTypeStaffPrice"> | string
    basePrice?: BigIntFilter<"CoachTypeStaffPrice"> | bigint | number
    createdAt?: DateTimeFilter<"CoachTypeStaffPrice"> | Date | string
    updatedAt?: DateTimeFilter<"CoachTypeStaffPrice"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    coachType?: XOR<BookingCoachTypeScalarRelationFilter, BookingCoachTypeWhereInput>
  }

  export type CoachTypeStaffPriceOrderByWithRelationInput = {
    id?: SortOrder
    staffId?: SortOrder
    coachTypeId?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staff?: StaffOrderByWithRelationInput
    coachType?: BookingCoachTypeOrderByWithRelationInput
  }

  export type CoachTypeStaffPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    staffId_coachTypeId?: CoachTypeStaffPriceStaffIdCoachTypeIdCompoundUniqueInput
    AND?: CoachTypeStaffPriceWhereInput | CoachTypeStaffPriceWhereInput[]
    OR?: CoachTypeStaffPriceWhereInput[]
    NOT?: CoachTypeStaffPriceWhereInput | CoachTypeStaffPriceWhereInput[]
    staffId?: StringFilter<"CoachTypeStaffPrice"> | string
    coachTypeId?: StringFilter<"CoachTypeStaffPrice"> | string
    basePrice?: BigIntFilter<"CoachTypeStaffPrice"> | bigint | number
    createdAt?: DateTimeFilter<"CoachTypeStaffPrice"> | Date | string
    updatedAt?: DateTimeFilter<"CoachTypeStaffPrice"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    coachType?: XOR<BookingCoachTypeScalarRelationFilter, BookingCoachTypeWhereInput>
  }, "id" | "staffId_coachTypeId">

  export type CoachTypeStaffPriceOrderByWithAggregationInput = {
    id?: SortOrder
    staffId?: SortOrder
    coachTypeId?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoachTypeStaffPriceCountOrderByAggregateInput
    _avg?: CoachTypeStaffPriceAvgOrderByAggregateInput
    _max?: CoachTypeStaffPriceMaxOrderByAggregateInput
    _min?: CoachTypeStaffPriceMinOrderByAggregateInput
    _sum?: CoachTypeStaffPriceSumOrderByAggregateInput
  }

  export type CoachTypeStaffPriceScalarWhereWithAggregatesInput = {
    AND?: CoachTypeStaffPriceScalarWhereWithAggregatesInput | CoachTypeStaffPriceScalarWhereWithAggregatesInput[]
    OR?: CoachTypeStaffPriceScalarWhereWithAggregatesInput[]
    NOT?: CoachTypeStaffPriceScalarWhereWithAggregatesInput | CoachTypeStaffPriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoachTypeStaffPrice"> | string
    staffId?: StringWithAggregatesFilter<"CoachTypeStaffPrice"> | string
    coachTypeId?: StringWithAggregatesFilter<"CoachTypeStaffPrice"> | string
    basePrice?: BigIntWithAggregatesFilter<"CoachTypeStaffPrice"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"CoachTypeStaffPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoachTypeStaffPrice"> | Date | string
  }

  export type BookingCoachWhereInput = {
    AND?: BookingCoachWhereInput | BookingCoachWhereInput[]
    OR?: BookingCoachWhereInput[]
    NOT?: BookingCoachWhereInput | BookingCoachWhereInput[]
    id?: StringFilter<"BookingCoach"> | string
    bookingId?: StringFilter<"BookingCoach"> | string
    slotId?: StringFilter<"BookingCoach"> | string
    bookingCoachTypeId?: StringFilter<"BookingCoach"> | string
    price?: IntFilter<"BookingCoach"> | number
    createdAt?: DateTimeFilter<"BookingCoach"> | Date | string
    updatedAt?: DateTimeFilter<"BookingCoach"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    slot?: XOR<SlotScalarRelationFilter, SlotWhereInput>
    bookingCoachType?: XOR<BookingCoachTypeScalarRelationFilter, BookingCoachTypeWhereInput>
  }

  export type BookingCoachOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    bookingCoachTypeId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    slot?: SlotOrderByWithRelationInput
    bookingCoachType?: BookingCoachTypeOrderByWithRelationInput
  }

  export type BookingCoachWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slotId?: string
    AND?: BookingCoachWhereInput | BookingCoachWhereInput[]
    OR?: BookingCoachWhereInput[]
    NOT?: BookingCoachWhereInput | BookingCoachWhereInput[]
    bookingId?: StringFilter<"BookingCoach"> | string
    bookingCoachTypeId?: StringFilter<"BookingCoach"> | string
    price?: IntFilter<"BookingCoach"> | number
    createdAt?: DateTimeFilter<"BookingCoach"> | Date | string
    updatedAt?: DateTimeFilter<"BookingCoach"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    slot?: XOR<SlotScalarRelationFilter, SlotWhereInput>
    bookingCoachType?: XOR<BookingCoachTypeScalarRelationFilter, BookingCoachTypeWhereInput>
  }, "id" | "slotId">

  export type BookingCoachOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    bookingCoachTypeId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCoachCountOrderByAggregateInput
    _avg?: BookingCoachAvgOrderByAggregateInput
    _max?: BookingCoachMaxOrderByAggregateInput
    _min?: BookingCoachMinOrderByAggregateInput
    _sum?: BookingCoachSumOrderByAggregateInput
  }

  export type BookingCoachScalarWhereWithAggregatesInput = {
    AND?: BookingCoachScalarWhereWithAggregatesInput | BookingCoachScalarWhereWithAggregatesInput[]
    OR?: BookingCoachScalarWhereWithAggregatesInput[]
    NOT?: BookingCoachScalarWhereWithAggregatesInput | BookingCoachScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingCoach"> | string
    bookingId?: StringWithAggregatesFilter<"BookingCoach"> | string
    slotId?: StringWithAggregatesFilter<"BookingCoach"> | string
    bookingCoachTypeId?: StringWithAggregatesFilter<"BookingCoach"> | string
    price?: IntWithAggregatesFilter<"BookingCoach"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BookingCoach"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BookingCoach"> | Date | string
  }

  export type MembershipWhereInput = {
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    id?: StringFilter<"Membership"> | string
    name?: StringFilter<"Membership"> | string
    description?: StringNullableFilter<"Membership"> | string | null
    content?: StringNullableFilter<"Membership"> | string | null
    price?: IntFilter<"Membership"> | number
    sessions?: IntFilter<"Membership"> | number
    duration?: IntFilter<"Membership"> | number
    sequence?: IntFilter<"Membership"> | number
    isActive?: BoolFilter<"Membership"> | boolean
    createdAt?: DateTimeFilter<"Membership"> | Date | string
    updatedAt?: DateTimeFilter<"Membership"> | Date | string
    benefits?: MembershipBenefitListRelationFilter
    membershipUser?: MembershipUserListRelationFilter
  }

  export type MembershipOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    price?: SortOrder
    sessions?: SortOrder
    duration?: SortOrder
    sequence?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    benefits?: MembershipBenefitOrderByRelationAggregateInput
    membershipUser?: MembershipUserOrderByRelationAggregateInput
  }

  export type MembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    description?: StringNullableFilter<"Membership"> | string | null
    content?: StringNullableFilter<"Membership"> | string | null
    price?: IntFilter<"Membership"> | number
    sessions?: IntFilter<"Membership"> | number
    duration?: IntFilter<"Membership"> | number
    sequence?: IntFilter<"Membership"> | number
    isActive?: BoolFilter<"Membership"> | boolean
    createdAt?: DateTimeFilter<"Membership"> | Date | string
    updatedAt?: DateTimeFilter<"Membership"> | Date | string
    benefits?: MembershipBenefitListRelationFilter
    membershipUser?: MembershipUserListRelationFilter
  }, "id" | "name">

  export type MembershipOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    price?: SortOrder
    sessions?: SortOrder
    duration?: SortOrder
    sequence?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipCountOrderByAggregateInput
    _avg?: MembershipAvgOrderByAggregateInput
    _max?: MembershipMaxOrderByAggregateInput
    _min?: MembershipMinOrderByAggregateInput
    _sum?: MembershipSumOrderByAggregateInput
  }

  export type MembershipScalarWhereWithAggregatesInput = {
    AND?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    OR?: MembershipScalarWhereWithAggregatesInput[]
    NOT?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Membership"> | string
    name?: StringWithAggregatesFilter<"Membership"> | string
    description?: StringNullableWithAggregatesFilter<"Membership"> | string | null
    content?: StringNullableWithAggregatesFilter<"Membership"> | string | null
    price?: IntWithAggregatesFilter<"Membership"> | number
    sessions?: IntWithAggregatesFilter<"Membership"> | number
    duration?: IntWithAggregatesFilter<"Membership"> | number
    sequence?: IntWithAggregatesFilter<"Membership"> | number
    isActive?: BoolWithAggregatesFilter<"Membership"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Membership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Membership"> | Date | string
  }

  export type MembershipBenefitWhereInput = {
    AND?: MembershipBenefitWhereInput | MembershipBenefitWhereInput[]
    OR?: MembershipBenefitWhereInput[]
    NOT?: MembershipBenefitWhereInput | MembershipBenefitWhereInput[]
    id?: StringFilter<"MembershipBenefit"> | string
    membershipId?: StringFilter<"MembershipBenefit"> | string
    benefit?: StringFilter<"MembershipBenefit"> | string
    createdAt?: DateTimeFilter<"MembershipBenefit"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipBenefit"> | Date | string
    membership?: XOR<MembershipScalarRelationFilter, MembershipWhereInput>
  }

  export type MembershipBenefitOrderByWithRelationInput = {
    id?: SortOrder
    membershipId?: SortOrder
    benefit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    membership?: MembershipOrderByWithRelationInput
  }

  export type MembershipBenefitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MembershipBenefitWhereInput | MembershipBenefitWhereInput[]
    OR?: MembershipBenefitWhereInput[]
    NOT?: MembershipBenefitWhereInput | MembershipBenefitWhereInput[]
    membershipId?: StringFilter<"MembershipBenefit"> | string
    benefit?: StringFilter<"MembershipBenefit"> | string
    createdAt?: DateTimeFilter<"MembershipBenefit"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipBenefit"> | Date | string
    membership?: XOR<MembershipScalarRelationFilter, MembershipWhereInput>
  }, "id">

  export type MembershipBenefitOrderByWithAggregationInput = {
    id?: SortOrder
    membershipId?: SortOrder
    benefit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipBenefitCountOrderByAggregateInput
    _max?: MembershipBenefitMaxOrderByAggregateInput
    _min?: MembershipBenefitMinOrderByAggregateInput
  }

  export type MembershipBenefitScalarWhereWithAggregatesInput = {
    AND?: MembershipBenefitScalarWhereWithAggregatesInput | MembershipBenefitScalarWhereWithAggregatesInput[]
    OR?: MembershipBenefitScalarWhereWithAggregatesInput[]
    NOT?: MembershipBenefitScalarWhereWithAggregatesInput | MembershipBenefitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MembershipBenefit"> | string
    membershipId?: StringWithAggregatesFilter<"MembershipBenefit"> | string
    benefit?: StringWithAggregatesFilter<"MembershipBenefit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MembershipBenefit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MembershipBenefit"> | Date | string
  }

  export type MembershipUserWhereInput = {
    AND?: MembershipUserWhereInput | MembershipUserWhereInput[]
    OR?: MembershipUserWhereInput[]
    NOT?: MembershipUserWhereInput | MembershipUserWhereInput[]
    id?: StringFilter<"MembershipUser"> | string
    userId?: StringFilter<"MembershipUser"> | string
    membershipId?: StringFilter<"MembershipUser"> | string
    startDate?: DateTimeFilter<"MembershipUser"> | Date | string
    endDate?: DateTimeFilter<"MembershipUser"> | Date | string
    remainingSessions?: IntFilter<"MembershipUser"> | number
    remainingDuration?: IntFilter<"MembershipUser"> | number
    isExpired?: BoolFilter<"MembershipUser"> | boolean
    isSuspended?: BoolFilter<"MembershipUser"> | boolean
    suspensionReason?: StringNullableFilter<"MembershipUser"> | string | null
    suspensionEndDate?: DateTimeNullableFilter<"MembershipUser"> | Date | string | null
    createdAt?: DateTimeFilter<"MembershipUser"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    membership?: XOR<MembershipScalarRelationFilter, MembershipWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type MembershipUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    membershipId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    remainingSessions?: SortOrder
    remainingDuration?: SortOrder
    isExpired?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrderInput | SortOrder
    suspensionEndDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    membership?: MembershipOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type MembershipUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MembershipUserWhereInput | MembershipUserWhereInput[]
    OR?: MembershipUserWhereInput[]
    NOT?: MembershipUserWhereInput | MembershipUserWhereInput[]
    userId?: StringFilter<"MembershipUser"> | string
    membershipId?: StringFilter<"MembershipUser"> | string
    startDate?: DateTimeFilter<"MembershipUser"> | Date | string
    endDate?: DateTimeFilter<"MembershipUser"> | Date | string
    remainingSessions?: IntFilter<"MembershipUser"> | number
    remainingDuration?: IntFilter<"MembershipUser"> | number
    isExpired?: BoolFilter<"MembershipUser"> | boolean
    isSuspended?: BoolFilter<"MembershipUser"> | boolean
    suspensionReason?: StringNullableFilter<"MembershipUser"> | string | null
    suspensionEndDate?: DateTimeNullableFilter<"MembershipUser"> | Date | string | null
    createdAt?: DateTimeFilter<"MembershipUser"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    membership?: XOR<MembershipScalarRelationFilter, MembershipWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type MembershipUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    membershipId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    remainingSessions?: SortOrder
    remainingDuration?: SortOrder
    isExpired?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrderInput | SortOrder
    suspensionEndDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipUserCountOrderByAggregateInput
    _avg?: MembershipUserAvgOrderByAggregateInput
    _max?: MembershipUserMaxOrderByAggregateInput
    _min?: MembershipUserMinOrderByAggregateInput
    _sum?: MembershipUserSumOrderByAggregateInput
  }

  export type MembershipUserScalarWhereWithAggregatesInput = {
    AND?: MembershipUserScalarWhereWithAggregatesInput | MembershipUserScalarWhereWithAggregatesInput[]
    OR?: MembershipUserScalarWhereWithAggregatesInput[]
    NOT?: MembershipUserScalarWhereWithAggregatesInput | MembershipUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MembershipUser"> | string
    userId?: StringWithAggregatesFilter<"MembershipUser"> | string
    membershipId?: StringWithAggregatesFilter<"MembershipUser"> | string
    startDate?: DateTimeWithAggregatesFilter<"MembershipUser"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"MembershipUser"> | Date | string
    remainingSessions?: IntWithAggregatesFilter<"MembershipUser"> | number
    remainingDuration?: IntWithAggregatesFilter<"MembershipUser"> | number
    isExpired?: BoolWithAggregatesFilter<"MembershipUser"> | boolean
    isSuspended?: BoolWithAggregatesFilter<"MembershipUser"> | boolean
    suspensionReason?: StringNullableWithAggregatesFilter<"MembershipUser"> | string | null
    suspensionEndDate?: DateTimeNullableWithAggregatesFilter<"MembershipUser"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MembershipUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MembershipUser"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    content?: StringNullableFilter<"Class"> | string | null
    organizerName?: StringNullableFilter<"Class"> | string | null
    speakerName?: StringNullableFilter<"Class"> | string | null
    image?: StringNullableFilter<"Class"> | string | null
    startDate?: DateTimeFilter<"Class"> | Date | string
    endDate?: DateTimeFilter<"Class"> | Date | string
    startTime?: StringFilter<"Class"> | string
    endTime?: StringFilter<"Class"> | string
    price?: IntFilter<"Class"> | number
    sessions?: IntFilter<"Class"> | number
    capacity?: IntFilter<"Class"> | number
    remaining?: IntFilter<"Class"> | number
    maxBookingPax?: IntFilter<"Class"> | number
    gender?: EnumGenderFilter<"Class"> | $Enums.Gender
    ageMin?: IntFilter<"Class"> | number
    isActive?: BoolFilter<"Class"> | boolean
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    classBookings?: ClassBookingListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    organizerName?: SortOrderInput | SortOrder
    speakerName?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    price?: SortOrder
    sessions?: SortOrder
    capacity?: SortOrder
    remaining?: SortOrder
    maxBookingPax?: SortOrder
    gender?: SortOrder
    ageMin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classBookings?: ClassBookingOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    description?: StringNullableFilter<"Class"> | string | null
    content?: StringNullableFilter<"Class"> | string | null
    organizerName?: StringNullableFilter<"Class"> | string | null
    speakerName?: StringNullableFilter<"Class"> | string | null
    image?: StringNullableFilter<"Class"> | string | null
    startDate?: DateTimeFilter<"Class"> | Date | string
    endDate?: DateTimeFilter<"Class"> | Date | string
    startTime?: StringFilter<"Class"> | string
    endTime?: StringFilter<"Class"> | string
    price?: IntFilter<"Class"> | number
    sessions?: IntFilter<"Class"> | number
    capacity?: IntFilter<"Class"> | number
    remaining?: IntFilter<"Class"> | number
    maxBookingPax?: IntFilter<"Class"> | number
    gender?: EnumGenderFilter<"Class"> | $Enums.Gender
    ageMin?: IntFilter<"Class"> | number
    isActive?: BoolFilter<"Class"> | boolean
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    classBookings?: ClassBookingListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    organizerName?: SortOrderInput | SortOrder
    speakerName?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    price?: SortOrder
    sessions?: SortOrder
    capacity?: SortOrder
    remaining?: SortOrder
    maxBookingPax?: SortOrder
    gender?: SortOrder
    ageMin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    description?: StringNullableWithAggregatesFilter<"Class"> | string | null
    content?: StringNullableWithAggregatesFilter<"Class"> | string | null
    organizerName?: StringNullableWithAggregatesFilter<"Class"> | string | null
    speakerName?: StringNullableWithAggregatesFilter<"Class"> | string | null
    image?: StringNullableWithAggregatesFilter<"Class"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    startTime?: StringWithAggregatesFilter<"Class"> | string
    endTime?: StringWithAggregatesFilter<"Class"> | string
    price?: IntWithAggregatesFilter<"Class"> | number
    sessions?: IntWithAggregatesFilter<"Class"> | number
    capacity?: IntWithAggregatesFilter<"Class"> | number
    remaining?: IntWithAggregatesFilter<"Class"> | number
    maxBookingPax?: IntWithAggregatesFilter<"Class"> | number
    gender?: EnumGenderWithAggregatesFilter<"Class"> | $Enums.Gender
    ageMin?: IntWithAggregatesFilter<"Class"> | number
    isActive?: BoolWithAggregatesFilter<"Class"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type ClassBookingWhereInput = {
    AND?: ClassBookingWhereInput | ClassBookingWhereInput[]
    OR?: ClassBookingWhereInput[]
    NOT?: ClassBookingWhereInput | ClassBookingWhereInput[]
    id?: StringFilter<"ClassBooking"> | string
    classId?: StringFilter<"ClassBooking"> | string
    userId?: StringFilter<"ClassBooking"> | string
    status?: EnumBookingStatusFilter<"ClassBooking"> | $Enums.BookingStatus
    totalPrice?: IntFilter<"ClassBooking"> | number
    processingFee?: IntFilter<"ClassBooking"> | number
    createdAt?: DateTimeFilter<"ClassBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ClassBooking"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"ClassBooking"> | Date | string | null
    cancellationReason?: StringNullableFilter<"ClassBooking"> | string | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    details?: ClassBookingDetailListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type ClassBookingOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    class?: ClassOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    details?: ClassBookingDetailOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type ClassBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassBookingWhereInput | ClassBookingWhereInput[]
    OR?: ClassBookingWhereInput[]
    NOT?: ClassBookingWhereInput | ClassBookingWhereInput[]
    classId?: StringFilter<"ClassBooking"> | string
    userId?: StringFilter<"ClassBooking"> | string
    status?: EnumBookingStatusFilter<"ClassBooking"> | $Enums.BookingStatus
    totalPrice?: IntFilter<"ClassBooking"> | number
    processingFee?: IntFilter<"ClassBooking"> | number
    createdAt?: DateTimeFilter<"ClassBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ClassBooking"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"ClassBooking"> | Date | string | null
    cancellationReason?: StringNullableFilter<"ClassBooking"> | string | null
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    details?: ClassBookingDetailListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type ClassBookingOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    _count?: ClassBookingCountOrderByAggregateInput
    _avg?: ClassBookingAvgOrderByAggregateInput
    _max?: ClassBookingMaxOrderByAggregateInput
    _min?: ClassBookingMinOrderByAggregateInput
    _sum?: ClassBookingSumOrderByAggregateInput
  }

  export type ClassBookingScalarWhereWithAggregatesInput = {
    AND?: ClassBookingScalarWhereWithAggregatesInput | ClassBookingScalarWhereWithAggregatesInput[]
    OR?: ClassBookingScalarWhereWithAggregatesInput[]
    NOT?: ClassBookingScalarWhereWithAggregatesInput | ClassBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassBooking"> | string
    classId?: StringWithAggregatesFilter<"ClassBooking"> | string
    userId?: StringWithAggregatesFilter<"ClassBooking"> | string
    status?: EnumBookingStatusWithAggregatesFilter<"ClassBooking"> | $Enums.BookingStatus
    totalPrice?: IntWithAggregatesFilter<"ClassBooking"> | number
    processingFee?: IntWithAggregatesFilter<"ClassBooking"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ClassBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassBooking"> | Date | string
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"ClassBooking"> | Date | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"ClassBooking"> | string | null
  }

  export type ClassBookingDetailWhereInput = {
    AND?: ClassBookingDetailWhereInput | ClassBookingDetailWhereInput[]
    OR?: ClassBookingDetailWhereInput[]
    NOT?: ClassBookingDetailWhereInput | ClassBookingDetailWhereInput[]
    id?: StringFilter<"ClassBookingDetail"> | string
    classBookingId?: StringFilter<"ClassBookingDetail"> | string
    date?: DateTimeFilter<"ClassBookingDetail"> | Date | string
    time?: StringFilter<"ClassBookingDetail"> | string
    price?: IntFilter<"ClassBookingDetail"> | number
    attendance?: BoolFilter<"ClassBookingDetail"> | boolean
    createdAt?: DateTimeFilter<"ClassBookingDetail"> | Date | string
    updatedAt?: DateTimeFilter<"ClassBookingDetail"> | Date | string
    classBooking?: XOR<ClassBookingScalarRelationFilter, ClassBookingWhereInput>
  }

  export type ClassBookingDetailOrderByWithRelationInput = {
    id?: SortOrder
    classBookingId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    price?: SortOrder
    attendance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classBooking?: ClassBookingOrderByWithRelationInput
  }

  export type ClassBookingDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassBookingDetailWhereInput | ClassBookingDetailWhereInput[]
    OR?: ClassBookingDetailWhereInput[]
    NOT?: ClassBookingDetailWhereInput | ClassBookingDetailWhereInput[]
    classBookingId?: StringFilter<"ClassBookingDetail"> | string
    date?: DateTimeFilter<"ClassBookingDetail"> | Date | string
    time?: StringFilter<"ClassBookingDetail"> | string
    price?: IntFilter<"ClassBookingDetail"> | number
    attendance?: BoolFilter<"ClassBookingDetail"> | boolean
    createdAt?: DateTimeFilter<"ClassBookingDetail"> | Date | string
    updatedAt?: DateTimeFilter<"ClassBookingDetail"> | Date | string
    classBooking?: XOR<ClassBookingScalarRelationFilter, ClassBookingWhereInput>
  }, "id">

  export type ClassBookingDetailOrderByWithAggregationInput = {
    id?: SortOrder
    classBookingId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    price?: SortOrder
    attendance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassBookingDetailCountOrderByAggregateInput
    _avg?: ClassBookingDetailAvgOrderByAggregateInput
    _max?: ClassBookingDetailMaxOrderByAggregateInput
    _min?: ClassBookingDetailMinOrderByAggregateInput
    _sum?: ClassBookingDetailSumOrderByAggregateInput
  }

  export type ClassBookingDetailScalarWhereWithAggregatesInput = {
    AND?: ClassBookingDetailScalarWhereWithAggregatesInput | ClassBookingDetailScalarWhereWithAggregatesInput[]
    OR?: ClassBookingDetailScalarWhereWithAggregatesInput[]
    NOT?: ClassBookingDetailScalarWhereWithAggregatesInput | ClassBookingDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassBookingDetail"> | string
    classBookingId?: StringWithAggregatesFilter<"ClassBookingDetail"> | string
    date?: DateTimeWithAggregatesFilter<"ClassBookingDetail"> | Date | string
    time?: StringWithAggregatesFilter<"ClassBookingDetail"> | string
    price?: IntWithAggregatesFilter<"ClassBookingDetail"> | number
    attendance?: BoolWithAggregatesFilter<"ClassBookingDetail"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClassBookingDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassBookingDetail"> | Date | string
  }

  export type ClubWhereInput = {
    AND?: ClubWhereInput | ClubWhereInput[]
    OR?: ClubWhereInput[]
    NOT?: ClubWhereInput | ClubWhereInput[]
    id?: StringFilter<"Club"> | string
    name?: StringFilter<"Club"> | string
    logo?: StringNullableFilter<"Club"> | string | null
    description?: StringNullableFilter<"Club"> | string | null
    rules?: StringNullableFilter<"Club"> | string | null
    leaderId?: StringFilter<"Club"> | string
    visibility?: EnumClubVisibilityFilter<"Club"> | $Enums.ClubVisibility
    isActive?: BoolFilter<"Club"> | boolean
    createdAt?: DateTimeFilter<"Club"> | Date | string
    updatedAt?: DateTimeFilter<"Club"> | Date | string
    leader?: XOR<UserScalarRelationFilter, UserWhereInput>
    clubMember?: ClubMemberListRelationFilter
    tournamentRegistration?: TournamentRegistrationListRelationFilter
  }

  export type ClubOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    leaderId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leader?: UserOrderByWithRelationInput
    clubMember?: ClubMemberOrderByRelationAggregateInput
    tournamentRegistration?: TournamentRegistrationOrderByRelationAggregateInput
  }

  export type ClubWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ClubWhereInput | ClubWhereInput[]
    OR?: ClubWhereInput[]
    NOT?: ClubWhereInput | ClubWhereInput[]
    logo?: StringNullableFilter<"Club"> | string | null
    description?: StringNullableFilter<"Club"> | string | null
    rules?: StringNullableFilter<"Club"> | string | null
    leaderId?: StringFilter<"Club"> | string
    visibility?: EnumClubVisibilityFilter<"Club"> | $Enums.ClubVisibility
    isActive?: BoolFilter<"Club"> | boolean
    createdAt?: DateTimeFilter<"Club"> | Date | string
    updatedAt?: DateTimeFilter<"Club"> | Date | string
    leader?: XOR<UserScalarRelationFilter, UserWhereInput>
    clubMember?: ClubMemberListRelationFilter
    tournamentRegistration?: TournamentRegistrationListRelationFilter
  }, "id" | "name">

  export type ClubOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    leaderId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClubCountOrderByAggregateInput
    _max?: ClubMaxOrderByAggregateInput
    _min?: ClubMinOrderByAggregateInput
  }

  export type ClubScalarWhereWithAggregatesInput = {
    AND?: ClubScalarWhereWithAggregatesInput | ClubScalarWhereWithAggregatesInput[]
    OR?: ClubScalarWhereWithAggregatesInput[]
    NOT?: ClubScalarWhereWithAggregatesInput | ClubScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Club"> | string
    name?: StringWithAggregatesFilter<"Club"> | string
    logo?: StringNullableWithAggregatesFilter<"Club"> | string | null
    description?: StringNullableWithAggregatesFilter<"Club"> | string | null
    rules?: StringNullableWithAggregatesFilter<"Club"> | string | null
    leaderId?: StringWithAggregatesFilter<"Club"> | string
    visibility?: EnumClubVisibilityWithAggregatesFilter<"Club"> | $Enums.ClubVisibility
    isActive?: BoolWithAggregatesFilter<"Club"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Club"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Club"> | Date | string
  }

  export type ClubMemberWhereInput = {
    AND?: ClubMemberWhereInput | ClubMemberWhereInput[]
    OR?: ClubMemberWhereInput[]
    NOT?: ClubMemberWhereInput | ClubMemberWhereInput[]
    id?: StringFilter<"ClubMember"> | string
    clubId?: StringFilter<"ClubMember"> | string
    userId?: StringFilter<"ClubMember"> | string
    joinedAt?: DateTimeFilter<"ClubMember"> | Date | string
    isActive?: BoolFilter<"ClubMember"> | boolean
    createdAt?: DateTimeFilter<"ClubMember"> | Date | string
    updatedAt?: DateTimeFilter<"ClubMember"> | Date | string
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClubMemberOrderByWithRelationInput = {
    id?: SortOrder
    clubId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    club?: ClubOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ClubMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clubId_userId?: ClubMemberClubIdUserIdCompoundUniqueInput
    AND?: ClubMemberWhereInput | ClubMemberWhereInput[]
    OR?: ClubMemberWhereInput[]
    NOT?: ClubMemberWhereInput | ClubMemberWhereInput[]
    clubId?: StringFilter<"ClubMember"> | string
    userId?: StringFilter<"ClubMember"> | string
    joinedAt?: DateTimeFilter<"ClubMember"> | Date | string
    isActive?: BoolFilter<"ClubMember"> | boolean
    createdAt?: DateTimeFilter<"ClubMember"> | Date | string
    updatedAt?: DateTimeFilter<"ClubMember"> | Date | string
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "clubId_userId">

  export type ClubMemberOrderByWithAggregationInput = {
    id?: SortOrder
    clubId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClubMemberCountOrderByAggregateInput
    _max?: ClubMemberMaxOrderByAggregateInput
    _min?: ClubMemberMinOrderByAggregateInput
  }

  export type ClubMemberScalarWhereWithAggregatesInput = {
    AND?: ClubMemberScalarWhereWithAggregatesInput | ClubMemberScalarWhereWithAggregatesInput[]
    OR?: ClubMemberScalarWhereWithAggregatesInput[]
    NOT?: ClubMemberScalarWhereWithAggregatesInput | ClubMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClubMember"> | string
    clubId?: StringWithAggregatesFilter<"ClubMember"> | string
    userId?: StringWithAggregatesFilter<"ClubMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ClubMember"> | Date | string
    isActive?: BoolWithAggregatesFilter<"ClubMember"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClubMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClubMember"> | Date | string
  }

  export type TournamentWhereInput = {
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    id?: StringFilter<"Tournament"> | string
    name?: StringFilter<"Tournament"> | string
    description?: StringNullableFilter<"Tournament"> | string | null
    rules?: StringNullableFilter<"Tournament"> | string | null
    image?: StringNullableFilter<"Tournament"> | string | null
    startDate?: DateTimeFilter<"Tournament"> | Date | string
    endDate?: DateTimeFilter<"Tournament"> | Date | string
    startTime?: StringFilter<"Tournament"> | string
    endTime?: StringFilter<"Tournament"> | string
    maxTeams?: IntFilter<"Tournament"> | number
    teamSize?: IntFilter<"Tournament"> | number
    entryFee?: IntFilter<"Tournament"> | number
    location?: StringFilter<"Tournament"> | string
    isActive?: BoolFilter<"Tournament"> | boolean
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeFilter<"Tournament"> | Date | string
    tournamentRegistration?: TournamentRegistrationListRelationFilter
  }

  export type TournamentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxTeams?: SortOrder
    teamSize?: SortOrder
    entryFee?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tournamentRegistration?: TournamentRegistrationOrderByRelationAggregateInput
  }

  export type TournamentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    name?: StringFilter<"Tournament"> | string
    description?: StringNullableFilter<"Tournament"> | string | null
    rules?: StringNullableFilter<"Tournament"> | string | null
    image?: StringNullableFilter<"Tournament"> | string | null
    startDate?: DateTimeFilter<"Tournament"> | Date | string
    endDate?: DateTimeFilter<"Tournament"> | Date | string
    startTime?: StringFilter<"Tournament"> | string
    endTime?: StringFilter<"Tournament"> | string
    maxTeams?: IntFilter<"Tournament"> | number
    teamSize?: IntFilter<"Tournament"> | number
    entryFee?: IntFilter<"Tournament"> | number
    location?: StringFilter<"Tournament"> | string
    isActive?: BoolFilter<"Tournament"> | boolean
    createdAt?: DateTimeFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeFilter<"Tournament"> | Date | string
    tournamentRegistration?: TournamentRegistrationListRelationFilter
  }, "id">

  export type TournamentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxTeams?: SortOrder
    teamSize?: SortOrder
    entryFee?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TournamentCountOrderByAggregateInput
    _avg?: TournamentAvgOrderByAggregateInput
    _max?: TournamentMaxOrderByAggregateInput
    _min?: TournamentMinOrderByAggregateInput
    _sum?: TournamentSumOrderByAggregateInput
  }

  export type TournamentScalarWhereWithAggregatesInput = {
    AND?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    OR?: TournamentScalarWhereWithAggregatesInput[]
    NOT?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tournament"> | string
    name?: StringWithAggregatesFilter<"Tournament"> | string
    description?: StringNullableWithAggregatesFilter<"Tournament"> | string | null
    rules?: StringNullableWithAggregatesFilter<"Tournament"> | string | null
    image?: StringNullableWithAggregatesFilter<"Tournament"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    startTime?: StringWithAggregatesFilter<"Tournament"> | string
    endTime?: StringWithAggregatesFilter<"Tournament"> | string
    maxTeams?: IntWithAggregatesFilter<"Tournament"> | number
    teamSize?: IntWithAggregatesFilter<"Tournament"> | number
    entryFee?: IntWithAggregatesFilter<"Tournament"> | number
    location?: StringWithAggregatesFilter<"Tournament"> | string
    isActive?: BoolWithAggregatesFilter<"Tournament"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
  }

  export type TournamentRegistrationWhereInput = {
    AND?: TournamentRegistrationWhereInput | TournamentRegistrationWhereInput[]
    OR?: TournamentRegistrationWhereInput[]
    NOT?: TournamentRegistrationWhereInput | TournamentRegistrationWhereInput[]
    id?: StringFilter<"TournamentRegistration"> | string
    tournamentId?: StringFilter<"TournamentRegistration"> | string
    clubId?: StringFilter<"TournamentRegistration"> | string
    members?: IntFilter<"TournamentRegistration"> | number
    totalFee?: IntFilter<"TournamentRegistration"> | number
    status?: EnumBookingStatusFilter<"TournamentRegistration"> | $Enums.BookingStatus
    createdAt?: DateTimeFilter<"TournamentRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"TournamentRegistration"> | Date | string
    paymentLockedUntil?: DateTimeNullableFilter<"TournamentRegistration"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"TournamentRegistration"> | Date | string | null
    cancellationReason?: StringNullableFilter<"TournamentRegistration"> | string | null
    tournament?: XOR<TournamentScalarRelationFilter, TournamentWhereInput>
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    membersRef?: TournamentRegistrationMemberListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type TournamentRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    clubId?: SortOrder
    members?: SortOrder
    totalFee?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentLockedUntil?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    tournament?: TournamentOrderByWithRelationInput
    club?: ClubOrderByWithRelationInput
    membersRef?: TournamentRegistrationMemberOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type TournamentRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TournamentRegistrationWhereInput | TournamentRegistrationWhereInput[]
    OR?: TournamentRegistrationWhereInput[]
    NOT?: TournamentRegistrationWhereInput | TournamentRegistrationWhereInput[]
    tournamentId?: StringFilter<"TournamentRegistration"> | string
    clubId?: StringFilter<"TournamentRegistration"> | string
    members?: IntFilter<"TournamentRegistration"> | number
    totalFee?: IntFilter<"TournamentRegistration"> | number
    status?: EnumBookingStatusFilter<"TournamentRegistration"> | $Enums.BookingStatus
    createdAt?: DateTimeFilter<"TournamentRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"TournamentRegistration"> | Date | string
    paymentLockedUntil?: DateTimeNullableFilter<"TournamentRegistration"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"TournamentRegistration"> | Date | string | null
    cancellationReason?: StringNullableFilter<"TournamentRegistration"> | string | null
    tournament?: XOR<TournamentScalarRelationFilter, TournamentWhereInput>
    club?: XOR<ClubScalarRelationFilter, ClubWhereInput>
    membersRef?: TournamentRegistrationMemberListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type TournamentRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    clubId?: SortOrder
    members?: SortOrder
    totalFee?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentLockedUntil?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    _count?: TournamentRegistrationCountOrderByAggregateInput
    _avg?: TournamentRegistrationAvgOrderByAggregateInput
    _max?: TournamentRegistrationMaxOrderByAggregateInput
    _min?: TournamentRegistrationMinOrderByAggregateInput
    _sum?: TournamentRegistrationSumOrderByAggregateInput
  }

  export type TournamentRegistrationScalarWhereWithAggregatesInput = {
    AND?: TournamentRegistrationScalarWhereWithAggregatesInput | TournamentRegistrationScalarWhereWithAggregatesInput[]
    OR?: TournamentRegistrationScalarWhereWithAggregatesInput[]
    NOT?: TournamentRegistrationScalarWhereWithAggregatesInput | TournamentRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TournamentRegistration"> | string
    tournamentId?: StringWithAggregatesFilter<"TournamentRegistration"> | string
    clubId?: StringWithAggregatesFilter<"TournamentRegistration"> | string
    members?: IntWithAggregatesFilter<"TournamentRegistration"> | number
    totalFee?: IntWithAggregatesFilter<"TournamentRegistration"> | number
    status?: EnumBookingStatusWithAggregatesFilter<"TournamentRegistration"> | $Enums.BookingStatus
    createdAt?: DateTimeWithAggregatesFilter<"TournamentRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TournamentRegistration"> | Date | string
    paymentLockedUntil?: DateTimeNullableWithAggregatesFilter<"TournamentRegistration"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"TournamentRegistration"> | Date | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"TournamentRegistration"> | string | null
  }

  export type TournamentRegistrationMemberWhereInput = {
    AND?: TournamentRegistrationMemberWhereInput | TournamentRegistrationMemberWhereInput[]
    OR?: TournamentRegistrationMemberWhereInput[]
    NOT?: TournamentRegistrationMemberWhereInput | TournamentRegistrationMemberWhereInput[]
    id?: StringFilter<"TournamentRegistrationMember"> | string
    tournamentRegistrationId?: StringFilter<"TournamentRegistrationMember"> | string
    userId?: StringFilter<"TournamentRegistrationMember"> | string
    isHost?: BoolFilter<"TournamentRegistrationMember"> | boolean
    createdAt?: DateTimeFilter<"TournamentRegistrationMember"> | Date | string
    updatedAt?: DateTimeFilter<"TournamentRegistrationMember"> | Date | string
    tournamentRegistration?: XOR<TournamentRegistrationScalarRelationFilter, TournamentRegistrationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TournamentRegistrationMemberOrderByWithRelationInput = {
    id?: SortOrder
    tournamentRegistrationId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tournamentRegistration?: TournamentRegistrationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TournamentRegistrationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tournamentRegistrationId_userId?: TournamentRegistrationMemberTournamentRegistrationIdUserIdCompoundUniqueInput
    AND?: TournamentRegistrationMemberWhereInput | TournamentRegistrationMemberWhereInput[]
    OR?: TournamentRegistrationMemberWhereInput[]
    NOT?: TournamentRegistrationMemberWhereInput | TournamentRegistrationMemberWhereInput[]
    tournamentRegistrationId?: StringFilter<"TournamentRegistrationMember"> | string
    userId?: StringFilter<"TournamentRegistrationMember"> | string
    isHost?: BoolFilter<"TournamentRegistrationMember"> | boolean
    createdAt?: DateTimeFilter<"TournamentRegistrationMember"> | Date | string
    updatedAt?: DateTimeFilter<"TournamentRegistrationMember"> | Date | string
    tournamentRegistration?: XOR<TournamentRegistrationScalarRelationFilter, TournamentRegistrationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "tournamentRegistrationId_userId">

  export type TournamentRegistrationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    tournamentRegistrationId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TournamentRegistrationMemberCountOrderByAggregateInput
    _max?: TournamentRegistrationMemberMaxOrderByAggregateInput
    _min?: TournamentRegistrationMemberMinOrderByAggregateInput
  }

  export type TournamentRegistrationMemberScalarWhereWithAggregatesInput = {
    AND?: TournamentRegistrationMemberScalarWhereWithAggregatesInput | TournamentRegistrationMemberScalarWhereWithAggregatesInput[]
    OR?: TournamentRegistrationMemberScalarWhereWithAggregatesInput[]
    NOT?: TournamentRegistrationMemberScalarWhereWithAggregatesInput | TournamentRegistrationMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TournamentRegistrationMember"> | string
    tournamentRegistrationId?: StringWithAggregatesFilter<"TournamentRegistrationMember"> | string
    userId?: StringWithAggregatesFilter<"TournamentRegistrationMember"> | string
    isHost?: BoolWithAggregatesFilter<"TournamentRegistrationMember"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TournamentRegistrationMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TournamentRegistrationMember"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingCreateNestedManyWithoutUserInput
    clubsLed?: ClubCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberCreateNestedManyWithoutUserInput
    invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingUncheckedCreateNestedManyWithoutUserInput
    clubsLed?: ClubUncheckedCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutUserInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUncheckedUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUncheckedUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUncheckedUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationCreateInput = {
    id?: string
    phone: string
    type?: $Enums.PhoneVerificationType | null
    code: string
    expiresAt: Date | string
    requestId: string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneVerificationUncheckedCreateInput = {
    id?: string
    phone: string
    type?: $Enums.PhoneVerificationType | null
    code: string
    expiresAt: Date | string
    requestId: string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumPhoneVerificationTypeFieldUpdateOperationsInput | $Enums.PhoneVerificationType | null
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestId?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumPhoneVerificationTypeFieldUpdateOperationsInput | $Enums.PhoneVerificationType | null
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestId?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationCreateManyInput = {
    id?: string
    phone: string
    type?: $Enums.PhoneVerificationType | null
    code: string
    expiresAt: Date | string
    requestId: string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhoneVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumPhoneVerificationTypeFieldUpdateOperationsInput | $Enums.PhoneVerificationType | null
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestId?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumPhoneVerificationTypeFieldUpdateOperationsInput | $Enums.PhoneVerificationType | null
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestId?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    image?: string | null
    name: string
    email: string
    phone?: string | null
    password: string
    isActive?: boolean
    joinedAt?: Date | string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutStaffInput
    slot?: SlotCreateNestedManyWithoutStaffInput
    coachTypeStaffPrice?: CoachTypeStaffPriceCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    image?: string | null
    name: string
    email: string
    phone?: string | null
    password: string
    isActive?: boolean
    joinedAt?: Date | string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutStaffInput
    slot?: SlotUncheckedCreateNestedManyWithoutStaffInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutStaffNestedInput
    slot?: SlotUpdateManyWithoutStaffNestedInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutStaffNestedInput
    slot?: SlotUncheckedUpdateManyWithoutStaffNestedInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffCreateManyInput = {
    id?: string
    image?: string | null
    name: string
    email: string
    phone?: string | null
    password: string
    isActive?: boolean
    joinedAt?: Date | string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthTokenCreateInput = {
    id?: string
    type?: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAuthTokensInput
    staff?: StaffCreateNestedOneWithoutAuthTokensInput
  }

  export type AuthTokenUncheckedCreateInput = {
    id?: string
    userId?: string | null
    staffId?: string | null
    type?: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuthTokensNestedInput
    staff?: StaffUpdateOneWithoutAuthTokensNestedInput
  }

  export type AuthTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthTokenCreateManyInput = {
    id?: string
    userId?: string | null
    staffId?: string | null
    type?: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateInput = {
    id?: string
    image: string
    link?: string | null
    isActive?: boolean
    startAt?: Date | string | null
    endAt?: Date | string | null
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    image: string
    link?: string | null
    isActive?: boolean
    startAt?: Date | string | null
    endAt?: Date | string | null
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateManyInput = {
    id?: string
    image: string
    link?: string | null
    isActive?: boolean
    startAt?: Date | string | null
    endAt?: Date | string | null
    sequence?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sequence?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    costSchedules?: CourtCostScheduleCreateNestedManyWithoutCourtInput
    bookingDetail?: BookingDetailCreateNestedManyWithoutCourtInput
    slot?: SlotCreateNestedManyWithoutCourtInput
  }

  export type CourtUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    costSchedules?: CourtCostScheduleUncheckedCreateNestedManyWithoutCourtInput
    bookingDetail?: BookingDetailUncheckedCreateNestedManyWithoutCourtInput
    slot?: SlotUncheckedCreateNestedManyWithoutCourtInput
  }

  export type CourtUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costSchedules?: CourtCostScheduleUpdateManyWithoutCourtNestedInput
    bookingDetail?: BookingDetailUpdateManyWithoutCourtNestedInput
    slot?: SlotUpdateManyWithoutCourtNestedInput
  }

  export type CourtUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costSchedules?: CourtCostScheduleUncheckedUpdateManyWithoutCourtNestedInput
    bookingDetail?: BookingDetailUncheckedUpdateManyWithoutCourtNestedInput
    slot?: SlotUncheckedUpdateManyWithoutCourtNestedInput
  }

  export type CourtCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourtUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingInventory?: BookingInventoryCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingInventory?: BookingInventoryUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingInventory?: BookingInventoryUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingInventory?: BookingInventoryUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotCreateInput = {
    id?: string
    type: $Enums.SlotType
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    court?: CourtCreateNestedOneWithoutSlotInput
    staff?: StaffCreateNestedOneWithoutSlotInput
    bookingDetails?: BookingDetailCreateNestedManyWithoutSlotInput
    bookingCoaches?: BookingCoachCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyCreateNestedManyWithoutSlotInput
  }

  export type SlotUncheckedCreateInput = {
    id?: string
    type: $Enums.SlotType
    courtId?: string | null
    staffId?: string | null
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingDetails?: BookingDetailUncheckedCreateNestedManyWithoutSlotInput
    bookingCoaches?: BookingCoachUncheckedCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyUncheckedCreateNestedManyWithoutSlotInput
  }

  export type SlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    court?: CourtUpdateOneWithoutSlotNestedInput
    staff?: StaffUpdateOneWithoutSlotNestedInput
    bookingDetails?: BookingDetailUpdateManyWithoutSlotNestedInput
    bookingCoaches?: BookingCoachUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUpdateManyWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingDetails?: BookingDetailUncheckedUpdateManyWithoutSlotNestedInput
    bookingCoaches?: BookingCoachUncheckedUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type SlotCreateManyInput = {
    id?: string
    type: $Enums.SlotType
    courtId?: string | null
    staffId?: string | null
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCostScheduleCreateInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    price: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    court: CourtCreateNestedOneWithoutCostSchedulesInput
  }

  export type CourtCostScheduleUncheckedCreateInput = {
    id?: string
    courtId: string
    startAt: Date | string
    endAt: Date | string
    price: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourtCostScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    court?: CourtUpdateOneRequiredWithoutCostSchedulesNestedInput
  }

  export type CourtCostScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCostScheduleCreateManyInput = {
    id?: string
    courtId: string
    startAt: Date | string
    endAt: Date | string
    price: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourtCostScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCostScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    name: string
    logo?: string | null
    fees?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    name: string
    logo?: string | null
    fees?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutMethodInput
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    name: string
    logo?: string | null
    fees?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    status?: $Enums.PaymentStatus
    amount: number
    fees?: number
    externalRef?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    method: PaymentMethodCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    paymentMethodId: string
    status?: $Enums.PaymentStatus
    amount: number
    fees?: number
    externalRef?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: IntFieldUpdateOperationsInput | number
    fees?: IntFieldUpdateOperationsInput | number
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: IntFieldUpdateOperationsInput | number
    fees?: IntFieldUpdateOperationsInput | number
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    paymentMethodId: string
    status?: $Enums.PaymentStatus
    amount: number
    fees?: number
    externalRef?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: IntFieldUpdateOperationsInput | number
    fees?: IntFieldUpdateOperationsInput | number
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: IntFieldUpdateOperationsInput | number
    fees?: IntFieldUpdateOperationsInput | number
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    number: string
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    user: UserCreateNestedOneWithoutInvoiceInput
    payment?: PaymentCreateNestedOneWithoutInvoiceInput
    booking?: BookingCreateNestedOneWithoutInvoiceInput
    classBooking?: ClassBookingCreateNestedOneWithoutInvoiceInput
    membershipUser?: MembershipUserCreateNestedOneWithoutInvoiceInput
    tournamentRegistration?: TournamentRegistrationCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    bookingId?: string | null
    classBookingId?: string | null
    membershipUserId?: string | null
    tournamentRegistrationId?: string | null
    number: string
    userId: string
    paymentId?: string | null
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    payment?: PaymentUpdateOneWithoutInvoiceNestedInput
    booking?: BookingUpdateOneWithoutInvoiceNestedInput
    classBooking?: ClassBookingUpdateOneWithoutInvoiceNestedInput
    membershipUser?: MembershipUserUpdateOneWithoutInvoiceNestedInput
    tournamentRegistration?: TournamentRegistrationUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    classBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceCreateManyInput = {
    id?: string
    bookingId?: string | null
    classBookingId?: string | null
    membershipUserId?: string | null
    tournamentRegistrationId?: string | null
    number: string
    userId: string
    paymentId?: string | null
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    classBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingCreateInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    user: UserCreateNestedOneWithoutBookingsInput
    details?: BookingDetailCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: BookingDetailUncheckedCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryUncheckedCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyUncheckedCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    details?: BookingDetailUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: BookingDetailUncheckedUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUncheckedUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUncheckedUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingDetailCreateInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutDetailsInput
    slot: SlotCreateNestedOneWithoutBookingDetailsInput
    court?: CourtCreateNestedOneWithoutBookingDetailInput
  }

  export type BookingDetailUncheckedCreateInput = {
    id?: string
    bookingId: string
    slotId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courtId?: string | null
  }

  export type BookingDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutDetailsNestedInput
    slot?: SlotUpdateOneRequiredWithoutBookingDetailsNestedInput
    court?: CourtUpdateOneWithoutBookingDetailNestedInput
  }

  export type BookingDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingDetailCreateManyInput = {
    id?: string
    bookingId: string
    slotId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courtId?: string | null
  }

  export type BookingDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingInventoryCreateInput = {
    id?: string
    quantity?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutInventoriesInput
    inventory: InventoryCreateNestedOneWithoutBookingInventoryInput
  }

  export type BookingInventoryUncheckedCreateInput = {
    id?: string
    bookingId: string
    inventoryId: string
    quantity?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingInventoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutInventoriesNestedInput
    inventory?: InventoryUpdateOneRequiredWithoutBookingInventoryNestedInput
  }

  export type BookingInventoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingInventoryCreateManyInput = {
    id?: string
    bookingId: string
    inventoryId: string
    quantity?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingInventoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingInventoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingBallboyCreateInput = {
    id?: string
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutBallboysInput
    slot: SlotCreateNestedOneWithoutBookingBallboysInput
  }

  export type BookingBallboyUncheckedCreateInput = {
    id?: string
    bookingId: string
    slotId: string
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingBallboyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutBallboysNestedInput
    slot?: SlotUpdateOneRequiredWithoutBookingBallboysNestedInput
  }

  export type BookingBallboyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingBallboyCreateManyInput = {
    id?: string
    bookingId: string
    slotId: string
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingBallboyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingBallboyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingCoach?: BookingCoachCreateNestedManyWithoutBookingCoachTypeInput
    coachTypeStaffPrice?: CoachTypeStaffPriceCreateNestedManyWithoutCoachTypeInput
  }

  export type BookingCoachTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingCoach?: BookingCoachUncheckedCreateNestedManyWithoutBookingCoachTypeInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedCreateNestedManyWithoutCoachTypeInput
  }

  export type BookingCoachTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingCoach?: BookingCoachUpdateManyWithoutBookingCoachTypeNestedInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUpdateManyWithoutCoachTypeNestedInput
  }

  export type BookingCoachTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingCoach?: BookingCoachUncheckedUpdateManyWithoutBookingCoachTypeNestedInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedUpdateManyWithoutCoachTypeNestedInput
  }

  export type BookingCoachTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCoachTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachTypeStaffPriceCreateInput = {
    id?: string
    basePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutCoachTypeStaffPriceInput
    coachType: BookingCoachTypeCreateNestedOneWithoutCoachTypeStaffPriceInput
  }

  export type CoachTypeStaffPriceUncheckedCreateInput = {
    id?: string
    staffId: string
    coachTypeId: string
    basePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachTypeStaffPriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutCoachTypeStaffPriceNestedInput
    coachType?: BookingCoachTypeUpdateOneRequiredWithoutCoachTypeStaffPriceNestedInput
  }

  export type CoachTypeStaffPriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    coachTypeId?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachTypeStaffPriceCreateManyInput = {
    id?: string
    staffId: string
    coachTypeId: string
    basePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachTypeStaffPriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachTypeStaffPriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    coachTypeId?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachCreateInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCoachesInput
    slot: SlotCreateNestedOneWithoutBookingCoachesInput
    bookingCoachType: BookingCoachTypeCreateNestedOneWithoutBookingCoachInput
  }

  export type BookingCoachUncheckedCreateInput = {
    id?: string
    bookingId: string
    slotId: string
    bookingCoachTypeId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCoachUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCoachesNestedInput
    slot?: SlotUpdateOneRequiredWithoutBookingCoachesNestedInput
    bookingCoachType?: BookingCoachTypeUpdateOneRequiredWithoutBookingCoachNestedInput
  }

  export type BookingCoachUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    bookingCoachTypeId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachCreateManyInput = {
    id?: string
    bookingId: string
    slotId: string
    bookingCoachTypeId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCoachUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    bookingCoachTypeId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    price: number
    sessions: number
    duration: number
    sequence?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    benefits?: MembershipBenefitCreateNestedManyWithoutMembershipInput
    membershipUser?: MembershipUserCreateNestedManyWithoutMembershipInput
  }

  export type MembershipUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    price: number
    sessions: number
    duration: number
    sequence?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    benefits?: MembershipBenefitUncheckedCreateNestedManyWithoutMembershipInput
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutMembershipInput
  }

  export type MembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: MembershipBenefitUpdateManyWithoutMembershipNestedInput
    membershipUser?: MembershipUserUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: MembershipBenefitUncheckedUpdateManyWithoutMembershipNestedInput
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    price: number
    sessions: number
    duration: number
    sequence?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipBenefitCreateInput = {
    id?: string
    benefit: string
    createdAt?: Date | string
    updatedAt?: Date | string
    membership: MembershipCreateNestedOneWithoutBenefitsInput
  }

  export type MembershipBenefitUncheckedCreateInput = {
    id?: string
    membershipId: string
    benefit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipBenefitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    benefit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipUpdateOneRequiredWithoutBenefitsNestedInput
  }

  export type MembershipBenefitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    benefit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipBenefitCreateManyInput = {
    id?: string
    membershipId: string
    benefit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipBenefitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    benefit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipBenefitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    benefit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUserCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipUserInput
    membership: MembershipCreateNestedOneWithoutMembershipUserInput
    invoice?: InvoiceCreateNestedOneWithoutMembershipUserInput
  }

  export type MembershipUserUncheckedCreateInput = {
    id?: string
    userId: string
    membershipId: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutMembershipUserInput
  }

  export type MembershipUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipUserNestedInput
    membership?: MembershipUpdateOneRequiredWithoutMembershipUserNestedInput
    invoice?: InvoiceUpdateOneWithoutMembershipUserNestedInput
  }

  export type MembershipUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutMembershipUserNestedInput
  }

  export type MembershipUserCreateManyInput = {
    id?: string
    userId: string
    membershipId: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    organizerName?: string | null
    speakerName?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    price: number
    sessions: number
    capacity: number
    remaining: number
    maxBookingPax?: number
    gender?: $Enums.Gender
    ageMin: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    classBookings?: ClassBookingCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    organizerName?: string | null
    speakerName?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    price: number
    sessions: number
    capacity: number
    remaining: number
    maxBookingPax?: number
    gender?: $Enums.Gender
    ageMin: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    classBookings?: ClassBookingUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    organizerName?: NullableStringFieldUpdateOperationsInput | string | null
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    remaining?: IntFieldUpdateOperationsInput | number
    maxBookingPax?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    ageMin?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classBookings?: ClassBookingUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    organizerName?: NullableStringFieldUpdateOperationsInput | string | null
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    remaining?: IntFieldUpdateOperationsInput | number
    maxBookingPax?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    ageMin?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classBookings?: ClassBookingUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    organizerName?: string | null
    speakerName?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    price: number
    sessions: number
    capacity: number
    remaining: number
    maxBookingPax?: number
    gender?: $Enums.Gender
    ageMin: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    organizerName?: NullableStringFieldUpdateOperationsInput | string | null
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    remaining?: IntFieldUpdateOperationsInput | number
    maxBookingPax?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    ageMin?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    organizerName?: NullableStringFieldUpdateOperationsInput | string | null
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    remaining?: IntFieldUpdateOperationsInput | number
    maxBookingPax?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    ageMin?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingCreateInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    class: ClassCreateNestedOneWithoutClassBookingsInput
    user: UserCreateNestedOneWithoutClassBookingsInput
    details?: ClassBookingDetailCreateNestedManyWithoutClassBookingInput
    invoice?: InvoiceCreateNestedOneWithoutClassBookingInput
  }

  export type ClassBookingUncheckedCreateInput = {
    id?: string
    classId: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: ClassBookingDetailUncheckedCreateNestedManyWithoutClassBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutClassBookingInput
  }

  export type ClassBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutClassBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutClassBookingsNestedInput
    details?: ClassBookingDetailUpdateManyWithoutClassBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutClassBookingNestedInput
  }

  export type ClassBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: ClassBookingDetailUncheckedUpdateManyWithoutClassBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutClassBookingNestedInput
  }

  export type ClassBookingCreateManyInput = {
    id?: string
    classId: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
  }

  export type ClassBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassBookingDetailCreateInput = {
    id?: string
    date: Date | string
    time: string
    price: number
    attendance?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    classBooking: ClassBookingCreateNestedOneWithoutDetailsInput
  }

  export type ClassBookingDetailUncheckedCreateInput = {
    id?: string
    classBookingId: string
    date: Date | string
    time: string
    price: number
    attendance?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassBookingDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    attendance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classBooking?: ClassBookingUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type ClassBookingDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classBookingId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    attendance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingDetailCreateManyInput = {
    id?: string
    classBookingId: string
    date: Date | string
    time: string
    price: number
    attendance?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassBookingDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    attendance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classBookingId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    attendance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubCreateInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutClubsLedInput
    clubMember?: ClubMemberCreateNestedManyWithoutClubInput
    tournamentRegistration?: TournamentRegistrationCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    leaderId: string
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutClubInput
    tournamentRegistration?: TournamentRegistrationUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutClubsLedNestedInput
    clubMember?: ClubMemberUpdateManyWithoutClubNestedInput
    tournamentRegistration?: TournamentRegistrationUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubMember?: ClubMemberUncheckedUpdateManyWithoutClubNestedInput
    tournamentRegistration?: TournamentRegistrationUncheckedUpdateManyWithoutClubNestedInput
  }

  export type ClubCreateManyInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    leaderId: string
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClubUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubMemberCreateInput = {
    id?: string
    joinedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    club: ClubCreateNestedOneWithoutClubMemberInput
    user: UserCreateNestedOneWithoutClubMemberInput
  }

  export type ClubMemberUncheckedCreateInput = {
    id?: string
    clubId: string
    userId: string
    joinedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClubMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneRequiredWithoutClubMemberNestedInput
    user?: UserUpdateOneRequiredWithoutClubMemberNestedInput
  }

  export type ClubMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubMemberCreateManyInput = {
    id?: string
    clubId: string
    userId: string
    joinedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClubMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentCreateInput = {
    id?: string
    name: string
    description?: string | null
    rules?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    maxTeams: number
    teamSize: number
    entryFee: number
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentRegistration?: TournamentRegistrationCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    rules?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    maxTeams: number
    teamSize: number
    entryFee: number
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentRegistration?: TournamentRegistrationUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentRegistration?: TournamentRegistrationUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentRegistration?: TournamentRegistrationUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    rules?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    maxTeams: number
    teamSize: number
    entryFee: number
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentRegistrationCreateInput = {
    id?: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    tournament: TournamentCreateNestedOneWithoutTournamentRegistrationInput
    club: ClubCreateNestedOneWithoutTournamentRegistrationInput
    membersRef?: TournamentRegistrationMemberCreateNestedManyWithoutTournamentRegistrationInput
    invoice?: InvoiceCreateNestedOneWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationUncheckedCreateInput = {
    id?: string
    tournamentId: string
    clubId: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    membersRef?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutTournamentRegistrationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    tournament?: TournamentUpdateOneRequiredWithoutTournamentRegistrationNestedInput
    club?: ClubUpdateOneRequiredWithoutTournamentRegistrationNestedInput
    membersRef?: TournamentRegistrationMemberUpdateManyWithoutTournamentRegistrationNestedInput
    invoice?: InvoiceUpdateOneWithoutTournamentRegistrationNestedInput
  }

  export type TournamentRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    membersRef?: TournamentRegistrationMemberUncheckedUpdateManyWithoutTournamentRegistrationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTournamentRegistrationNestedInput
  }

  export type TournamentRegistrationCreateManyInput = {
    id?: string
    tournamentId: string
    clubId: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
  }

  export type TournamentRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TournamentRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TournamentRegistrationMemberCreateInput = {
    id?: string
    isHost?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentRegistration: TournamentRegistrationCreateNestedOneWithoutMembersRefInput
    user: UserCreateNestedOneWithoutTournamentRegistrationMemberInput
  }

  export type TournamentRegistrationMemberUncheckedCreateInput = {
    id?: string
    tournamentRegistrationId: string
    userId: string
    isHost?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentRegistrationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentRegistration?: TournamentRegistrationUpdateOneRequiredWithoutMembersRefNestedInput
    user?: UserUpdateOneRequiredWithoutTournamentRegistrationMemberNestedInput
  }

  export type TournamentRegistrationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentRegistrationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentRegistrationMemberCreateManyInput = {
    id?: string
    tournamentRegistrationId: string
    userId: string
    isHost?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentRegistrationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentRegistrationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentRegistrationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AuthTokenListRelationFilter = {
    every?: AuthTokenWhereInput
    some?: AuthTokenWhereInput
    none?: AuthTokenWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type MembershipUserListRelationFilter = {
    every?: MembershipUserWhereInput
    some?: MembershipUserWhereInput
    none?: MembershipUserWhereInput
  }

  export type ClassBookingListRelationFilter = {
    every?: ClassBookingWhereInput
    some?: ClassBookingWhereInput
    none?: ClassBookingWhereInput
  }

  export type ClubListRelationFilter = {
    every?: ClubWhereInput
    some?: ClubWhereInput
    none?: ClubWhereInput
  }

  export type ClubMemberListRelationFilter = {
    every?: ClubMemberWhereInput
    some?: ClubMemberWhereInput
    none?: ClubMemberWhereInput
  }

  export type TournamentRegistrationMemberListRelationFilter = {
    every?: TournamentRegistrationMemberWhereInput
    some?: TournamentRegistrationMemberWhereInput
    none?: TournamentRegistrationMemberWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuthTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TournamentRegistrationMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    googleId?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    googleId?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    googleId?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPhoneVerificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneVerificationType | EnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PhoneVerificationType[] | ListEnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PhoneVerificationType[] | ListEnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPhoneVerificationTypeNullableFilter<$PrismaModel> | $Enums.PhoneVerificationType | null
  }

  export type PhoneVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    type?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    requestId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhoneVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    type?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    requestId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhoneVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    type?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    requestId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPhoneVerificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneVerificationType | EnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PhoneVerificationType[] | ListEnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PhoneVerificationType[] | ListEnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPhoneVerificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PhoneVerificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPhoneVerificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPhoneVerificationTypeNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type SlotListRelationFilter = {
    every?: SlotWhereInput
    some?: SlotWhereInput
    none?: SlotWhereInput
  }

  export type CoachTypeStaffPriceListRelationFilter = {
    every?: CoachTypeStaffPriceWhereInput
    some?: CoachTypeStaffPriceWhereInput
    none?: CoachTypeStaffPriceWhereInput
  }

  export type SlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachTypeStaffPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumAuthTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthTokenType | EnumAuthTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthTokenType[] | ListEnumAuthTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthTokenType[] | ListEnumAuthTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTokenTypeFilter<$PrismaModel> | $Enums.AuthTokenType
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StaffNullableScalarRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type AuthTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    staffId?: SortOrder
    type?: SortOrder
    refreshToken?: SortOrder
    refreshExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    staffId?: SortOrder
    type?: SortOrder
    refreshToken?: SortOrder
    refreshExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    staffId?: SortOrder
    type?: SortOrder
    refreshToken?: SortOrder
    refreshExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuthTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthTokenType | EnumAuthTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthTokenType[] | ListEnumAuthTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthTokenType[] | ListEnumAuthTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthTokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthTokenTypeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    link?: SortOrder
    isActive?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerAvgOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    link?: SortOrder
    isActive?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    link?: SortOrder
    isActive?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    sequence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerSumOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CourtCostScheduleListRelationFilter = {
    every?: CourtCostScheduleWhereInput
    some?: CourtCostScheduleWhereInput
    none?: CourtCostScheduleWhereInput
  }

  export type BookingDetailListRelationFilter = {
    every?: BookingDetailWhereInput
    some?: BookingDetailWhereInput
    none?: BookingDetailWhereInput
  }

  export type CourtCostScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourtCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingInventoryListRelationFilter = {
    every?: BookingInventoryWhereInput
    some?: BookingInventoryWhereInput
    none?: BookingInventoryWhereInput
  }

  export type BookingInventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type CourtNullableScalarRelationFilter = {
    is?: CourtWhereInput | null
    isNot?: CourtWhereInput | null
  }

  export type BookingCoachListRelationFilter = {
    every?: BookingCoachWhereInput
    some?: BookingCoachWhereInput
    none?: BookingCoachWhereInput
  }

  export type BookingBallboyListRelationFilter = {
    every?: BookingBallboyWhereInput
    some?: BookingBallboyWhereInput
    none?: BookingBallboyWhereInput
  }

  export type BookingCoachOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingBallboyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SlotCourtIdStartAtCompoundUniqueInput = {
    courtId: string
    startAt: Date | string
  }

  export type SlotStaffIdStartAtCompoundUniqueInput = {
    staffId: string
    startAt: Date | string
  }

  export type SlotCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    courtId?: SortOrder
    staffId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type SlotMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    courtId?: SortOrder
    staffId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    courtId?: SortOrder
    staffId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlotSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type CourtScalarRelationFilter = {
    is?: CourtWhereInput
    isNot?: CourtWhereInput
  }

  export type CourtCostScheduleCourtIdStartAtCompoundUniqueInput = {
    courtId: string
    startAt: Date | string
  }

  export type CourtCostScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    courtId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtCostScheduleAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CourtCostScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    courtId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtCostScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    courtId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtCostScheduleSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    fees?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    fees?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    fees?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    fees?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    fees?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PaymentMethodScalarRelationFilter = {
    is?: PaymentMethodWhereInput
    isNot?: PaymentMethodWhereInput
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentMethodId?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    externalRef?: SortOrder
    meta?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    fees?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentMethodId?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    externalRef?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentMethodId?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    externalRef?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    fees?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type ClassBookingNullableScalarRelationFilter = {
    is?: ClassBookingWhereInput | null
    isNot?: ClassBookingWhereInput | null
  }

  export type MembershipUserNullableScalarRelationFilter = {
    is?: MembershipUserWhereInput | null
    isNot?: MembershipUserWhereInput | null
  }

  export type TournamentRegistrationNullableScalarRelationFilter = {
    is?: TournamentRegistrationWhereInput | null
    isNot?: TournamentRegistrationWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    classBookingId?: SortOrder
    membershipUserId?: SortOrder
    tournamentRegistrationId?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    subtotal?: SortOrder
    processingFee?: SortOrder
    total?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    processingFee?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    classBookingId?: SortOrder
    membershipUserId?: SortOrder
    tournamentRegistrationId?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    subtotal?: SortOrder
    processingFee?: SortOrder
    total?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    classBookingId?: SortOrder
    membershipUserId?: SortOrder
    tournamentRegistrationId?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    paymentId?: SortOrder
    subtotal?: SortOrder
    processingFee?: SortOrder
    total?: SortOrder
    status?: SortOrder
    issuedAt?: SortOrder
    dueDate?: SortOrder
    paidAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    processingFee?: SortOrder
    total?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiresAt?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    processingFee?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiresAt?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    holdExpiresAt?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    processingFee?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type SlotScalarRelationFilter = {
    is?: SlotWhereInput
    isNot?: SlotWhereInput
  }

  export type BookingDetailCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courtId?: SortOrder
  }

  export type BookingDetailAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BookingDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courtId?: SortOrder
  }

  export type BookingDetailMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courtId?: SortOrder
  }

  export type BookingDetailSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type InventoryScalarRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type BookingInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingInventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type BookingInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    inventoryId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingInventorySumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type BookingBallboyCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingBallboyAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BookingBallboyMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingBallboyMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingBallboySumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BookingCoachTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingCoachTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingCoachTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StaffScalarRelationFilter = {
    is?: StaffWhereInput
    isNot?: StaffWhereInput
  }

  export type BookingCoachTypeScalarRelationFilter = {
    is?: BookingCoachTypeWhereInput
    isNot?: BookingCoachTypeWhereInput
  }

  export type CoachTypeStaffPriceStaffIdCoachTypeIdCompoundUniqueInput = {
    staffId: string
    coachTypeId: string
  }

  export type CoachTypeStaffPriceCountOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    coachTypeId?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachTypeStaffPriceAvgOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type CoachTypeStaffPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    coachTypeId?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachTypeStaffPriceMinOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    coachTypeId?: SortOrder
    basePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachTypeStaffPriceSumOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BookingCoachCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    bookingCoachTypeId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingCoachAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BookingCoachMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    bookingCoachTypeId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingCoachMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    slotId?: SortOrder
    bookingCoachTypeId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingCoachSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type MembershipBenefitListRelationFilter = {
    every?: MembershipBenefitWhereInput
    some?: MembershipBenefitWhereInput
    none?: MembershipBenefitWhereInput
  }

  export type MembershipBenefitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    price?: SortOrder
    sessions?: SortOrder
    duration?: SortOrder
    sequence?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipAvgOrderByAggregateInput = {
    price?: SortOrder
    sessions?: SortOrder
    duration?: SortOrder
    sequence?: SortOrder
  }

  export type MembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    price?: SortOrder
    sessions?: SortOrder
    duration?: SortOrder
    sequence?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    price?: SortOrder
    sessions?: SortOrder
    duration?: SortOrder
    sequence?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipSumOrderByAggregateInput = {
    price?: SortOrder
    sessions?: SortOrder
    duration?: SortOrder
    sequence?: SortOrder
  }

  export type MembershipScalarRelationFilter = {
    is?: MembershipWhereInput
    isNot?: MembershipWhereInput
  }

  export type MembershipBenefitCountOrderByAggregateInput = {
    id?: SortOrder
    membershipId?: SortOrder
    benefit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipBenefitMaxOrderByAggregateInput = {
    id?: SortOrder
    membershipId?: SortOrder
    benefit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipBenefitMinOrderByAggregateInput = {
    id?: SortOrder
    membershipId?: SortOrder
    benefit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    membershipId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    remainingSessions?: SortOrder
    remainingDuration?: SortOrder
    isExpired?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrder
    suspensionEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipUserAvgOrderByAggregateInput = {
    remainingSessions?: SortOrder
    remainingDuration?: SortOrder
  }

  export type MembershipUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    membershipId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    remainingSessions?: SortOrder
    remainingDuration?: SortOrder
    isExpired?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrder
    suspensionEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    membershipId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    remainingSessions?: SortOrder
    remainingDuration?: SortOrder
    isExpired?: SortOrder
    isSuspended?: SortOrder
    suspensionReason?: SortOrder
    suspensionEndDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipUserSumOrderByAggregateInput = {
    remainingSessions?: SortOrder
    remainingDuration?: SortOrder
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    organizerName?: SortOrder
    speakerName?: SortOrder
    image?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    price?: SortOrder
    sessions?: SortOrder
    capacity?: SortOrder
    remaining?: SortOrder
    maxBookingPax?: SortOrder
    gender?: SortOrder
    ageMin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    price?: SortOrder
    sessions?: SortOrder
    capacity?: SortOrder
    remaining?: SortOrder
    maxBookingPax?: SortOrder
    ageMin?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    organizerName?: SortOrder
    speakerName?: SortOrder
    image?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    price?: SortOrder
    sessions?: SortOrder
    capacity?: SortOrder
    remaining?: SortOrder
    maxBookingPax?: SortOrder
    gender?: SortOrder
    ageMin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    content?: SortOrder
    organizerName?: SortOrder
    speakerName?: SortOrder
    image?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    price?: SortOrder
    sessions?: SortOrder
    capacity?: SortOrder
    remaining?: SortOrder
    maxBookingPax?: SortOrder
    gender?: SortOrder
    ageMin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    price?: SortOrder
    sessions?: SortOrder
    capacity?: SortOrder
    remaining?: SortOrder
    maxBookingPax?: SortOrder
    ageMin?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type ClassBookingDetailListRelationFilter = {
    every?: ClassBookingDetailWhereInput
    some?: ClassBookingDetailWhereInput
    none?: ClassBookingDetailWhereInput
  }

  export type ClassBookingDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassBookingCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
  }

  export type ClassBookingAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
    processingFee?: SortOrder
  }

  export type ClassBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
  }

  export type ClassBookingMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalPrice?: SortOrder
    processingFee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
  }

  export type ClassBookingSumOrderByAggregateInput = {
    totalPrice?: SortOrder
    processingFee?: SortOrder
  }

  export type ClassBookingScalarRelationFilter = {
    is?: ClassBookingWhereInput
    isNot?: ClassBookingWhereInput
  }

  export type ClassBookingDetailCountOrderByAggregateInput = {
    id?: SortOrder
    classBookingId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    price?: SortOrder
    attendance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassBookingDetailAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ClassBookingDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    classBookingId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    price?: SortOrder
    attendance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassBookingDetailMinOrderByAggregateInput = {
    id?: SortOrder
    classBookingId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    price?: SortOrder
    attendance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassBookingDetailSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumClubVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubVisibility | EnumClubVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ClubVisibility[] | ListEnumClubVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClubVisibility[] | ListEnumClubVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumClubVisibilityFilter<$PrismaModel> | $Enums.ClubVisibility
  }

  export type TournamentRegistrationListRelationFilter = {
    every?: TournamentRegistrationWhereInput
    some?: TournamentRegistrationWhereInput
    none?: TournamentRegistrationWhereInput
  }

  export type TournamentRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClubCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    leaderId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClubMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    leaderId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClubMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    leaderId?: SortOrder
    visibility?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClubVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubVisibility | EnumClubVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ClubVisibility[] | ListEnumClubVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClubVisibility[] | ListEnumClubVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumClubVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ClubVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClubVisibilityFilter<$PrismaModel>
    _max?: NestedEnumClubVisibilityFilter<$PrismaModel>
  }

  export type ClubScalarRelationFilter = {
    is?: ClubWhereInput
    isNot?: ClubWhereInput
  }

  export type ClubMemberClubIdUserIdCompoundUniqueInput = {
    clubId: string
    userId: string
  }

  export type ClubMemberCountOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClubMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClubMemberMinOrderByAggregateInput = {
    id?: SortOrder
    clubId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TournamentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    image?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxTeams?: SortOrder
    teamSize?: SortOrder
    entryFee?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TournamentAvgOrderByAggregateInput = {
    maxTeams?: SortOrder
    teamSize?: SortOrder
    entryFee?: SortOrder
  }

  export type TournamentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    image?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxTeams?: SortOrder
    teamSize?: SortOrder
    entryFee?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TournamentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    image?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxTeams?: SortOrder
    teamSize?: SortOrder
    entryFee?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TournamentSumOrderByAggregateInput = {
    maxTeams?: SortOrder
    teamSize?: SortOrder
    entryFee?: SortOrder
  }

  export type TournamentScalarRelationFilter = {
    is?: TournamentWhereInput
    isNot?: TournamentWhereInput
  }

  export type TournamentRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    clubId?: SortOrder
    members?: SortOrder
    totalFee?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentLockedUntil?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
  }

  export type TournamentRegistrationAvgOrderByAggregateInput = {
    members?: SortOrder
    totalFee?: SortOrder
  }

  export type TournamentRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    clubId?: SortOrder
    members?: SortOrder
    totalFee?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentLockedUntil?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
  }

  export type TournamentRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    clubId?: SortOrder
    members?: SortOrder
    totalFee?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentLockedUntil?: SortOrder
    cancelledAt?: SortOrder
    cancellationReason?: SortOrder
  }

  export type TournamentRegistrationSumOrderByAggregateInput = {
    members?: SortOrder
    totalFee?: SortOrder
  }

  export type TournamentRegistrationScalarRelationFilter = {
    is?: TournamentRegistrationWhereInput
    isNot?: TournamentRegistrationWhereInput
  }

  export type TournamentRegistrationMemberTournamentRegistrationIdUserIdCompoundUniqueInput = {
    tournamentRegistrationId: string
    userId: string
  }

  export type TournamentRegistrationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    tournamentRegistrationId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TournamentRegistrationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    tournamentRegistrationId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TournamentRegistrationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    tournamentRegistrationId?: SortOrder
    userId?: SortOrder
    isHost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthTokenCreateWithoutUserInput, AuthTokenUncheckedCreateWithoutUserInput> | AuthTokenCreateWithoutUserInput[] | AuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthTokenCreateOrConnectWithoutUserInput | AuthTokenCreateOrConnectWithoutUserInput[]
    createMany?: AuthTokenCreateManyUserInputEnvelope
    connect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type MembershipUserCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipUserCreateWithoutUserInput, MembershipUserUncheckedCreateWithoutUserInput> | MembershipUserCreateWithoutUserInput[] | MembershipUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipUserCreateOrConnectWithoutUserInput | MembershipUserCreateOrConnectWithoutUserInput[]
    createMany?: MembershipUserCreateManyUserInputEnvelope
    connect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
  }

  export type ClassBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<ClassBookingCreateWithoutUserInput, ClassBookingUncheckedCreateWithoutUserInput> | ClassBookingCreateWithoutUserInput[] | ClassBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutUserInput | ClassBookingCreateOrConnectWithoutUserInput[]
    createMany?: ClassBookingCreateManyUserInputEnvelope
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
  }

  export type ClubCreateNestedManyWithoutLeaderInput = {
    create?: XOR<ClubCreateWithoutLeaderInput, ClubUncheckedCreateWithoutLeaderInput> | ClubCreateWithoutLeaderInput[] | ClubUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutLeaderInput | ClubCreateOrConnectWithoutLeaderInput[]
    createMany?: ClubCreateManyLeaderInputEnvelope
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
  }

  export type ClubMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ClubMemberCreateWithoutUserInput, ClubMemberUncheckedCreateWithoutUserInput> | ClubMemberCreateWithoutUserInput[] | ClubMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubMemberCreateOrConnectWithoutUserInput | ClubMemberCreateOrConnectWithoutUserInput[]
    createMany?: ClubMemberCreateManyUserInputEnvelope
    connect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
  }

  export type TournamentRegistrationMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TournamentRegistrationMemberCreateWithoutUserInput, TournamentRegistrationMemberUncheckedCreateWithoutUserInput> | TournamentRegistrationMemberCreateWithoutUserInput[] | TournamentRegistrationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentRegistrationMemberCreateOrConnectWithoutUserInput | TournamentRegistrationMemberCreateOrConnectWithoutUserInput[]
    createMany?: TournamentRegistrationMemberCreateManyUserInputEnvelope
    connect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type AuthTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthTokenCreateWithoutUserInput, AuthTokenUncheckedCreateWithoutUserInput> | AuthTokenCreateWithoutUserInput[] | AuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthTokenCreateOrConnectWithoutUserInput | AuthTokenCreateOrConnectWithoutUserInput[]
    createMany?: AuthTokenCreateManyUserInputEnvelope
    connect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type MembershipUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipUserCreateWithoutUserInput, MembershipUserUncheckedCreateWithoutUserInput> | MembershipUserCreateWithoutUserInput[] | MembershipUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipUserCreateOrConnectWithoutUserInput | MembershipUserCreateOrConnectWithoutUserInput[]
    createMany?: MembershipUserCreateManyUserInputEnvelope
    connect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
  }

  export type ClassBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClassBookingCreateWithoutUserInput, ClassBookingUncheckedCreateWithoutUserInput> | ClassBookingCreateWithoutUserInput[] | ClassBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutUserInput | ClassBookingCreateOrConnectWithoutUserInput[]
    createMany?: ClassBookingCreateManyUserInputEnvelope
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
  }

  export type ClubUncheckedCreateNestedManyWithoutLeaderInput = {
    create?: XOR<ClubCreateWithoutLeaderInput, ClubUncheckedCreateWithoutLeaderInput> | ClubCreateWithoutLeaderInput[] | ClubUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutLeaderInput | ClubCreateOrConnectWithoutLeaderInput[]
    createMany?: ClubCreateManyLeaderInputEnvelope
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
  }

  export type ClubMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClubMemberCreateWithoutUserInput, ClubMemberUncheckedCreateWithoutUserInput> | ClubMemberCreateWithoutUserInput[] | ClubMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubMemberCreateOrConnectWithoutUserInput | ClubMemberCreateOrConnectWithoutUserInput[]
    createMany?: ClubMemberCreateManyUserInputEnvelope
    connect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
  }

  export type TournamentRegistrationMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TournamentRegistrationMemberCreateWithoutUserInput, TournamentRegistrationMemberUncheckedCreateWithoutUserInput> | TournamentRegistrationMemberCreateWithoutUserInput[] | TournamentRegistrationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentRegistrationMemberCreateOrConnectWithoutUserInput | TournamentRegistrationMemberCreateOrConnectWithoutUserInput[]
    createMany?: TournamentRegistrationMemberCreateManyUserInputEnvelope
    connect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AuthTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthTokenCreateWithoutUserInput, AuthTokenUncheckedCreateWithoutUserInput> | AuthTokenCreateWithoutUserInput[] | AuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthTokenCreateOrConnectWithoutUserInput | AuthTokenCreateOrConnectWithoutUserInput[]
    upsert?: AuthTokenUpsertWithWhereUniqueWithoutUserInput | AuthTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthTokenCreateManyUserInputEnvelope
    set?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    disconnect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    delete?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    connect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    update?: AuthTokenUpdateWithWhereUniqueWithoutUserInput | AuthTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthTokenUpdateManyWithWhereWithoutUserInput | AuthTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthTokenScalarWhereInput | AuthTokenScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type MembershipUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipUserCreateWithoutUserInput, MembershipUserUncheckedCreateWithoutUserInput> | MembershipUserCreateWithoutUserInput[] | MembershipUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipUserCreateOrConnectWithoutUserInput | MembershipUserCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUserUpsertWithWhereUniqueWithoutUserInput | MembershipUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipUserCreateManyUserInputEnvelope
    set?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    disconnect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    delete?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    connect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    update?: MembershipUserUpdateWithWhereUniqueWithoutUserInput | MembershipUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUserUpdateManyWithWhereWithoutUserInput | MembershipUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipUserScalarWhereInput | MembershipUserScalarWhereInput[]
  }

  export type ClassBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClassBookingCreateWithoutUserInput, ClassBookingUncheckedCreateWithoutUserInput> | ClassBookingCreateWithoutUserInput[] | ClassBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutUserInput | ClassBookingCreateOrConnectWithoutUserInput[]
    upsert?: ClassBookingUpsertWithWhereUniqueWithoutUserInput | ClassBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClassBookingCreateManyUserInputEnvelope
    set?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    disconnect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    delete?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    update?: ClassBookingUpdateWithWhereUniqueWithoutUserInput | ClassBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClassBookingUpdateManyWithWhereWithoutUserInput | ClassBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
  }

  export type ClubUpdateManyWithoutLeaderNestedInput = {
    create?: XOR<ClubCreateWithoutLeaderInput, ClubUncheckedCreateWithoutLeaderInput> | ClubCreateWithoutLeaderInput[] | ClubUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutLeaderInput | ClubCreateOrConnectWithoutLeaderInput[]
    upsert?: ClubUpsertWithWhereUniqueWithoutLeaderInput | ClubUpsertWithWhereUniqueWithoutLeaderInput[]
    createMany?: ClubCreateManyLeaderInputEnvelope
    set?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    disconnect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    delete?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    update?: ClubUpdateWithWhereUniqueWithoutLeaderInput | ClubUpdateWithWhereUniqueWithoutLeaderInput[]
    updateMany?: ClubUpdateManyWithWhereWithoutLeaderInput | ClubUpdateManyWithWhereWithoutLeaderInput[]
    deleteMany?: ClubScalarWhereInput | ClubScalarWhereInput[]
  }

  export type ClubMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClubMemberCreateWithoutUserInput, ClubMemberUncheckedCreateWithoutUserInput> | ClubMemberCreateWithoutUserInput[] | ClubMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubMemberCreateOrConnectWithoutUserInput | ClubMemberCreateOrConnectWithoutUserInput[]
    upsert?: ClubMemberUpsertWithWhereUniqueWithoutUserInput | ClubMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClubMemberCreateManyUserInputEnvelope
    set?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    disconnect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    delete?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    connect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    update?: ClubMemberUpdateWithWhereUniqueWithoutUserInput | ClubMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClubMemberUpdateManyWithWhereWithoutUserInput | ClubMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClubMemberScalarWhereInput | ClubMemberScalarWhereInput[]
  }

  export type TournamentRegistrationMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TournamentRegistrationMemberCreateWithoutUserInput, TournamentRegistrationMemberUncheckedCreateWithoutUserInput> | TournamentRegistrationMemberCreateWithoutUserInput[] | TournamentRegistrationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentRegistrationMemberCreateOrConnectWithoutUserInput | TournamentRegistrationMemberCreateOrConnectWithoutUserInput[]
    upsert?: TournamentRegistrationMemberUpsertWithWhereUniqueWithoutUserInput | TournamentRegistrationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TournamentRegistrationMemberCreateManyUserInputEnvelope
    set?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    disconnect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    delete?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    connect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    update?: TournamentRegistrationMemberUpdateWithWhereUniqueWithoutUserInput | TournamentRegistrationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TournamentRegistrationMemberUpdateManyWithWhereWithoutUserInput | TournamentRegistrationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TournamentRegistrationMemberScalarWhereInput | TournamentRegistrationMemberScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type AuthTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthTokenCreateWithoutUserInput, AuthTokenUncheckedCreateWithoutUserInput> | AuthTokenCreateWithoutUserInput[] | AuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthTokenCreateOrConnectWithoutUserInput | AuthTokenCreateOrConnectWithoutUserInput[]
    upsert?: AuthTokenUpsertWithWhereUniqueWithoutUserInput | AuthTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthTokenCreateManyUserInputEnvelope
    set?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    disconnect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    delete?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    connect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    update?: AuthTokenUpdateWithWhereUniqueWithoutUserInput | AuthTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthTokenUpdateManyWithWhereWithoutUserInput | AuthTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthTokenScalarWhereInput | AuthTokenScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type MembershipUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipUserCreateWithoutUserInput, MembershipUserUncheckedCreateWithoutUserInput> | MembershipUserCreateWithoutUserInput[] | MembershipUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipUserCreateOrConnectWithoutUserInput | MembershipUserCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUserUpsertWithWhereUniqueWithoutUserInput | MembershipUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipUserCreateManyUserInputEnvelope
    set?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    disconnect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    delete?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    connect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    update?: MembershipUserUpdateWithWhereUniqueWithoutUserInput | MembershipUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUserUpdateManyWithWhereWithoutUserInput | MembershipUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipUserScalarWhereInput | MembershipUserScalarWhereInput[]
  }

  export type ClassBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClassBookingCreateWithoutUserInput, ClassBookingUncheckedCreateWithoutUserInput> | ClassBookingCreateWithoutUserInput[] | ClassBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutUserInput | ClassBookingCreateOrConnectWithoutUserInput[]
    upsert?: ClassBookingUpsertWithWhereUniqueWithoutUserInput | ClassBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClassBookingCreateManyUserInputEnvelope
    set?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    disconnect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    delete?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    update?: ClassBookingUpdateWithWhereUniqueWithoutUserInput | ClassBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClassBookingUpdateManyWithWhereWithoutUserInput | ClassBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
  }

  export type ClubUncheckedUpdateManyWithoutLeaderNestedInput = {
    create?: XOR<ClubCreateWithoutLeaderInput, ClubUncheckedCreateWithoutLeaderInput> | ClubCreateWithoutLeaderInput[] | ClubUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: ClubCreateOrConnectWithoutLeaderInput | ClubCreateOrConnectWithoutLeaderInput[]
    upsert?: ClubUpsertWithWhereUniqueWithoutLeaderInput | ClubUpsertWithWhereUniqueWithoutLeaderInput[]
    createMany?: ClubCreateManyLeaderInputEnvelope
    set?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    disconnect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    delete?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    connect?: ClubWhereUniqueInput | ClubWhereUniqueInput[]
    update?: ClubUpdateWithWhereUniqueWithoutLeaderInput | ClubUpdateWithWhereUniqueWithoutLeaderInput[]
    updateMany?: ClubUpdateManyWithWhereWithoutLeaderInput | ClubUpdateManyWithWhereWithoutLeaderInput[]
    deleteMany?: ClubScalarWhereInput | ClubScalarWhereInput[]
  }

  export type ClubMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClubMemberCreateWithoutUserInput, ClubMemberUncheckedCreateWithoutUserInput> | ClubMemberCreateWithoutUserInput[] | ClubMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClubMemberCreateOrConnectWithoutUserInput | ClubMemberCreateOrConnectWithoutUserInput[]
    upsert?: ClubMemberUpsertWithWhereUniqueWithoutUserInput | ClubMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClubMemberCreateManyUserInputEnvelope
    set?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    disconnect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    delete?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    connect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    update?: ClubMemberUpdateWithWhereUniqueWithoutUserInput | ClubMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClubMemberUpdateManyWithWhereWithoutUserInput | ClubMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClubMemberScalarWhereInput | ClubMemberScalarWhereInput[]
  }

  export type TournamentRegistrationMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TournamentRegistrationMemberCreateWithoutUserInput, TournamentRegistrationMemberUncheckedCreateWithoutUserInput> | TournamentRegistrationMemberCreateWithoutUserInput[] | TournamentRegistrationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentRegistrationMemberCreateOrConnectWithoutUserInput | TournamentRegistrationMemberCreateOrConnectWithoutUserInput[]
    upsert?: TournamentRegistrationMemberUpsertWithWhereUniqueWithoutUserInput | TournamentRegistrationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TournamentRegistrationMemberCreateManyUserInputEnvelope
    set?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    disconnect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    delete?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    connect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    update?: TournamentRegistrationMemberUpdateWithWhereUniqueWithoutUserInput | TournamentRegistrationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TournamentRegistrationMemberUpdateManyWithWhereWithoutUserInput | TournamentRegistrationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TournamentRegistrationMemberScalarWhereInput | TournamentRegistrationMemberScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type NullableEnumPhoneVerificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.PhoneVerificationType | null
  }

  export type AuthTokenCreateNestedManyWithoutStaffInput = {
    create?: XOR<AuthTokenCreateWithoutStaffInput, AuthTokenUncheckedCreateWithoutStaffInput> | AuthTokenCreateWithoutStaffInput[] | AuthTokenUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AuthTokenCreateOrConnectWithoutStaffInput | AuthTokenCreateOrConnectWithoutStaffInput[]
    createMany?: AuthTokenCreateManyStaffInputEnvelope
    connect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
  }

  export type SlotCreateNestedManyWithoutStaffInput = {
    create?: XOR<SlotCreateWithoutStaffInput, SlotUncheckedCreateWithoutStaffInput> | SlotCreateWithoutStaffInput[] | SlotUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutStaffInput | SlotCreateOrConnectWithoutStaffInput[]
    createMany?: SlotCreateManyStaffInputEnvelope
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
  }

  export type CoachTypeStaffPriceCreateNestedManyWithoutStaffInput = {
    create?: XOR<CoachTypeStaffPriceCreateWithoutStaffInput, CoachTypeStaffPriceUncheckedCreateWithoutStaffInput> | CoachTypeStaffPriceCreateWithoutStaffInput[] | CoachTypeStaffPriceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: CoachTypeStaffPriceCreateOrConnectWithoutStaffInput | CoachTypeStaffPriceCreateOrConnectWithoutStaffInput[]
    createMany?: CoachTypeStaffPriceCreateManyStaffInputEnvelope
    connect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
  }

  export type AuthTokenUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<AuthTokenCreateWithoutStaffInput, AuthTokenUncheckedCreateWithoutStaffInput> | AuthTokenCreateWithoutStaffInput[] | AuthTokenUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AuthTokenCreateOrConnectWithoutStaffInput | AuthTokenCreateOrConnectWithoutStaffInput[]
    createMany?: AuthTokenCreateManyStaffInputEnvelope
    connect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
  }

  export type SlotUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<SlotCreateWithoutStaffInput, SlotUncheckedCreateWithoutStaffInput> | SlotCreateWithoutStaffInput[] | SlotUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutStaffInput | SlotCreateOrConnectWithoutStaffInput[]
    createMany?: SlotCreateManyStaffInputEnvelope
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
  }

  export type CoachTypeStaffPriceUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<CoachTypeStaffPriceCreateWithoutStaffInput, CoachTypeStaffPriceUncheckedCreateWithoutStaffInput> | CoachTypeStaffPriceCreateWithoutStaffInput[] | CoachTypeStaffPriceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: CoachTypeStaffPriceCreateOrConnectWithoutStaffInput | CoachTypeStaffPriceCreateOrConnectWithoutStaffInput[]
    createMany?: CoachTypeStaffPriceCreateManyStaffInputEnvelope
    connect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AuthTokenUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AuthTokenCreateWithoutStaffInput, AuthTokenUncheckedCreateWithoutStaffInput> | AuthTokenCreateWithoutStaffInput[] | AuthTokenUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AuthTokenCreateOrConnectWithoutStaffInput | AuthTokenCreateOrConnectWithoutStaffInput[]
    upsert?: AuthTokenUpsertWithWhereUniqueWithoutStaffInput | AuthTokenUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AuthTokenCreateManyStaffInputEnvelope
    set?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    disconnect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    delete?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    connect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    update?: AuthTokenUpdateWithWhereUniqueWithoutStaffInput | AuthTokenUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AuthTokenUpdateManyWithWhereWithoutStaffInput | AuthTokenUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AuthTokenScalarWhereInput | AuthTokenScalarWhereInput[]
  }

  export type SlotUpdateManyWithoutStaffNestedInput = {
    create?: XOR<SlotCreateWithoutStaffInput, SlotUncheckedCreateWithoutStaffInput> | SlotCreateWithoutStaffInput[] | SlotUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutStaffInput | SlotCreateOrConnectWithoutStaffInput[]
    upsert?: SlotUpsertWithWhereUniqueWithoutStaffInput | SlotUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: SlotCreateManyStaffInputEnvelope
    set?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    disconnect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    delete?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    update?: SlotUpdateWithWhereUniqueWithoutStaffInput | SlotUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: SlotUpdateManyWithWhereWithoutStaffInput | SlotUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: SlotScalarWhereInput | SlotScalarWhereInput[]
  }

  export type CoachTypeStaffPriceUpdateManyWithoutStaffNestedInput = {
    create?: XOR<CoachTypeStaffPriceCreateWithoutStaffInput, CoachTypeStaffPriceUncheckedCreateWithoutStaffInput> | CoachTypeStaffPriceCreateWithoutStaffInput[] | CoachTypeStaffPriceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: CoachTypeStaffPriceCreateOrConnectWithoutStaffInput | CoachTypeStaffPriceCreateOrConnectWithoutStaffInput[]
    upsert?: CoachTypeStaffPriceUpsertWithWhereUniqueWithoutStaffInput | CoachTypeStaffPriceUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: CoachTypeStaffPriceCreateManyStaffInputEnvelope
    set?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    disconnect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    delete?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    connect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    update?: CoachTypeStaffPriceUpdateWithWhereUniqueWithoutStaffInput | CoachTypeStaffPriceUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: CoachTypeStaffPriceUpdateManyWithWhereWithoutStaffInput | CoachTypeStaffPriceUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: CoachTypeStaffPriceScalarWhereInput | CoachTypeStaffPriceScalarWhereInput[]
  }

  export type AuthTokenUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AuthTokenCreateWithoutStaffInput, AuthTokenUncheckedCreateWithoutStaffInput> | AuthTokenCreateWithoutStaffInput[] | AuthTokenUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AuthTokenCreateOrConnectWithoutStaffInput | AuthTokenCreateOrConnectWithoutStaffInput[]
    upsert?: AuthTokenUpsertWithWhereUniqueWithoutStaffInput | AuthTokenUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AuthTokenCreateManyStaffInputEnvelope
    set?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    disconnect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    delete?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    connect?: AuthTokenWhereUniqueInput | AuthTokenWhereUniqueInput[]
    update?: AuthTokenUpdateWithWhereUniqueWithoutStaffInput | AuthTokenUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AuthTokenUpdateManyWithWhereWithoutStaffInput | AuthTokenUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AuthTokenScalarWhereInput | AuthTokenScalarWhereInput[]
  }

  export type SlotUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<SlotCreateWithoutStaffInput, SlotUncheckedCreateWithoutStaffInput> | SlotCreateWithoutStaffInput[] | SlotUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutStaffInput | SlotCreateOrConnectWithoutStaffInput[]
    upsert?: SlotUpsertWithWhereUniqueWithoutStaffInput | SlotUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: SlotCreateManyStaffInputEnvelope
    set?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    disconnect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    delete?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    update?: SlotUpdateWithWhereUniqueWithoutStaffInput | SlotUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: SlotUpdateManyWithWhereWithoutStaffInput | SlotUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: SlotScalarWhereInput | SlotScalarWhereInput[]
  }

  export type CoachTypeStaffPriceUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<CoachTypeStaffPriceCreateWithoutStaffInput, CoachTypeStaffPriceUncheckedCreateWithoutStaffInput> | CoachTypeStaffPriceCreateWithoutStaffInput[] | CoachTypeStaffPriceUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: CoachTypeStaffPriceCreateOrConnectWithoutStaffInput | CoachTypeStaffPriceCreateOrConnectWithoutStaffInput[]
    upsert?: CoachTypeStaffPriceUpsertWithWhereUniqueWithoutStaffInput | CoachTypeStaffPriceUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: CoachTypeStaffPriceCreateManyStaffInputEnvelope
    set?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    disconnect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    delete?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    connect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    update?: CoachTypeStaffPriceUpdateWithWhereUniqueWithoutStaffInput | CoachTypeStaffPriceUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: CoachTypeStaffPriceUpdateManyWithWhereWithoutStaffInput | CoachTypeStaffPriceUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: CoachTypeStaffPriceScalarWhereInput | CoachTypeStaffPriceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuthTokensInput = {
    create?: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthTokensInput
    connect?: UserWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutAuthTokensInput = {
    create?: XOR<StaffCreateWithoutAuthTokensInput, StaffUncheckedCreateWithoutAuthTokensInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAuthTokensInput
    connect?: StaffWhereUniqueInput
  }

  export type EnumAuthTokenTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuthTokenType
  }

  export type UserUpdateOneWithoutAuthTokensNestedInput = {
    create?: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthTokensInput
    upsert?: UserUpsertWithoutAuthTokensInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthTokensInput, UserUpdateWithoutAuthTokensInput>, UserUncheckedUpdateWithoutAuthTokensInput>
  }

  export type StaffUpdateOneWithoutAuthTokensNestedInput = {
    create?: XOR<StaffCreateWithoutAuthTokensInput, StaffUncheckedCreateWithoutAuthTokensInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAuthTokensInput
    upsert?: StaffUpsertWithoutAuthTokensInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutAuthTokensInput, StaffUpdateWithoutAuthTokensInput>, StaffUncheckedUpdateWithoutAuthTokensInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourtCostScheduleCreateNestedManyWithoutCourtInput = {
    create?: XOR<CourtCostScheduleCreateWithoutCourtInput, CourtCostScheduleUncheckedCreateWithoutCourtInput> | CourtCostScheduleCreateWithoutCourtInput[] | CourtCostScheduleUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: CourtCostScheduleCreateOrConnectWithoutCourtInput | CourtCostScheduleCreateOrConnectWithoutCourtInput[]
    createMany?: CourtCostScheduleCreateManyCourtInputEnvelope
    connect?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
  }

  export type BookingDetailCreateNestedManyWithoutCourtInput = {
    create?: XOR<BookingDetailCreateWithoutCourtInput, BookingDetailUncheckedCreateWithoutCourtInput> | BookingDetailCreateWithoutCourtInput[] | BookingDetailUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutCourtInput | BookingDetailCreateOrConnectWithoutCourtInput[]
    createMany?: BookingDetailCreateManyCourtInputEnvelope
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
  }

  export type SlotCreateNestedManyWithoutCourtInput = {
    create?: XOR<SlotCreateWithoutCourtInput, SlotUncheckedCreateWithoutCourtInput> | SlotCreateWithoutCourtInput[] | SlotUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutCourtInput | SlotCreateOrConnectWithoutCourtInput[]
    createMany?: SlotCreateManyCourtInputEnvelope
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
  }

  export type CourtCostScheduleUncheckedCreateNestedManyWithoutCourtInput = {
    create?: XOR<CourtCostScheduleCreateWithoutCourtInput, CourtCostScheduleUncheckedCreateWithoutCourtInput> | CourtCostScheduleCreateWithoutCourtInput[] | CourtCostScheduleUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: CourtCostScheduleCreateOrConnectWithoutCourtInput | CourtCostScheduleCreateOrConnectWithoutCourtInput[]
    createMany?: CourtCostScheduleCreateManyCourtInputEnvelope
    connect?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
  }

  export type BookingDetailUncheckedCreateNestedManyWithoutCourtInput = {
    create?: XOR<BookingDetailCreateWithoutCourtInput, BookingDetailUncheckedCreateWithoutCourtInput> | BookingDetailCreateWithoutCourtInput[] | BookingDetailUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutCourtInput | BookingDetailCreateOrConnectWithoutCourtInput[]
    createMany?: BookingDetailCreateManyCourtInputEnvelope
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
  }

  export type SlotUncheckedCreateNestedManyWithoutCourtInput = {
    create?: XOR<SlotCreateWithoutCourtInput, SlotUncheckedCreateWithoutCourtInput> | SlotCreateWithoutCourtInput[] | SlotUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutCourtInput | SlotCreateOrConnectWithoutCourtInput[]
    createMany?: SlotCreateManyCourtInputEnvelope
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
  }

  export type CourtCostScheduleUpdateManyWithoutCourtNestedInput = {
    create?: XOR<CourtCostScheduleCreateWithoutCourtInput, CourtCostScheduleUncheckedCreateWithoutCourtInput> | CourtCostScheduleCreateWithoutCourtInput[] | CourtCostScheduleUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: CourtCostScheduleCreateOrConnectWithoutCourtInput | CourtCostScheduleCreateOrConnectWithoutCourtInput[]
    upsert?: CourtCostScheduleUpsertWithWhereUniqueWithoutCourtInput | CourtCostScheduleUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: CourtCostScheduleCreateManyCourtInputEnvelope
    set?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
    disconnect?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
    delete?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
    connect?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
    update?: CourtCostScheduleUpdateWithWhereUniqueWithoutCourtInput | CourtCostScheduleUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: CourtCostScheduleUpdateManyWithWhereWithoutCourtInput | CourtCostScheduleUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: CourtCostScheduleScalarWhereInput | CourtCostScheduleScalarWhereInput[]
  }

  export type BookingDetailUpdateManyWithoutCourtNestedInput = {
    create?: XOR<BookingDetailCreateWithoutCourtInput, BookingDetailUncheckedCreateWithoutCourtInput> | BookingDetailCreateWithoutCourtInput[] | BookingDetailUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutCourtInput | BookingDetailCreateOrConnectWithoutCourtInput[]
    upsert?: BookingDetailUpsertWithWhereUniqueWithoutCourtInput | BookingDetailUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: BookingDetailCreateManyCourtInputEnvelope
    set?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    disconnect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    delete?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    update?: BookingDetailUpdateWithWhereUniqueWithoutCourtInput | BookingDetailUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: BookingDetailUpdateManyWithWhereWithoutCourtInput | BookingDetailUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: BookingDetailScalarWhereInput | BookingDetailScalarWhereInput[]
  }

  export type SlotUpdateManyWithoutCourtNestedInput = {
    create?: XOR<SlotCreateWithoutCourtInput, SlotUncheckedCreateWithoutCourtInput> | SlotCreateWithoutCourtInput[] | SlotUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutCourtInput | SlotCreateOrConnectWithoutCourtInput[]
    upsert?: SlotUpsertWithWhereUniqueWithoutCourtInput | SlotUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: SlotCreateManyCourtInputEnvelope
    set?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    disconnect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    delete?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    update?: SlotUpdateWithWhereUniqueWithoutCourtInput | SlotUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: SlotUpdateManyWithWhereWithoutCourtInput | SlotUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: SlotScalarWhereInput | SlotScalarWhereInput[]
  }

  export type CourtCostScheduleUncheckedUpdateManyWithoutCourtNestedInput = {
    create?: XOR<CourtCostScheduleCreateWithoutCourtInput, CourtCostScheduleUncheckedCreateWithoutCourtInput> | CourtCostScheduleCreateWithoutCourtInput[] | CourtCostScheduleUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: CourtCostScheduleCreateOrConnectWithoutCourtInput | CourtCostScheduleCreateOrConnectWithoutCourtInput[]
    upsert?: CourtCostScheduleUpsertWithWhereUniqueWithoutCourtInput | CourtCostScheduleUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: CourtCostScheduleCreateManyCourtInputEnvelope
    set?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
    disconnect?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
    delete?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
    connect?: CourtCostScheduleWhereUniqueInput | CourtCostScheduleWhereUniqueInput[]
    update?: CourtCostScheduleUpdateWithWhereUniqueWithoutCourtInput | CourtCostScheduleUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: CourtCostScheduleUpdateManyWithWhereWithoutCourtInput | CourtCostScheduleUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: CourtCostScheduleScalarWhereInput | CourtCostScheduleScalarWhereInput[]
  }

  export type BookingDetailUncheckedUpdateManyWithoutCourtNestedInput = {
    create?: XOR<BookingDetailCreateWithoutCourtInput, BookingDetailUncheckedCreateWithoutCourtInput> | BookingDetailCreateWithoutCourtInput[] | BookingDetailUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutCourtInput | BookingDetailCreateOrConnectWithoutCourtInput[]
    upsert?: BookingDetailUpsertWithWhereUniqueWithoutCourtInput | BookingDetailUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: BookingDetailCreateManyCourtInputEnvelope
    set?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    disconnect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    delete?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    update?: BookingDetailUpdateWithWhereUniqueWithoutCourtInput | BookingDetailUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: BookingDetailUpdateManyWithWhereWithoutCourtInput | BookingDetailUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: BookingDetailScalarWhereInput | BookingDetailScalarWhereInput[]
  }

  export type SlotUncheckedUpdateManyWithoutCourtNestedInput = {
    create?: XOR<SlotCreateWithoutCourtInput, SlotUncheckedCreateWithoutCourtInput> | SlotCreateWithoutCourtInput[] | SlotUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: SlotCreateOrConnectWithoutCourtInput | SlotCreateOrConnectWithoutCourtInput[]
    upsert?: SlotUpsertWithWhereUniqueWithoutCourtInput | SlotUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: SlotCreateManyCourtInputEnvelope
    set?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    disconnect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    delete?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    connect?: SlotWhereUniqueInput | SlotWhereUniqueInput[]
    update?: SlotUpdateWithWhereUniqueWithoutCourtInput | SlotUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: SlotUpdateManyWithWhereWithoutCourtInput | SlotUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: SlotScalarWhereInput | SlotScalarWhereInput[]
  }

  export type BookingInventoryCreateNestedManyWithoutInventoryInput = {
    create?: XOR<BookingInventoryCreateWithoutInventoryInput, BookingInventoryUncheckedCreateWithoutInventoryInput> | BookingInventoryCreateWithoutInventoryInput[] | BookingInventoryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: BookingInventoryCreateOrConnectWithoutInventoryInput | BookingInventoryCreateOrConnectWithoutInventoryInput[]
    createMany?: BookingInventoryCreateManyInventoryInputEnvelope
    connect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
  }

  export type BookingInventoryUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<BookingInventoryCreateWithoutInventoryInput, BookingInventoryUncheckedCreateWithoutInventoryInput> | BookingInventoryCreateWithoutInventoryInput[] | BookingInventoryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: BookingInventoryCreateOrConnectWithoutInventoryInput | BookingInventoryCreateOrConnectWithoutInventoryInput[]
    createMany?: BookingInventoryCreateManyInventoryInputEnvelope
    connect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
  }

  export type BookingInventoryUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<BookingInventoryCreateWithoutInventoryInput, BookingInventoryUncheckedCreateWithoutInventoryInput> | BookingInventoryCreateWithoutInventoryInput[] | BookingInventoryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: BookingInventoryCreateOrConnectWithoutInventoryInput | BookingInventoryCreateOrConnectWithoutInventoryInput[]
    upsert?: BookingInventoryUpsertWithWhereUniqueWithoutInventoryInput | BookingInventoryUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: BookingInventoryCreateManyInventoryInputEnvelope
    set?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    disconnect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    delete?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    connect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    update?: BookingInventoryUpdateWithWhereUniqueWithoutInventoryInput | BookingInventoryUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: BookingInventoryUpdateManyWithWhereWithoutInventoryInput | BookingInventoryUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: BookingInventoryScalarWhereInput | BookingInventoryScalarWhereInput[]
  }

  export type BookingInventoryUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<BookingInventoryCreateWithoutInventoryInput, BookingInventoryUncheckedCreateWithoutInventoryInput> | BookingInventoryCreateWithoutInventoryInput[] | BookingInventoryUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: BookingInventoryCreateOrConnectWithoutInventoryInput | BookingInventoryCreateOrConnectWithoutInventoryInput[]
    upsert?: BookingInventoryUpsertWithWhereUniqueWithoutInventoryInput | BookingInventoryUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: BookingInventoryCreateManyInventoryInputEnvelope
    set?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    disconnect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    delete?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    connect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    update?: BookingInventoryUpdateWithWhereUniqueWithoutInventoryInput | BookingInventoryUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: BookingInventoryUpdateManyWithWhereWithoutInventoryInput | BookingInventoryUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: BookingInventoryScalarWhereInput | BookingInventoryScalarWhereInput[]
  }

  export type CourtCreateNestedOneWithoutSlotInput = {
    create?: XOR<CourtCreateWithoutSlotInput, CourtUncheckedCreateWithoutSlotInput>
    connectOrCreate?: CourtCreateOrConnectWithoutSlotInput
    connect?: CourtWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutSlotInput = {
    create?: XOR<StaffCreateWithoutSlotInput, StaffUncheckedCreateWithoutSlotInput>
    connectOrCreate?: StaffCreateOrConnectWithoutSlotInput
    connect?: StaffWhereUniqueInput
  }

  export type BookingDetailCreateNestedManyWithoutSlotInput = {
    create?: XOR<BookingDetailCreateWithoutSlotInput, BookingDetailUncheckedCreateWithoutSlotInput> | BookingDetailCreateWithoutSlotInput[] | BookingDetailUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutSlotInput | BookingDetailCreateOrConnectWithoutSlotInput[]
    createMany?: BookingDetailCreateManySlotInputEnvelope
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
  }

  export type BookingCoachCreateNestedManyWithoutSlotInput = {
    create?: XOR<BookingCoachCreateWithoutSlotInput, BookingCoachUncheckedCreateWithoutSlotInput> | BookingCoachCreateWithoutSlotInput[] | BookingCoachUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutSlotInput | BookingCoachCreateOrConnectWithoutSlotInput[]
    createMany?: BookingCoachCreateManySlotInputEnvelope
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
  }

  export type BookingBallboyCreateNestedManyWithoutSlotInput = {
    create?: XOR<BookingBallboyCreateWithoutSlotInput, BookingBallboyUncheckedCreateWithoutSlotInput> | BookingBallboyCreateWithoutSlotInput[] | BookingBallboyUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingBallboyCreateOrConnectWithoutSlotInput | BookingBallboyCreateOrConnectWithoutSlotInput[]
    createMany?: BookingBallboyCreateManySlotInputEnvelope
    connect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
  }

  export type BookingDetailUncheckedCreateNestedManyWithoutSlotInput = {
    create?: XOR<BookingDetailCreateWithoutSlotInput, BookingDetailUncheckedCreateWithoutSlotInput> | BookingDetailCreateWithoutSlotInput[] | BookingDetailUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutSlotInput | BookingDetailCreateOrConnectWithoutSlotInput[]
    createMany?: BookingDetailCreateManySlotInputEnvelope
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
  }

  export type BookingCoachUncheckedCreateNestedManyWithoutSlotInput = {
    create?: XOR<BookingCoachCreateWithoutSlotInput, BookingCoachUncheckedCreateWithoutSlotInput> | BookingCoachCreateWithoutSlotInput[] | BookingCoachUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutSlotInput | BookingCoachCreateOrConnectWithoutSlotInput[]
    createMany?: BookingCoachCreateManySlotInputEnvelope
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
  }

  export type BookingBallboyUncheckedCreateNestedManyWithoutSlotInput = {
    create?: XOR<BookingBallboyCreateWithoutSlotInput, BookingBallboyUncheckedCreateWithoutSlotInput> | BookingBallboyCreateWithoutSlotInput[] | BookingBallboyUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingBallboyCreateOrConnectWithoutSlotInput | BookingBallboyCreateOrConnectWithoutSlotInput[]
    createMany?: BookingBallboyCreateManySlotInputEnvelope
    connect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
  }

  export type EnumSlotTypeFieldUpdateOperationsInput = {
    set?: $Enums.SlotType
  }

  export type CourtUpdateOneWithoutSlotNestedInput = {
    create?: XOR<CourtCreateWithoutSlotInput, CourtUncheckedCreateWithoutSlotInput>
    connectOrCreate?: CourtCreateOrConnectWithoutSlotInput
    upsert?: CourtUpsertWithoutSlotInput
    disconnect?: CourtWhereInput | boolean
    delete?: CourtWhereInput | boolean
    connect?: CourtWhereUniqueInput
    update?: XOR<XOR<CourtUpdateToOneWithWhereWithoutSlotInput, CourtUpdateWithoutSlotInput>, CourtUncheckedUpdateWithoutSlotInput>
  }

  export type StaffUpdateOneWithoutSlotNestedInput = {
    create?: XOR<StaffCreateWithoutSlotInput, StaffUncheckedCreateWithoutSlotInput>
    connectOrCreate?: StaffCreateOrConnectWithoutSlotInput
    upsert?: StaffUpsertWithoutSlotInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutSlotInput, StaffUpdateWithoutSlotInput>, StaffUncheckedUpdateWithoutSlotInput>
  }

  export type BookingDetailUpdateManyWithoutSlotNestedInput = {
    create?: XOR<BookingDetailCreateWithoutSlotInput, BookingDetailUncheckedCreateWithoutSlotInput> | BookingDetailCreateWithoutSlotInput[] | BookingDetailUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutSlotInput | BookingDetailCreateOrConnectWithoutSlotInput[]
    upsert?: BookingDetailUpsertWithWhereUniqueWithoutSlotInput | BookingDetailUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: BookingDetailCreateManySlotInputEnvelope
    set?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    disconnect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    delete?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    update?: BookingDetailUpdateWithWhereUniqueWithoutSlotInput | BookingDetailUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: BookingDetailUpdateManyWithWhereWithoutSlotInput | BookingDetailUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: BookingDetailScalarWhereInput | BookingDetailScalarWhereInput[]
  }

  export type BookingCoachUpdateManyWithoutSlotNestedInput = {
    create?: XOR<BookingCoachCreateWithoutSlotInput, BookingCoachUncheckedCreateWithoutSlotInput> | BookingCoachCreateWithoutSlotInput[] | BookingCoachUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutSlotInput | BookingCoachCreateOrConnectWithoutSlotInput[]
    upsert?: BookingCoachUpsertWithWhereUniqueWithoutSlotInput | BookingCoachUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: BookingCoachCreateManySlotInputEnvelope
    set?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    disconnect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    delete?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    update?: BookingCoachUpdateWithWhereUniqueWithoutSlotInput | BookingCoachUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: BookingCoachUpdateManyWithWhereWithoutSlotInput | BookingCoachUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: BookingCoachScalarWhereInput | BookingCoachScalarWhereInput[]
  }

  export type BookingBallboyUpdateManyWithoutSlotNestedInput = {
    create?: XOR<BookingBallboyCreateWithoutSlotInput, BookingBallboyUncheckedCreateWithoutSlotInput> | BookingBallboyCreateWithoutSlotInput[] | BookingBallboyUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingBallboyCreateOrConnectWithoutSlotInput | BookingBallboyCreateOrConnectWithoutSlotInput[]
    upsert?: BookingBallboyUpsertWithWhereUniqueWithoutSlotInput | BookingBallboyUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: BookingBallboyCreateManySlotInputEnvelope
    set?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    disconnect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    delete?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    connect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    update?: BookingBallboyUpdateWithWhereUniqueWithoutSlotInput | BookingBallboyUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: BookingBallboyUpdateManyWithWhereWithoutSlotInput | BookingBallboyUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: BookingBallboyScalarWhereInput | BookingBallboyScalarWhereInput[]
  }

  export type BookingDetailUncheckedUpdateManyWithoutSlotNestedInput = {
    create?: XOR<BookingDetailCreateWithoutSlotInput, BookingDetailUncheckedCreateWithoutSlotInput> | BookingDetailCreateWithoutSlotInput[] | BookingDetailUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutSlotInput | BookingDetailCreateOrConnectWithoutSlotInput[]
    upsert?: BookingDetailUpsertWithWhereUniqueWithoutSlotInput | BookingDetailUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: BookingDetailCreateManySlotInputEnvelope
    set?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    disconnect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    delete?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    update?: BookingDetailUpdateWithWhereUniqueWithoutSlotInput | BookingDetailUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: BookingDetailUpdateManyWithWhereWithoutSlotInput | BookingDetailUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: BookingDetailScalarWhereInput | BookingDetailScalarWhereInput[]
  }

  export type BookingCoachUncheckedUpdateManyWithoutSlotNestedInput = {
    create?: XOR<BookingCoachCreateWithoutSlotInput, BookingCoachUncheckedCreateWithoutSlotInput> | BookingCoachCreateWithoutSlotInput[] | BookingCoachUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutSlotInput | BookingCoachCreateOrConnectWithoutSlotInput[]
    upsert?: BookingCoachUpsertWithWhereUniqueWithoutSlotInput | BookingCoachUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: BookingCoachCreateManySlotInputEnvelope
    set?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    disconnect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    delete?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    update?: BookingCoachUpdateWithWhereUniqueWithoutSlotInput | BookingCoachUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: BookingCoachUpdateManyWithWhereWithoutSlotInput | BookingCoachUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: BookingCoachScalarWhereInput | BookingCoachScalarWhereInput[]
  }

  export type BookingBallboyUncheckedUpdateManyWithoutSlotNestedInput = {
    create?: XOR<BookingBallboyCreateWithoutSlotInput, BookingBallboyUncheckedCreateWithoutSlotInput> | BookingBallboyCreateWithoutSlotInput[] | BookingBallboyUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: BookingBallboyCreateOrConnectWithoutSlotInput | BookingBallboyCreateOrConnectWithoutSlotInput[]
    upsert?: BookingBallboyUpsertWithWhereUniqueWithoutSlotInput | BookingBallboyUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: BookingBallboyCreateManySlotInputEnvelope
    set?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    disconnect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    delete?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    connect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    update?: BookingBallboyUpdateWithWhereUniqueWithoutSlotInput | BookingBallboyUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: BookingBallboyUpdateManyWithWhereWithoutSlotInput | BookingBallboyUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: BookingBallboyScalarWhereInput | BookingBallboyScalarWhereInput[]
  }

  export type CourtCreateNestedOneWithoutCostSchedulesInput = {
    create?: XOR<CourtCreateWithoutCostSchedulesInput, CourtUncheckedCreateWithoutCostSchedulesInput>
    connectOrCreate?: CourtCreateOrConnectWithoutCostSchedulesInput
    connect?: CourtWhereUniqueInput
  }

  export type CourtUpdateOneRequiredWithoutCostSchedulesNestedInput = {
    create?: XOR<CourtCreateWithoutCostSchedulesInput, CourtUncheckedCreateWithoutCostSchedulesInput>
    connectOrCreate?: CourtCreateOrConnectWithoutCostSchedulesInput
    upsert?: CourtUpsertWithoutCostSchedulesInput
    connect?: CourtWhereUniqueInput
    update?: XOR<XOR<CourtUpdateToOneWithWhereWithoutCostSchedulesInput, CourtUpdateWithoutCostSchedulesInput>, CourtUncheckedUpdateWithoutCostSchedulesInput>
  }

  export type PaymentCreateNestedManyWithoutMethodInput = {
    create?: XOR<PaymentCreateWithoutMethodInput, PaymentUncheckedCreateWithoutMethodInput> | PaymentCreateWithoutMethodInput[] | PaymentUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutMethodInput | PaymentCreateOrConnectWithoutMethodInput[]
    createMany?: PaymentCreateManyMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutMethodInput = {
    create?: XOR<PaymentCreateWithoutMethodInput, PaymentUncheckedCreateWithoutMethodInput> | PaymentCreateWithoutMethodInput[] | PaymentUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutMethodInput | PaymentCreateOrConnectWithoutMethodInput[]
    createMany?: PaymentCreateManyMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUpdateManyWithoutMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutMethodInput, PaymentUncheckedCreateWithoutMethodInput> | PaymentCreateWithoutMethodInput[] | PaymentUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutMethodInput | PaymentCreateOrConnectWithoutMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutMethodInput | PaymentUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: PaymentCreateManyMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutMethodInput | PaymentUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutMethodInput | PaymentUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutMethodInput, PaymentUncheckedCreateWithoutMethodInput> | PaymentCreateWithoutMethodInput[] | PaymentUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutMethodInput | PaymentCreateOrConnectWithoutMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutMethodInput | PaymentUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: PaymentCreateManyMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutMethodInput | PaymentUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutMethodInput | PaymentUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentMethodCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentInput = {
    create?: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentsInput
    upsert?: PaymentMethodUpsertWithoutPaymentsInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutPaymentsInput, PaymentMethodUpdateWithoutPaymentsInput>, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentInput
    upsert?: InvoiceUpsertWithoutPaymentInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentInput, InvoiceUpdateWithoutPaymentInput>, InvoiceUncheckedUpdateWithoutPaymentInput>
  }

  export type InvoiceUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentInput
    upsert?: InvoiceUpsertWithoutPaymentInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentInput, InvoiceUpdateWithoutPaymentInput>, InvoiceUncheckedUpdateWithoutPaymentInput>
  }

  export type UserCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput
    connect?: PaymentWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<BookingCreateWithoutInvoiceInput, BookingUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInvoiceInput
    connect?: BookingWhereUniqueInput
  }

  export type ClassBookingCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<ClassBookingCreateWithoutInvoiceInput, ClassBookingUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ClassBookingCreateOrConnectWithoutInvoiceInput
    connect?: ClassBookingWhereUniqueInput
  }

  export type MembershipUserCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<MembershipUserCreateWithoutInvoiceInput, MembershipUserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: MembershipUserCreateOrConnectWithoutInvoiceInput
    connect?: MembershipUserWhereUniqueInput
  }

  export type TournamentRegistrationCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<TournamentRegistrationCreateWithoutInvoiceInput, TournamentRegistrationUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutInvoiceInput
    connect?: TournamentRegistrationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceInput
    upsert?: UserUpsertWithoutInvoiceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoiceInput, UserUpdateWithoutInvoiceInput>, UserUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput
    upsert?: PaymentUpsertWithoutInvoiceInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutInvoiceInput, PaymentUpdateWithoutInvoiceInput>, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type BookingUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<BookingCreateWithoutInvoiceInput, BookingUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInvoiceInput
    upsert?: BookingUpsertWithoutInvoiceInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutInvoiceInput, BookingUpdateWithoutInvoiceInput>, BookingUncheckedUpdateWithoutInvoiceInput>
  }

  export type ClassBookingUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<ClassBookingCreateWithoutInvoiceInput, ClassBookingUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ClassBookingCreateOrConnectWithoutInvoiceInput
    upsert?: ClassBookingUpsertWithoutInvoiceInput
    disconnect?: ClassBookingWhereInput | boolean
    delete?: ClassBookingWhereInput | boolean
    connect?: ClassBookingWhereUniqueInput
    update?: XOR<XOR<ClassBookingUpdateToOneWithWhereWithoutInvoiceInput, ClassBookingUpdateWithoutInvoiceInput>, ClassBookingUncheckedUpdateWithoutInvoiceInput>
  }

  export type MembershipUserUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<MembershipUserCreateWithoutInvoiceInput, MembershipUserUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: MembershipUserCreateOrConnectWithoutInvoiceInput
    upsert?: MembershipUserUpsertWithoutInvoiceInput
    disconnect?: MembershipUserWhereInput | boolean
    delete?: MembershipUserWhereInput | boolean
    connect?: MembershipUserWhereUniqueInput
    update?: XOR<XOR<MembershipUserUpdateToOneWithWhereWithoutInvoiceInput, MembershipUserUpdateWithoutInvoiceInput>, MembershipUserUncheckedUpdateWithoutInvoiceInput>
  }

  export type TournamentRegistrationUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<TournamentRegistrationCreateWithoutInvoiceInput, TournamentRegistrationUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutInvoiceInput
    upsert?: TournamentRegistrationUpsertWithoutInvoiceInput
    disconnect?: TournamentRegistrationWhereInput | boolean
    delete?: TournamentRegistrationWhereInput | boolean
    connect?: TournamentRegistrationWhereUniqueInput
    update?: XOR<XOR<TournamentRegistrationUpdateToOneWithWhereWithoutInvoiceInput, TournamentRegistrationUpdateWithoutInvoiceInput>, TournamentRegistrationUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingDetailCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingDetailCreateWithoutBookingInput, BookingDetailUncheckedCreateWithoutBookingInput> | BookingDetailCreateWithoutBookingInput[] | BookingDetailUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutBookingInput | BookingDetailCreateOrConnectWithoutBookingInput[]
    createMany?: BookingDetailCreateManyBookingInputEnvelope
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
  }

  export type BookingInventoryCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingInventoryCreateWithoutBookingInput, BookingInventoryUncheckedCreateWithoutBookingInput> | BookingInventoryCreateWithoutBookingInput[] | BookingInventoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingInventoryCreateOrConnectWithoutBookingInput | BookingInventoryCreateOrConnectWithoutBookingInput[]
    createMany?: BookingInventoryCreateManyBookingInputEnvelope
    connect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
  }

  export type BookingBallboyCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingBallboyCreateWithoutBookingInput, BookingBallboyUncheckedCreateWithoutBookingInput> | BookingBallboyCreateWithoutBookingInput[] | BookingBallboyUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingBallboyCreateOrConnectWithoutBookingInput | BookingBallboyCreateOrConnectWithoutBookingInput[]
    createMany?: BookingBallboyCreateManyBookingInputEnvelope
    connect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
  }

  export type BookingCoachCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingCoachCreateWithoutBookingInput, BookingCoachUncheckedCreateWithoutBookingInput> | BookingCoachCreateWithoutBookingInput[] | BookingCoachUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutBookingInput | BookingCoachCreateOrConnectWithoutBookingInput[]
    createMany?: BookingCoachCreateManyBookingInputEnvelope
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutBookingInput = {
    create?: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBookingInput
    connect?: InvoiceWhereUniqueInput
  }

  export type BookingDetailUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingDetailCreateWithoutBookingInput, BookingDetailUncheckedCreateWithoutBookingInput> | BookingDetailCreateWithoutBookingInput[] | BookingDetailUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutBookingInput | BookingDetailCreateOrConnectWithoutBookingInput[]
    createMany?: BookingDetailCreateManyBookingInputEnvelope
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
  }

  export type BookingInventoryUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingInventoryCreateWithoutBookingInput, BookingInventoryUncheckedCreateWithoutBookingInput> | BookingInventoryCreateWithoutBookingInput[] | BookingInventoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingInventoryCreateOrConnectWithoutBookingInput | BookingInventoryCreateOrConnectWithoutBookingInput[]
    createMany?: BookingInventoryCreateManyBookingInputEnvelope
    connect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
  }

  export type BookingBallboyUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingBallboyCreateWithoutBookingInput, BookingBallboyUncheckedCreateWithoutBookingInput> | BookingBallboyCreateWithoutBookingInput[] | BookingBallboyUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingBallboyCreateOrConnectWithoutBookingInput | BookingBallboyCreateOrConnectWithoutBookingInput[]
    createMany?: BookingBallboyCreateManyBookingInputEnvelope
    connect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
  }

  export type BookingCoachUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingCoachCreateWithoutBookingInput, BookingCoachUncheckedCreateWithoutBookingInput> | BookingCoachCreateWithoutBookingInput[] | BookingCoachUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutBookingInput | BookingCoachCreateOrConnectWithoutBookingInput[]
    createMany?: BookingCoachCreateManyBookingInputEnvelope
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBookingInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type BookingDetailUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingDetailCreateWithoutBookingInput, BookingDetailUncheckedCreateWithoutBookingInput> | BookingDetailCreateWithoutBookingInput[] | BookingDetailUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutBookingInput | BookingDetailCreateOrConnectWithoutBookingInput[]
    upsert?: BookingDetailUpsertWithWhereUniqueWithoutBookingInput | BookingDetailUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingDetailCreateManyBookingInputEnvelope
    set?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    disconnect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    delete?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    update?: BookingDetailUpdateWithWhereUniqueWithoutBookingInput | BookingDetailUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingDetailUpdateManyWithWhereWithoutBookingInput | BookingDetailUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingDetailScalarWhereInput | BookingDetailScalarWhereInput[]
  }

  export type BookingInventoryUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingInventoryCreateWithoutBookingInput, BookingInventoryUncheckedCreateWithoutBookingInput> | BookingInventoryCreateWithoutBookingInput[] | BookingInventoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingInventoryCreateOrConnectWithoutBookingInput | BookingInventoryCreateOrConnectWithoutBookingInput[]
    upsert?: BookingInventoryUpsertWithWhereUniqueWithoutBookingInput | BookingInventoryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingInventoryCreateManyBookingInputEnvelope
    set?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    disconnect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    delete?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    connect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    update?: BookingInventoryUpdateWithWhereUniqueWithoutBookingInput | BookingInventoryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingInventoryUpdateManyWithWhereWithoutBookingInput | BookingInventoryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingInventoryScalarWhereInput | BookingInventoryScalarWhereInput[]
  }

  export type BookingBallboyUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingBallboyCreateWithoutBookingInput, BookingBallboyUncheckedCreateWithoutBookingInput> | BookingBallboyCreateWithoutBookingInput[] | BookingBallboyUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingBallboyCreateOrConnectWithoutBookingInput | BookingBallboyCreateOrConnectWithoutBookingInput[]
    upsert?: BookingBallboyUpsertWithWhereUniqueWithoutBookingInput | BookingBallboyUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingBallboyCreateManyBookingInputEnvelope
    set?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    disconnect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    delete?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    connect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    update?: BookingBallboyUpdateWithWhereUniqueWithoutBookingInput | BookingBallboyUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingBallboyUpdateManyWithWhereWithoutBookingInput | BookingBallboyUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingBallboyScalarWhereInput | BookingBallboyScalarWhereInput[]
  }

  export type BookingCoachUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingCoachCreateWithoutBookingInput, BookingCoachUncheckedCreateWithoutBookingInput> | BookingCoachCreateWithoutBookingInput[] | BookingCoachUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutBookingInput | BookingCoachCreateOrConnectWithoutBookingInput[]
    upsert?: BookingCoachUpsertWithWhereUniqueWithoutBookingInput | BookingCoachUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingCoachCreateManyBookingInputEnvelope
    set?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    disconnect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    delete?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    update?: BookingCoachUpdateWithWhereUniqueWithoutBookingInput | BookingCoachUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingCoachUpdateManyWithWhereWithoutBookingInput | BookingCoachUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingCoachScalarWhereInput | BookingCoachScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutBookingNestedInput = {
    create?: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBookingInput
    upsert?: InvoiceUpsertWithoutBookingInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutBookingInput, InvoiceUpdateWithoutBookingInput>, InvoiceUncheckedUpdateWithoutBookingInput>
  }

  export type BookingDetailUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingDetailCreateWithoutBookingInput, BookingDetailUncheckedCreateWithoutBookingInput> | BookingDetailCreateWithoutBookingInput[] | BookingDetailUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingDetailCreateOrConnectWithoutBookingInput | BookingDetailCreateOrConnectWithoutBookingInput[]
    upsert?: BookingDetailUpsertWithWhereUniqueWithoutBookingInput | BookingDetailUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingDetailCreateManyBookingInputEnvelope
    set?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    disconnect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    delete?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    connect?: BookingDetailWhereUniqueInput | BookingDetailWhereUniqueInput[]
    update?: BookingDetailUpdateWithWhereUniqueWithoutBookingInput | BookingDetailUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingDetailUpdateManyWithWhereWithoutBookingInput | BookingDetailUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingDetailScalarWhereInput | BookingDetailScalarWhereInput[]
  }

  export type BookingInventoryUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingInventoryCreateWithoutBookingInput, BookingInventoryUncheckedCreateWithoutBookingInput> | BookingInventoryCreateWithoutBookingInput[] | BookingInventoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingInventoryCreateOrConnectWithoutBookingInput | BookingInventoryCreateOrConnectWithoutBookingInput[]
    upsert?: BookingInventoryUpsertWithWhereUniqueWithoutBookingInput | BookingInventoryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingInventoryCreateManyBookingInputEnvelope
    set?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    disconnect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    delete?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    connect?: BookingInventoryWhereUniqueInput | BookingInventoryWhereUniqueInput[]
    update?: BookingInventoryUpdateWithWhereUniqueWithoutBookingInput | BookingInventoryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingInventoryUpdateManyWithWhereWithoutBookingInput | BookingInventoryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingInventoryScalarWhereInput | BookingInventoryScalarWhereInput[]
  }

  export type BookingBallboyUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingBallboyCreateWithoutBookingInput, BookingBallboyUncheckedCreateWithoutBookingInput> | BookingBallboyCreateWithoutBookingInput[] | BookingBallboyUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingBallboyCreateOrConnectWithoutBookingInput | BookingBallboyCreateOrConnectWithoutBookingInput[]
    upsert?: BookingBallboyUpsertWithWhereUniqueWithoutBookingInput | BookingBallboyUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingBallboyCreateManyBookingInputEnvelope
    set?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    disconnect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    delete?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    connect?: BookingBallboyWhereUniqueInput | BookingBallboyWhereUniqueInput[]
    update?: BookingBallboyUpdateWithWhereUniqueWithoutBookingInput | BookingBallboyUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingBallboyUpdateManyWithWhereWithoutBookingInput | BookingBallboyUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingBallboyScalarWhereInput | BookingBallboyScalarWhereInput[]
  }

  export type BookingCoachUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingCoachCreateWithoutBookingInput, BookingCoachUncheckedCreateWithoutBookingInput> | BookingCoachCreateWithoutBookingInput[] | BookingCoachUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutBookingInput | BookingCoachCreateOrConnectWithoutBookingInput[]
    upsert?: BookingCoachUpsertWithWhereUniqueWithoutBookingInput | BookingCoachUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingCoachCreateManyBookingInputEnvelope
    set?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    disconnect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    delete?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    update?: BookingCoachUpdateWithWhereUniqueWithoutBookingInput | BookingCoachUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingCoachUpdateManyWithWhereWithoutBookingInput | BookingCoachUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingCoachScalarWhereInput | BookingCoachScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutBookingInput
    upsert?: InvoiceUpsertWithoutBookingInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutBookingInput, InvoiceUpdateWithoutBookingInput>, InvoiceUncheckedUpdateWithoutBookingInput>
  }

  export type BookingCreateNestedOneWithoutDetailsInput = {
    create?: XOR<BookingCreateWithoutDetailsInput, BookingUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutDetailsInput
    connect?: BookingWhereUniqueInput
  }

  export type SlotCreateNestedOneWithoutBookingDetailsInput = {
    create?: XOR<SlotCreateWithoutBookingDetailsInput, SlotUncheckedCreateWithoutBookingDetailsInput>
    connectOrCreate?: SlotCreateOrConnectWithoutBookingDetailsInput
    connect?: SlotWhereUniqueInput
  }

  export type CourtCreateNestedOneWithoutBookingDetailInput = {
    create?: XOR<CourtCreateWithoutBookingDetailInput, CourtUncheckedCreateWithoutBookingDetailInput>
    connectOrCreate?: CourtCreateOrConnectWithoutBookingDetailInput
    connect?: CourtWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<BookingCreateWithoutDetailsInput, BookingUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutDetailsInput
    upsert?: BookingUpsertWithoutDetailsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutDetailsInput, BookingUpdateWithoutDetailsInput>, BookingUncheckedUpdateWithoutDetailsInput>
  }

  export type SlotUpdateOneRequiredWithoutBookingDetailsNestedInput = {
    create?: XOR<SlotCreateWithoutBookingDetailsInput, SlotUncheckedCreateWithoutBookingDetailsInput>
    connectOrCreate?: SlotCreateOrConnectWithoutBookingDetailsInput
    upsert?: SlotUpsertWithoutBookingDetailsInput
    connect?: SlotWhereUniqueInput
    update?: XOR<XOR<SlotUpdateToOneWithWhereWithoutBookingDetailsInput, SlotUpdateWithoutBookingDetailsInput>, SlotUncheckedUpdateWithoutBookingDetailsInput>
  }

  export type CourtUpdateOneWithoutBookingDetailNestedInput = {
    create?: XOR<CourtCreateWithoutBookingDetailInput, CourtUncheckedCreateWithoutBookingDetailInput>
    connectOrCreate?: CourtCreateOrConnectWithoutBookingDetailInput
    upsert?: CourtUpsertWithoutBookingDetailInput
    disconnect?: CourtWhereInput | boolean
    delete?: CourtWhereInput | boolean
    connect?: CourtWhereUniqueInput
    update?: XOR<XOR<CourtUpdateToOneWithWhereWithoutBookingDetailInput, CourtUpdateWithoutBookingDetailInput>, CourtUncheckedUpdateWithoutBookingDetailInput>
  }

  export type BookingCreateNestedOneWithoutInventoriesInput = {
    create?: XOR<BookingCreateWithoutInventoriesInput, BookingUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInventoriesInput
    connect?: BookingWhereUniqueInput
  }

  export type InventoryCreateNestedOneWithoutBookingInventoryInput = {
    create?: XOR<InventoryCreateWithoutBookingInventoryInput, InventoryUncheckedCreateWithoutBookingInventoryInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutBookingInventoryInput
    connect?: InventoryWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutInventoriesNestedInput = {
    create?: XOR<BookingCreateWithoutInventoriesInput, BookingUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInventoriesInput
    upsert?: BookingUpsertWithoutInventoriesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutInventoriesInput, BookingUpdateWithoutInventoriesInput>, BookingUncheckedUpdateWithoutInventoriesInput>
  }

  export type InventoryUpdateOneRequiredWithoutBookingInventoryNestedInput = {
    create?: XOR<InventoryCreateWithoutBookingInventoryInput, InventoryUncheckedCreateWithoutBookingInventoryInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutBookingInventoryInput
    upsert?: InventoryUpsertWithoutBookingInventoryInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutBookingInventoryInput, InventoryUpdateWithoutBookingInventoryInput>, InventoryUncheckedUpdateWithoutBookingInventoryInput>
  }

  export type BookingCreateNestedOneWithoutBallboysInput = {
    create?: XOR<BookingCreateWithoutBallboysInput, BookingUncheckedCreateWithoutBallboysInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBallboysInput
    connect?: BookingWhereUniqueInput
  }

  export type SlotCreateNestedOneWithoutBookingBallboysInput = {
    create?: XOR<SlotCreateWithoutBookingBallboysInput, SlotUncheckedCreateWithoutBookingBallboysInput>
    connectOrCreate?: SlotCreateOrConnectWithoutBookingBallboysInput
    connect?: SlotWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutBallboysNestedInput = {
    create?: XOR<BookingCreateWithoutBallboysInput, BookingUncheckedCreateWithoutBallboysInput>
    connectOrCreate?: BookingCreateOrConnectWithoutBallboysInput
    upsert?: BookingUpsertWithoutBallboysInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutBallboysInput, BookingUpdateWithoutBallboysInput>, BookingUncheckedUpdateWithoutBallboysInput>
  }

  export type SlotUpdateOneRequiredWithoutBookingBallboysNestedInput = {
    create?: XOR<SlotCreateWithoutBookingBallboysInput, SlotUncheckedCreateWithoutBookingBallboysInput>
    connectOrCreate?: SlotCreateOrConnectWithoutBookingBallboysInput
    upsert?: SlotUpsertWithoutBookingBallboysInput
    connect?: SlotWhereUniqueInput
    update?: XOR<XOR<SlotUpdateToOneWithWhereWithoutBookingBallboysInput, SlotUpdateWithoutBookingBallboysInput>, SlotUncheckedUpdateWithoutBookingBallboysInput>
  }

  export type BookingCoachCreateNestedManyWithoutBookingCoachTypeInput = {
    create?: XOR<BookingCoachCreateWithoutBookingCoachTypeInput, BookingCoachUncheckedCreateWithoutBookingCoachTypeInput> | BookingCoachCreateWithoutBookingCoachTypeInput[] | BookingCoachUncheckedCreateWithoutBookingCoachTypeInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutBookingCoachTypeInput | BookingCoachCreateOrConnectWithoutBookingCoachTypeInput[]
    createMany?: BookingCoachCreateManyBookingCoachTypeInputEnvelope
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
  }

  export type CoachTypeStaffPriceCreateNestedManyWithoutCoachTypeInput = {
    create?: XOR<CoachTypeStaffPriceCreateWithoutCoachTypeInput, CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput> | CoachTypeStaffPriceCreateWithoutCoachTypeInput[] | CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput[]
    connectOrCreate?: CoachTypeStaffPriceCreateOrConnectWithoutCoachTypeInput | CoachTypeStaffPriceCreateOrConnectWithoutCoachTypeInput[]
    createMany?: CoachTypeStaffPriceCreateManyCoachTypeInputEnvelope
    connect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
  }

  export type BookingCoachUncheckedCreateNestedManyWithoutBookingCoachTypeInput = {
    create?: XOR<BookingCoachCreateWithoutBookingCoachTypeInput, BookingCoachUncheckedCreateWithoutBookingCoachTypeInput> | BookingCoachCreateWithoutBookingCoachTypeInput[] | BookingCoachUncheckedCreateWithoutBookingCoachTypeInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutBookingCoachTypeInput | BookingCoachCreateOrConnectWithoutBookingCoachTypeInput[]
    createMany?: BookingCoachCreateManyBookingCoachTypeInputEnvelope
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
  }

  export type CoachTypeStaffPriceUncheckedCreateNestedManyWithoutCoachTypeInput = {
    create?: XOR<CoachTypeStaffPriceCreateWithoutCoachTypeInput, CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput> | CoachTypeStaffPriceCreateWithoutCoachTypeInput[] | CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput[]
    connectOrCreate?: CoachTypeStaffPriceCreateOrConnectWithoutCoachTypeInput | CoachTypeStaffPriceCreateOrConnectWithoutCoachTypeInput[]
    createMany?: CoachTypeStaffPriceCreateManyCoachTypeInputEnvelope
    connect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
  }

  export type BookingCoachUpdateManyWithoutBookingCoachTypeNestedInput = {
    create?: XOR<BookingCoachCreateWithoutBookingCoachTypeInput, BookingCoachUncheckedCreateWithoutBookingCoachTypeInput> | BookingCoachCreateWithoutBookingCoachTypeInput[] | BookingCoachUncheckedCreateWithoutBookingCoachTypeInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutBookingCoachTypeInput | BookingCoachCreateOrConnectWithoutBookingCoachTypeInput[]
    upsert?: BookingCoachUpsertWithWhereUniqueWithoutBookingCoachTypeInput | BookingCoachUpsertWithWhereUniqueWithoutBookingCoachTypeInput[]
    createMany?: BookingCoachCreateManyBookingCoachTypeInputEnvelope
    set?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    disconnect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    delete?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    update?: BookingCoachUpdateWithWhereUniqueWithoutBookingCoachTypeInput | BookingCoachUpdateWithWhereUniqueWithoutBookingCoachTypeInput[]
    updateMany?: BookingCoachUpdateManyWithWhereWithoutBookingCoachTypeInput | BookingCoachUpdateManyWithWhereWithoutBookingCoachTypeInput[]
    deleteMany?: BookingCoachScalarWhereInput | BookingCoachScalarWhereInput[]
  }

  export type CoachTypeStaffPriceUpdateManyWithoutCoachTypeNestedInput = {
    create?: XOR<CoachTypeStaffPriceCreateWithoutCoachTypeInput, CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput> | CoachTypeStaffPriceCreateWithoutCoachTypeInput[] | CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput[]
    connectOrCreate?: CoachTypeStaffPriceCreateOrConnectWithoutCoachTypeInput | CoachTypeStaffPriceCreateOrConnectWithoutCoachTypeInput[]
    upsert?: CoachTypeStaffPriceUpsertWithWhereUniqueWithoutCoachTypeInput | CoachTypeStaffPriceUpsertWithWhereUniqueWithoutCoachTypeInput[]
    createMany?: CoachTypeStaffPriceCreateManyCoachTypeInputEnvelope
    set?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    disconnect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    delete?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    connect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    update?: CoachTypeStaffPriceUpdateWithWhereUniqueWithoutCoachTypeInput | CoachTypeStaffPriceUpdateWithWhereUniqueWithoutCoachTypeInput[]
    updateMany?: CoachTypeStaffPriceUpdateManyWithWhereWithoutCoachTypeInput | CoachTypeStaffPriceUpdateManyWithWhereWithoutCoachTypeInput[]
    deleteMany?: CoachTypeStaffPriceScalarWhereInput | CoachTypeStaffPriceScalarWhereInput[]
  }

  export type BookingCoachUncheckedUpdateManyWithoutBookingCoachTypeNestedInput = {
    create?: XOR<BookingCoachCreateWithoutBookingCoachTypeInput, BookingCoachUncheckedCreateWithoutBookingCoachTypeInput> | BookingCoachCreateWithoutBookingCoachTypeInput[] | BookingCoachUncheckedCreateWithoutBookingCoachTypeInput[]
    connectOrCreate?: BookingCoachCreateOrConnectWithoutBookingCoachTypeInput | BookingCoachCreateOrConnectWithoutBookingCoachTypeInput[]
    upsert?: BookingCoachUpsertWithWhereUniqueWithoutBookingCoachTypeInput | BookingCoachUpsertWithWhereUniqueWithoutBookingCoachTypeInput[]
    createMany?: BookingCoachCreateManyBookingCoachTypeInputEnvelope
    set?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    disconnect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    delete?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    connect?: BookingCoachWhereUniqueInput | BookingCoachWhereUniqueInput[]
    update?: BookingCoachUpdateWithWhereUniqueWithoutBookingCoachTypeInput | BookingCoachUpdateWithWhereUniqueWithoutBookingCoachTypeInput[]
    updateMany?: BookingCoachUpdateManyWithWhereWithoutBookingCoachTypeInput | BookingCoachUpdateManyWithWhereWithoutBookingCoachTypeInput[]
    deleteMany?: BookingCoachScalarWhereInput | BookingCoachScalarWhereInput[]
  }

  export type CoachTypeStaffPriceUncheckedUpdateManyWithoutCoachTypeNestedInput = {
    create?: XOR<CoachTypeStaffPriceCreateWithoutCoachTypeInput, CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput> | CoachTypeStaffPriceCreateWithoutCoachTypeInput[] | CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput[]
    connectOrCreate?: CoachTypeStaffPriceCreateOrConnectWithoutCoachTypeInput | CoachTypeStaffPriceCreateOrConnectWithoutCoachTypeInput[]
    upsert?: CoachTypeStaffPriceUpsertWithWhereUniqueWithoutCoachTypeInput | CoachTypeStaffPriceUpsertWithWhereUniqueWithoutCoachTypeInput[]
    createMany?: CoachTypeStaffPriceCreateManyCoachTypeInputEnvelope
    set?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    disconnect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    delete?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    connect?: CoachTypeStaffPriceWhereUniqueInput | CoachTypeStaffPriceWhereUniqueInput[]
    update?: CoachTypeStaffPriceUpdateWithWhereUniqueWithoutCoachTypeInput | CoachTypeStaffPriceUpdateWithWhereUniqueWithoutCoachTypeInput[]
    updateMany?: CoachTypeStaffPriceUpdateManyWithWhereWithoutCoachTypeInput | CoachTypeStaffPriceUpdateManyWithWhereWithoutCoachTypeInput[]
    deleteMany?: CoachTypeStaffPriceScalarWhereInput | CoachTypeStaffPriceScalarWhereInput[]
  }

  export type StaffCreateNestedOneWithoutCoachTypeStaffPriceInput = {
    create?: XOR<StaffCreateWithoutCoachTypeStaffPriceInput, StaffUncheckedCreateWithoutCoachTypeStaffPriceInput>
    connectOrCreate?: StaffCreateOrConnectWithoutCoachTypeStaffPriceInput
    connect?: StaffWhereUniqueInput
  }

  export type BookingCoachTypeCreateNestedOneWithoutCoachTypeStaffPriceInput = {
    create?: XOR<BookingCoachTypeCreateWithoutCoachTypeStaffPriceInput, BookingCoachTypeUncheckedCreateWithoutCoachTypeStaffPriceInput>
    connectOrCreate?: BookingCoachTypeCreateOrConnectWithoutCoachTypeStaffPriceInput
    connect?: BookingCoachTypeWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StaffUpdateOneRequiredWithoutCoachTypeStaffPriceNestedInput = {
    create?: XOR<StaffCreateWithoutCoachTypeStaffPriceInput, StaffUncheckedCreateWithoutCoachTypeStaffPriceInput>
    connectOrCreate?: StaffCreateOrConnectWithoutCoachTypeStaffPriceInput
    upsert?: StaffUpsertWithoutCoachTypeStaffPriceInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutCoachTypeStaffPriceInput, StaffUpdateWithoutCoachTypeStaffPriceInput>, StaffUncheckedUpdateWithoutCoachTypeStaffPriceInput>
  }

  export type BookingCoachTypeUpdateOneRequiredWithoutCoachTypeStaffPriceNestedInput = {
    create?: XOR<BookingCoachTypeCreateWithoutCoachTypeStaffPriceInput, BookingCoachTypeUncheckedCreateWithoutCoachTypeStaffPriceInput>
    connectOrCreate?: BookingCoachTypeCreateOrConnectWithoutCoachTypeStaffPriceInput
    upsert?: BookingCoachTypeUpsertWithoutCoachTypeStaffPriceInput
    connect?: BookingCoachTypeWhereUniqueInput
    update?: XOR<XOR<BookingCoachTypeUpdateToOneWithWhereWithoutCoachTypeStaffPriceInput, BookingCoachTypeUpdateWithoutCoachTypeStaffPriceInput>, BookingCoachTypeUncheckedUpdateWithoutCoachTypeStaffPriceInput>
  }

  export type BookingCreateNestedOneWithoutCoachesInput = {
    create?: XOR<BookingCreateWithoutCoachesInput, BookingUncheckedCreateWithoutCoachesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCoachesInput
    connect?: BookingWhereUniqueInput
  }

  export type SlotCreateNestedOneWithoutBookingCoachesInput = {
    create?: XOR<SlotCreateWithoutBookingCoachesInput, SlotUncheckedCreateWithoutBookingCoachesInput>
    connectOrCreate?: SlotCreateOrConnectWithoutBookingCoachesInput
    connect?: SlotWhereUniqueInput
  }

  export type BookingCoachTypeCreateNestedOneWithoutBookingCoachInput = {
    create?: XOR<BookingCoachTypeCreateWithoutBookingCoachInput, BookingCoachTypeUncheckedCreateWithoutBookingCoachInput>
    connectOrCreate?: BookingCoachTypeCreateOrConnectWithoutBookingCoachInput
    connect?: BookingCoachTypeWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutCoachesNestedInput = {
    create?: XOR<BookingCreateWithoutCoachesInput, BookingUncheckedCreateWithoutCoachesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCoachesInput
    upsert?: BookingUpsertWithoutCoachesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCoachesInput, BookingUpdateWithoutCoachesInput>, BookingUncheckedUpdateWithoutCoachesInput>
  }

  export type SlotUpdateOneRequiredWithoutBookingCoachesNestedInput = {
    create?: XOR<SlotCreateWithoutBookingCoachesInput, SlotUncheckedCreateWithoutBookingCoachesInput>
    connectOrCreate?: SlotCreateOrConnectWithoutBookingCoachesInput
    upsert?: SlotUpsertWithoutBookingCoachesInput
    connect?: SlotWhereUniqueInput
    update?: XOR<XOR<SlotUpdateToOneWithWhereWithoutBookingCoachesInput, SlotUpdateWithoutBookingCoachesInput>, SlotUncheckedUpdateWithoutBookingCoachesInput>
  }

  export type BookingCoachTypeUpdateOneRequiredWithoutBookingCoachNestedInput = {
    create?: XOR<BookingCoachTypeCreateWithoutBookingCoachInput, BookingCoachTypeUncheckedCreateWithoutBookingCoachInput>
    connectOrCreate?: BookingCoachTypeCreateOrConnectWithoutBookingCoachInput
    upsert?: BookingCoachTypeUpsertWithoutBookingCoachInput
    connect?: BookingCoachTypeWhereUniqueInput
    update?: XOR<XOR<BookingCoachTypeUpdateToOneWithWhereWithoutBookingCoachInput, BookingCoachTypeUpdateWithoutBookingCoachInput>, BookingCoachTypeUncheckedUpdateWithoutBookingCoachInput>
  }

  export type MembershipBenefitCreateNestedManyWithoutMembershipInput = {
    create?: XOR<MembershipBenefitCreateWithoutMembershipInput, MembershipBenefitUncheckedCreateWithoutMembershipInput> | MembershipBenefitCreateWithoutMembershipInput[] | MembershipBenefitUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: MembershipBenefitCreateOrConnectWithoutMembershipInput | MembershipBenefitCreateOrConnectWithoutMembershipInput[]
    createMany?: MembershipBenefitCreateManyMembershipInputEnvelope
    connect?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
  }

  export type MembershipUserCreateNestedManyWithoutMembershipInput = {
    create?: XOR<MembershipUserCreateWithoutMembershipInput, MembershipUserUncheckedCreateWithoutMembershipInput> | MembershipUserCreateWithoutMembershipInput[] | MembershipUserUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: MembershipUserCreateOrConnectWithoutMembershipInput | MembershipUserCreateOrConnectWithoutMembershipInput[]
    createMany?: MembershipUserCreateManyMembershipInputEnvelope
    connect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
  }

  export type MembershipBenefitUncheckedCreateNestedManyWithoutMembershipInput = {
    create?: XOR<MembershipBenefitCreateWithoutMembershipInput, MembershipBenefitUncheckedCreateWithoutMembershipInput> | MembershipBenefitCreateWithoutMembershipInput[] | MembershipBenefitUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: MembershipBenefitCreateOrConnectWithoutMembershipInput | MembershipBenefitCreateOrConnectWithoutMembershipInput[]
    createMany?: MembershipBenefitCreateManyMembershipInputEnvelope
    connect?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
  }

  export type MembershipUserUncheckedCreateNestedManyWithoutMembershipInput = {
    create?: XOR<MembershipUserCreateWithoutMembershipInput, MembershipUserUncheckedCreateWithoutMembershipInput> | MembershipUserCreateWithoutMembershipInput[] | MembershipUserUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: MembershipUserCreateOrConnectWithoutMembershipInput | MembershipUserCreateOrConnectWithoutMembershipInput[]
    createMany?: MembershipUserCreateManyMembershipInputEnvelope
    connect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
  }

  export type MembershipBenefitUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<MembershipBenefitCreateWithoutMembershipInput, MembershipBenefitUncheckedCreateWithoutMembershipInput> | MembershipBenefitCreateWithoutMembershipInput[] | MembershipBenefitUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: MembershipBenefitCreateOrConnectWithoutMembershipInput | MembershipBenefitCreateOrConnectWithoutMembershipInput[]
    upsert?: MembershipBenefitUpsertWithWhereUniqueWithoutMembershipInput | MembershipBenefitUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: MembershipBenefitCreateManyMembershipInputEnvelope
    set?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
    disconnect?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
    delete?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
    connect?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
    update?: MembershipBenefitUpdateWithWhereUniqueWithoutMembershipInput | MembershipBenefitUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: MembershipBenefitUpdateManyWithWhereWithoutMembershipInput | MembershipBenefitUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: MembershipBenefitScalarWhereInput | MembershipBenefitScalarWhereInput[]
  }

  export type MembershipUserUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<MembershipUserCreateWithoutMembershipInput, MembershipUserUncheckedCreateWithoutMembershipInput> | MembershipUserCreateWithoutMembershipInput[] | MembershipUserUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: MembershipUserCreateOrConnectWithoutMembershipInput | MembershipUserCreateOrConnectWithoutMembershipInput[]
    upsert?: MembershipUserUpsertWithWhereUniqueWithoutMembershipInput | MembershipUserUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: MembershipUserCreateManyMembershipInputEnvelope
    set?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    disconnect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    delete?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    connect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    update?: MembershipUserUpdateWithWhereUniqueWithoutMembershipInput | MembershipUserUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: MembershipUserUpdateManyWithWhereWithoutMembershipInput | MembershipUserUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: MembershipUserScalarWhereInput | MembershipUserScalarWhereInput[]
  }

  export type MembershipBenefitUncheckedUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<MembershipBenefitCreateWithoutMembershipInput, MembershipBenefitUncheckedCreateWithoutMembershipInput> | MembershipBenefitCreateWithoutMembershipInput[] | MembershipBenefitUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: MembershipBenefitCreateOrConnectWithoutMembershipInput | MembershipBenefitCreateOrConnectWithoutMembershipInput[]
    upsert?: MembershipBenefitUpsertWithWhereUniqueWithoutMembershipInput | MembershipBenefitUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: MembershipBenefitCreateManyMembershipInputEnvelope
    set?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
    disconnect?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
    delete?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
    connect?: MembershipBenefitWhereUniqueInput | MembershipBenefitWhereUniqueInput[]
    update?: MembershipBenefitUpdateWithWhereUniqueWithoutMembershipInput | MembershipBenefitUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: MembershipBenefitUpdateManyWithWhereWithoutMembershipInput | MembershipBenefitUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: MembershipBenefitScalarWhereInput | MembershipBenefitScalarWhereInput[]
  }

  export type MembershipUserUncheckedUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<MembershipUserCreateWithoutMembershipInput, MembershipUserUncheckedCreateWithoutMembershipInput> | MembershipUserCreateWithoutMembershipInput[] | MembershipUserUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: MembershipUserCreateOrConnectWithoutMembershipInput | MembershipUserCreateOrConnectWithoutMembershipInput[]
    upsert?: MembershipUserUpsertWithWhereUniqueWithoutMembershipInput | MembershipUserUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: MembershipUserCreateManyMembershipInputEnvelope
    set?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    disconnect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    delete?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    connect?: MembershipUserWhereUniqueInput | MembershipUserWhereUniqueInput[]
    update?: MembershipUserUpdateWithWhereUniqueWithoutMembershipInput | MembershipUserUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: MembershipUserUpdateManyWithWhereWithoutMembershipInput | MembershipUserUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: MembershipUserScalarWhereInput | MembershipUserScalarWhereInput[]
  }

  export type MembershipCreateNestedOneWithoutBenefitsInput = {
    create?: XOR<MembershipCreateWithoutBenefitsInput, MembershipUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutBenefitsInput
    connect?: MembershipWhereUniqueInput
  }

  export type MembershipUpdateOneRequiredWithoutBenefitsNestedInput = {
    create?: XOR<MembershipCreateWithoutBenefitsInput, MembershipUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutBenefitsInput
    upsert?: MembershipUpsertWithoutBenefitsInput
    connect?: MembershipWhereUniqueInput
    update?: XOR<XOR<MembershipUpdateToOneWithWhereWithoutBenefitsInput, MembershipUpdateWithoutBenefitsInput>, MembershipUncheckedUpdateWithoutBenefitsInput>
  }

  export type UserCreateNestedOneWithoutMembershipUserInput = {
    create?: XOR<UserCreateWithoutMembershipUserInput, UserUncheckedCreateWithoutMembershipUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipUserInput
    connect?: UserWhereUniqueInput
  }

  export type MembershipCreateNestedOneWithoutMembershipUserInput = {
    create?: XOR<MembershipCreateWithoutMembershipUserInput, MembershipUncheckedCreateWithoutMembershipUserInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutMembershipUserInput
    connect?: MembershipWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutMembershipUserInput = {
    create?: XOR<InvoiceCreateWithoutMembershipUserInput, InvoiceUncheckedCreateWithoutMembershipUserInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutMembershipUserInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUncheckedCreateNestedOneWithoutMembershipUserInput = {
    create?: XOR<InvoiceCreateWithoutMembershipUserInput, InvoiceUncheckedCreateWithoutMembershipUserInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutMembershipUserInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMembershipUserNestedInput = {
    create?: XOR<UserCreateWithoutMembershipUserInput, UserUncheckedCreateWithoutMembershipUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipUserInput
    upsert?: UserUpsertWithoutMembershipUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipUserInput, UserUpdateWithoutMembershipUserInput>, UserUncheckedUpdateWithoutMembershipUserInput>
  }

  export type MembershipUpdateOneRequiredWithoutMembershipUserNestedInput = {
    create?: XOR<MembershipCreateWithoutMembershipUserInput, MembershipUncheckedCreateWithoutMembershipUserInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutMembershipUserInput
    upsert?: MembershipUpsertWithoutMembershipUserInput
    connect?: MembershipWhereUniqueInput
    update?: XOR<XOR<MembershipUpdateToOneWithWhereWithoutMembershipUserInput, MembershipUpdateWithoutMembershipUserInput>, MembershipUncheckedUpdateWithoutMembershipUserInput>
  }

  export type InvoiceUpdateOneWithoutMembershipUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutMembershipUserInput, InvoiceUncheckedCreateWithoutMembershipUserInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutMembershipUserInput
    upsert?: InvoiceUpsertWithoutMembershipUserInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutMembershipUserInput, InvoiceUpdateWithoutMembershipUserInput>, InvoiceUncheckedUpdateWithoutMembershipUserInput>
  }

  export type InvoiceUncheckedUpdateOneWithoutMembershipUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutMembershipUserInput, InvoiceUncheckedCreateWithoutMembershipUserInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutMembershipUserInput
    upsert?: InvoiceUpsertWithoutMembershipUserInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutMembershipUserInput, InvoiceUpdateWithoutMembershipUserInput>, InvoiceUncheckedUpdateWithoutMembershipUserInput>
  }

  export type ClassBookingCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput> | ClassBookingCreateWithoutClassInput[] | ClassBookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutClassInput | ClassBookingCreateOrConnectWithoutClassInput[]
    createMany?: ClassBookingCreateManyClassInputEnvelope
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
  }

  export type ClassBookingUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput> | ClassBookingCreateWithoutClassInput[] | ClassBookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutClassInput | ClassBookingCreateOrConnectWithoutClassInput[]
    createMany?: ClassBookingCreateManyClassInputEnvelope
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type ClassBookingUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput> | ClassBookingCreateWithoutClassInput[] | ClassBookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutClassInput | ClassBookingCreateOrConnectWithoutClassInput[]
    upsert?: ClassBookingUpsertWithWhereUniqueWithoutClassInput | ClassBookingUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassBookingCreateManyClassInputEnvelope
    set?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    disconnect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    delete?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    update?: ClassBookingUpdateWithWhereUniqueWithoutClassInput | ClassBookingUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassBookingUpdateManyWithWhereWithoutClassInput | ClassBookingUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
  }

  export type ClassBookingUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput> | ClassBookingCreateWithoutClassInput[] | ClassBookingUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassBookingCreateOrConnectWithoutClassInput | ClassBookingCreateOrConnectWithoutClassInput[]
    upsert?: ClassBookingUpsertWithWhereUniqueWithoutClassInput | ClassBookingUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassBookingCreateManyClassInputEnvelope
    set?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    disconnect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    delete?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    connect?: ClassBookingWhereUniqueInput | ClassBookingWhereUniqueInput[]
    update?: ClassBookingUpdateWithWhereUniqueWithoutClassInput | ClassBookingUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassBookingUpdateManyWithWhereWithoutClassInput | ClassBookingUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutClassBookingsInput = {
    create?: XOR<ClassCreateWithoutClassBookingsInput, ClassUncheckedCreateWithoutClassBookingsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassBookingsInput
    connect?: ClassWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassBookingsInput = {
    create?: XOR<UserCreateWithoutClassBookingsInput, UserUncheckedCreateWithoutClassBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassBookingDetailCreateNestedManyWithoutClassBookingInput = {
    create?: XOR<ClassBookingDetailCreateWithoutClassBookingInput, ClassBookingDetailUncheckedCreateWithoutClassBookingInput> | ClassBookingDetailCreateWithoutClassBookingInput[] | ClassBookingDetailUncheckedCreateWithoutClassBookingInput[]
    connectOrCreate?: ClassBookingDetailCreateOrConnectWithoutClassBookingInput | ClassBookingDetailCreateOrConnectWithoutClassBookingInput[]
    createMany?: ClassBookingDetailCreateManyClassBookingInputEnvelope
    connect?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutClassBookingInput = {
    create?: XOR<InvoiceCreateWithoutClassBookingInput, InvoiceUncheckedCreateWithoutClassBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutClassBookingInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ClassBookingDetailUncheckedCreateNestedManyWithoutClassBookingInput = {
    create?: XOR<ClassBookingDetailCreateWithoutClassBookingInput, ClassBookingDetailUncheckedCreateWithoutClassBookingInput> | ClassBookingDetailCreateWithoutClassBookingInput[] | ClassBookingDetailUncheckedCreateWithoutClassBookingInput[]
    connectOrCreate?: ClassBookingDetailCreateOrConnectWithoutClassBookingInput | ClassBookingDetailCreateOrConnectWithoutClassBookingInput[]
    createMany?: ClassBookingDetailCreateManyClassBookingInputEnvelope
    connect?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutClassBookingInput = {
    create?: XOR<InvoiceCreateWithoutClassBookingInput, InvoiceUncheckedCreateWithoutClassBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutClassBookingInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutClassBookingsNestedInput = {
    create?: XOR<ClassCreateWithoutClassBookingsInput, ClassUncheckedCreateWithoutClassBookingsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassBookingsInput
    upsert?: ClassUpsertWithoutClassBookingsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutClassBookingsInput, ClassUpdateWithoutClassBookingsInput>, ClassUncheckedUpdateWithoutClassBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutClassBookingsNestedInput = {
    create?: XOR<UserCreateWithoutClassBookingsInput, UserUncheckedCreateWithoutClassBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassBookingsInput
    upsert?: UserUpsertWithoutClassBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassBookingsInput, UserUpdateWithoutClassBookingsInput>, UserUncheckedUpdateWithoutClassBookingsInput>
  }

  export type ClassBookingDetailUpdateManyWithoutClassBookingNestedInput = {
    create?: XOR<ClassBookingDetailCreateWithoutClassBookingInput, ClassBookingDetailUncheckedCreateWithoutClassBookingInput> | ClassBookingDetailCreateWithoutClassBookingInput[] | ClassBookingDetailUncheckedCreateWithoutClassBookingInput[]
    connectOrCreate?: ClassBookingDetailCreateOrConnectWithoutClassBookingInput | ClassBookingDetailCreateOrConnectWithoutClassBookingInput[]
    upsert?: ClassBookingDetailUpsertWithWhereUniqueWithoutClassBookingInput | ClassBookingDetailUpsertWithWhereUniqueWithoutClassBookingInput[]
    createMany?: ClassBookingDetailCreateManyClassBookingInputEnvelope
    set?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
    disconnect?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
    delete?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
    connect?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
    update?: ClassBookingDetailUpdateWithWhereUniqueWithoutClassBookingInput | ClassBookingDetailUpdateWithWhereUniqueWithoutClassBookingInput[]
    updateMany?: ClassBookingDetailUpdateManyWithWhereWithoutClassBookingInput | ClassBookingDetailUpdateManyWithWhereWithoutClassBookingInput[]
    deleteMany?: ClassBookingDetailScalarWhereInput | ClassBookingDetailScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutClassBookingNestedInput = {
    create?: XOR<InvoiceCreateWithoutClassBookingInput, InvoiceUncheckedCreateWithoutClassBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutClassBookingInput
    upsert?: InvoiceUpsertWithoutClassBookingInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutClassBookingInput, InvoiceUpdateWithoutClassBookingInput>, InvoiceUncheckedUpdateWithoutClassBookingInput>
  }

  export type ClassBookingDetailUncheckedUpdateManyWithoutClassBookingNestedInput = {
    create?: XOR<ClassBookingDetailCreateWithoutClassBookingInput, ClassBookingDetailUncheckedCreateWithoutClassBookingInput> | ClassBookingDetailCreateWithoutClassBookingInput[] | ClassBookingDetailUncheckedCreateWithoutClassBookingInput[]
    connectOrCreate?: ClassBookingDetailCreateOrConnectWithoutClassBookingInput | ClassBookingDetailCreateOrConnectWithoutClassBookingInput[]
    upsert?: ClassBookingDetailUpsertWithWhereUniqueWithoutClassBookingInput | ClassBookingDetailUpsertWithWhereUniqueWithoutClassBookingInput[]
    createMany?: ClassBookingDetailCreateManyClassBookingInputEnvelope
    set?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
    disconnect?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
    delete?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
    connect?: ClassBookingDetailWhereUniqueInput | ClassBookingDetailWhereUniqueInput[]
    update?: ClassBookingDetailUpdateWithWhereUniqueWithoutClassBookingInput | ClassBookingDetailUpdateWithWhereUniqueWithoutClassBookingInput[]
    updateMany?: ClassBookingDetailUpdateManyWithWhereWithoutClassBookingInput | ClassBookingDetailUpdateManyWithWhereWithoutClassBookingInput[]
    deleteMany?: ClassBookingDetailScalarWhereInput | ClassBookingDetailScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutClassBookingNestedInput = {
    create?: XOR<InvoiceCreateWithoutClassBookingInput, InvoiceUncheckedCreateWithoutClassBookingInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutClassBookingInput
    upsert?: InvoiceUpsertWithoutClassBookingInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutClassBookingInput, InvoiceUpdateWithoutClassBookingInput>, InvoiceUncheckedUpdateWithoutClassBookingInput>
  }

  export type ClassBookingCreateNestedOneWithoutDetailsInput = {
    create?: XOR<ClassBookingCreateWithoutDetailsInput, ClassBookingUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: ClassBookingCreateOrConnectWithoutDetailsInput
    connect?: ClassBookingWhereUniqueInput
  }

  export type ClassBookingUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<ClassBookingCreateWithoutDetailsInput, ClassBookingUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: ClassBookingCreateOrConnectWithoutDetailsInput
    upsert?: ClassBookingUpsertWithoutDetailsInput
    connect?: ClassBookingWhereUniqueInput
    update?: XOR<XOR<ClassBookingUpdateToOneWithWhereWithoutDetailsInput, ClassBookingUpdateWithoutDetailsInput>, ClassBookingUncheckedUpdateWithoutDetailsInput>
  }

  export type UserCreateNestedOneWithoutClubsLedInput = {
    create?: XOR<UserCreateWithoutClubsLedInput, UserUncheckedCreateWithoutClubsLedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubsLedInput
    connect?: UserWhereUniqueInput
  }

  export type ClubMemberCreateNestedManyWithoutClubInput = {
    create?: XOR<ClubMemberCreateWithoutClubInput, ClubMemberUncheckedCreateWithoutClubInput> | ClubMemberCreateWithoutClubInput[] | ClubMemberUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ClubMemberCreateOrConnectWithoutClubInput | ClubMemberCreateOrConnectWithoutClubInput[]
    createMany?: ClubMemberCreateManyClubInputEnvelope
    connect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
  }

  export type TournamentRegistrationCreateNestedManyWithoutClubInput = {
    create?: XOR<TournamentRegistrationCreateWithoutClubInput, TournamentRegistrationUncheckedCreateWithoutClubInput> | TournamentRegistrationCreateWithoutClubInput[] | TournamentRegistrationUncheckedCreateWithoutClubInput[]
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutClubInput | TournamentRegistrationCreateOrConnectWithoutClubInput[]
    createMany?: TournamentRegistrationCreateManyClubInputEnvelope
    connect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
  }

  export type ClubMemberUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<ClubMemberCreateWithoutClubInput, ClubMemberUncheckedCreateWithoutClubInput> | ClubMemberCreateWithoutClubInput[] | ClubMemberUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ClubMemberCreateOrConnectWithoutClubInput | ClubMemberCreateOrConnectWithoutClubInput[]
    createMany?: ClubMemberCreateManyClubInputEnvelope
    connect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
  }

  export type TournamentRegistrationUncheckedCreateNestedManyWithoutClubInput = {
    create?: XOR<TournamentRegistrationCreateWithoutClubInput, TournamentRegistrationUncheckedCreateWithoutClubInput> | TournamentRegistrationCreateWithoutClubInput[] | TournamentRegistrationUncheckedCreateWithoutClubInput[]
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutClubInput | TournamentRegistrationCreateOrConnectWithoutClubInput[]
    createMany?: TournamentRegistrationCreateManyClubInputEnvelope
    connect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
  }

  export type EnumClubVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.ClubVisibility
  }

  export type UserUpdateOneRequiredWithoutClubsLedNestedInput = {
    create?: XOR<UserCreateWithoutClubsLedInput, UserUncheckedCreateWithoutClubsLedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubsLedInput
    upsert?: UserUpsertWithoutClubsLedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClubsLedInput, UserUpdateWithoutClubsLedInput>, UserUncheckedUpdateWithoutClubsLedInput>
  }

  export type ClubMemberUpdateManyWithoutClubNestedInput = {
    create?: XOR<ClubMemberCreateWithoutClubInput, ClubMemberUncheckedCreateWithoutClubInput> | ClubMemberCreateWithoutClubInput[] | ClubMemberUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ClubMemberCreateOrConnectWithoutClubInput | ClubMemberCreateOrConnectWithoutClubInput[]
    upsert?: ClubMemberUpsertWithWhereUniqueWithoutClubInput | ClubMemberUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: ClubMemberCreateManyClubInputEnvelope
    set?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    disconnect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    delete?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    connect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    update?: ClubMemberUpdateWithWhereUniqueWithoutClubInput | ClubMemberUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: ClubMemberUpdateManyWithWhereWithoutClubInput | ClubMemberUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: ClubMemberScalarWhereInput | ClubMemberScalarWhereInput[]
  }

  export type TournamentRegistrationUpdateManyWithoutClubNestedInput = {
    create?: XOR<TournamentRegistrationCreateWithoutClubInput, TournamentRegistrationUncheckedCreateWithoutClubInput> | TournamentRegistrationCreateWithoutClubInput[] | TournamentRegistrationUncheckedCreateWithoutClubInput[]
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutClubInput | TournamentRegistrationCreateOrConnectWithoutClubInput[]
    upsert?: TournamentRegistrationUpsertWithWhereUniqueWithoutClubInput | TournamentRegistrationUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: TournamentRegistrationCreateManyClubInputEnvelope
    set?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    disconnect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    delete?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    connect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    update?: TournamentRegistrationUpdateWithWhereUniqueWithoutClubInput | TournamentRegistrationUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: TournamentRegistrationUpdateManyWithWhereWithoutClubInput | TournamentRegistrationUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: TournamentRegistrationScalarWhereInput | TournamentRegistrationScalarWhereInput[]
  }

  export type ClubMemberUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<ClubMemberCreateWithoutClubInput, ClubMemberUncheckedCreateWithoutClubInput> | ClubMemberCreateWithoutClubInput[] | ClubMemberUncheckedCreateWithoutClubInput[]
    connectOrCreate?: ClubMemberCreateOrConnectWithoutClubInput | ClubMemberCreateOrConnectWithoutClubInput[]
    upsert?: ClubMemberUpsertWithWhereUniqueWithoutClubInput | ClubMemberUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: ClubMemberCreateManyClubInputEnvelope
    set?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    disconnect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    delete?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    connect?: ClubMemberWhereUniqueInput | ClubMemberWhereUniqueInput[]
    update?: ClubMemberUpdateWithWhereUniqueWithoutClubInput | ClubMemberUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: ClubMemberUpdateManyWithWhereWithoutClubInput | ClubMemberUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: ClubMemberScalarWhereInput | ClubMemberScalarWhereInput[]
  }

  export type TournamentRegistrationUncheckedUpdateManyWithoutClubNestedInput = {
    create?: XOR<TournamentRegistrationCreateWithoutClubInput, TournamentRegistrationUncheckedCreateWithoutClubInput> | TournamentRegistrationCreateWithoutClubInput[] | TournamentRegistrationUncheckedCreateWithoutClubInput[]
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutClubInput | TournamentRegistrationCreateOrConnectWithoutClubInput[]
    upsert?: TournamentRegistrationUpsertWithWhereUniqueWithoutClubInput | TournamentRegistrationUpsertWithWhereUniqueWithoutClubInput[]
    createMany?: TournamentRegistrationCreateManyClubInputEnvelope
    set?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    disconnect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    delete?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    connect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    update?: TournamentRegistrationUpdateWithWhereUniqueWithoutClubInput | TournamentRegistrationUpdateWithWhereUniqueWithoutClubInput[]
    updateMany?: TournamentRegistrationUpdateManyWithWhereWithoutClubInput | TournamentRegistrationUpdateManyWithWhereWithoutClubInput[]
    deleteMany?: TournamentRegistrationScalarWhereInput | TournamentRegistrationScalarWhereInput[]
  }

  export type ClubCreateNestedOneWithoutClubMemberInput = {
    create?: XOR<ClubCreateWithoutClubMemberInput, ClubUncheckedCreateWithoutClubMemberInput>
    connectOrCreate?: ClubCreateOrConnectWithoutClubMemberInput
    connect?: ClubWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClubMemberInput = {
    create?: XOR<UserCreateWithoutClubMemberInput, UserUncheckedCreateWithoutClubMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubMemberInput
    connect?: UserWhereUniqueInput
  }

  export type ClubUpdateOneRequiredWithoutClubMemberNestedInput = {
    create?: XOR<ClubCreateWithoutClubMemberInput, ClubUncheckedCreateWithoutClubMemberInput>
    connectOrCreate?: ClubCreateOrConnectWithoutClubMemberInput
    upsert?: ClubUpsertWithoutClubMemberInput
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutClubMemberInput, ClubUpdateWithoutClubMemberInput>, ClubUncheckedUpdateWithoutClubMemberInput>
  }

  export type UserUpdateOneRequiredWithoutClubMemberNestedInput = {
    create?: XOR<UserCreateWithoutClubMemberInput, UserUncheckedCreateWithoutClubMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutClubMemberInput
    upsert?: UserUpsertWithoutClubMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClubMemberInput, UserUpdateWithoutClubMemberInput>, UserUncheckedUpdateWithoutClubMemberInput>
  }

  export type TournamentRegistrationCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentRegistrationCreateWithoutTournamentInput, TournamentRegistrationUncheckedCreateWithoutTournamentInput> | TournamentRegistrationCreateWithoutTournamentInput[] | TournamentRegistrationUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutTournamentInput | TournamentRegistrationCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentRegistrationCreateManyTournamentInputEnvelope
    connect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
  }

  export type TournamentRegistrationUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentRegistrationCreateWithoutTournamentInput, TournamentRegistrationUncheckedCreateWithoutTournamentInput> | TournamentRegistrationCreateWithoutTournamentInput[] | TournamentRegistrationUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutTournamentInput | TournamentRegistrationCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentRegistrationCreateManyTournamentInputEnvelope
    connect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
  }

  export type TournamentRegistrationUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentRegistrationCreateWithoutTournamentInput, TournamentRegistrationUncheckedCreateWithoutTournamentInput> | TournamentRegistrationCreateWithoutTournamentInput[] | TournamentRegistrationUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutTournamentInput | TournamentRegistrationCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentRegistrationUpsertWithWhereUniqueWithoutTournamentInput | TournamentRegistrationUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentRegistrationCreateManyTournamentInputEnvelope
    set?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    disconnect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    delete?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    connect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    update?: TournamentRegistrationUpdateWithWhereUniqueWithoutTournamentInput | TournamentRegistrationUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentRegistrationUpdateManyWithWhereWithoutTournamentInput | TournamentRegistrationUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentRegistrationScalarWhereInput | TournamentRegistrationScalarWhereInput[]
  }

  export type TournamentRegistrationUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentRegistrationCreateWithoutTournamentInput, TournamentRegistrationUncheckedCreateWithoutTournamentInput> | TournamentRegistrationCreateWithoutTournamentInput[] | TournamentRegistrationUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutTournamentInput | TournamentRegistrationCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentRegistrationUpsertWithWhereUniqueWithoutTournamentInput | TournamentRegistrationUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentRegistrationCreateManyTournamentInputEnvelope
    set?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    disconnect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    delete?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    connect?: TournamentRegistrationWhereUniqueInput | TournamentRegistrationWhereUniqueInput[]
    update?: TournamentRegistrationUpdateWithWhereUniqueWithoutTournamentInput | TournamentRegistrationUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentRegistrationUpdateManyWithWhereWithoutTournamentInput | TournamentRegistrationUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentRegistrationScalarWhereInput | TournamentRegistrationScalarWhereInput[]
  }

  export type TournamentCreateNestedOneWithoutTournamentRegistrationInput = {
    create?: XOR<TournamentCreateWithoutTournamentRegistrationInput, TournamentUncheckedCreateWithoutTournamentRegistrationInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentRegistrationInput
    connect?: TournamentWhereUniqueInput
  }

  export type ClubCreateNestedOneWithoutTournamentRegistrationInput = {
    create?: XOR<ClubCreateWithoutTournamentRegistrationInput, ClubUncheckedCreateWithoutTournamentRegistrationInput>
    connectOrCreate?: ClubCreateOrConnectWithoutTournamentRegistrationInput
    connect?: ClubWhereUniqueInput
  }

  export type TournamentRegistrationMemberCreateNestedManyWithoutTournamentRegistrationInput = {
    create?: XOR<TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput, TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput> | TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput[] | TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput[]
    connectOrCreate?: TournamentRegistrationMemberCreateOrConnectWithoutTournamentRegistrationInput | TournamentRegistrationMemberCreateOrConnectWithoutTournamentRegistrationInput[]
    createMany?: TournamentRegistrationMemberCreateManyTournamentRegistrationInputEnvelope
    connect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutTournamentRegistrationInput = {
    create?: XOR<InvoiceCreateWithoutTournamentRegistrationInput, InvoiceUncheckedCreateWithoutTournamentRegistrationInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTournamentRegistrationInput
    connect?: InvoiceWhereUniqueInput
  }

  export type TournamentRegistrationMemberUncheckedCreateNestedManyWithoutTournamentRegistrationInput = {
    create?: XOR<TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput, TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput> | TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput[] | TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput[]
    connectOrCreate?: TournamentRegistrationMemberCreateOrConnectWithoutTournamentRegistrationInput | TournamentRegistrationMemberCreateOrConnectWithoutTournamentRegistrationInput[]
    createMany?: TournamentRegistrationMemberCreateManyTournamentRegistrationInputEnvelope
    connect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutTournamentRegistrationInput = {
    create?: XOR<InvoiceCreateWithoutTournamentRegistrationInput, InvoiceUncheckedCreateWithoutTournamentRegistrationInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTournamentRegistrationInput
    connect?: InvoiceWhereUniqueInput
  }

  export type TournamentUpdateOneRequiredWithoutTournamentRegistrationNestedInput = {
    create?: XOR<TournamentCreateWithoutTournamentRegistrationInput, TournamentUncheckedCreateWithoutTournamentRegistrationInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentRegistrationInput
    upsert?: TournamentUpsertWithoutTournamentRegistrationInput
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutTournamentRegistrationInput, TournamentUpdateWithoutTournamentRegistrationInput>, TournamentUncheckedUpdateWithoutTournamentRegistrationInput>
  }

  export type ClubUpdateOneRequiredWithoutTournamentRegistrationNestedInput = {
    create?: XOR<ClubCreateWithoutTournamentRegistrationInput, ClubUncheckedCreateWithoutTournamentRegistrationInput>
    connectOrCreate?: ClubCreateOrConnectWithoutTournamentRegistrationInput
    upsert?: ClubUpsertWithoutTournamentRegistrationInput
    connect?: ClubWhereUniqueInput
    update?: XOR<XOR<ClubUpdateToOneWithWhereWithoutTournamentRegistrationInput, ClubUpdateWithoutTournamentRegistrationInput>, ClubUncheckedUpdateWithoutTournamentRegistrationInput>
  }

  export type TournamentRegistrationMemberUpdateManyWithoutTournamentRegistrationNestedInput = {
    create?: XOR<TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput, TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput> | TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput[] | TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput[]
    connectOrCreate?: TournamentRegistrationMemberCreateOrConnectWithoutTournamentRegistrationInput | TournamentRegistrationMemberCreateOrConnectWithoutTournamentRegistrationInput[]
    upsert?: TournamentRegistrationMemberUpsertWithWhereUniqueWithoutTournamentRegistrationInput | TournamentRegistrationMemberUpsertWithWhereUniqueWithoutTournamentRegistrationInput[]
    createMany?: TournamentRegistrationMemberCreateManyTournamentRegistrationInputEnvelope
    set?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    disconnect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    delete?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    connect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    update?: TournamentRegistrationMemberUpdateWithWhereUniqueWithoutTournamentRegistrationInput | TournamentRegistrationMemberUpdateWithWhereUniqueWithoutTournamentRegistrationInput[]
    updateMany?: TournamentRegistrationMemberUpdateManyWithWhereWithoutTournamentRegistrationInput | TournamentRegistrationMemberUpdateManyWithWhereWithoutTournamentRegistrationInput[]
    deleteMany?: TournamentRegistrationMemberScalarWhereInput | TournamentRegistrationMemberScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutTournamentRegistrationNestedInput = {
    create?: XOR<InvoiceCreateWithoutTournamentRegistrationInput, InvoiceUncheckedCreateWithoutTournamentRegistrationInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTournamentRegistrationInput
    upsert?: InvoiceUpsertWithoutTournamentRegistrationInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTournamentRegistrationInput, InvoiceUpdateWithoutTournamentRegistrationInput>, InvoiceUncheckedUpdateWithoutTournamentRegistrationInput>
  }

  export type TournamentRegistrationMemberUncheckedUpdateManyWithoutTournamentRegistrationNestedInput = {
    create?: XOR<TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput, TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput> | TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput[] | TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput[]
    connectOrCreate?: TournamentRegistrationMemberCreateOrConnectWithoutTournamentRegistrationInput | TournamentRegistrationMemberCreateOrConnectWithoutTournamentRegistrationInput[]
    upsert?: TournamentRegistrationMemberUpsertWithWhereUniqueWithoutTournamentRegistrationInput | TournamentRegistrationMemberUpsertWithWhereUniqueWithoutTournamentRegistrationInput[]
    createMany?: TournamentRegistrationMemberCreateManyTournamentRegistrationInputEnvelope
    set?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    disconnect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    delete?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    connect?: TournamentRegistrationMemberWhereUniqueInput | TournamentRegistrationMemberWhereUniqueInput[]
    update?: TournamentRegistrationMemberUpdateWithWhereUniqueWithoutTournamentRegistrationInput | TournamentRegistrationMemberUpdateWithWhereUniqueWithoutTournamentRegistrationInput[]
    updateMany?: TournamentRegistrationMemberUpdateManyWithWhereWithoutTournamentRegistrationInput | TournamentRegistrationMemberUpdateManyWithWhereWithoutTournamentRegistrationInput[]
    deleteMany?: TournamentRegistrationMemberScalarWhereInput | TournamentRegistrationMemberScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutTournamentRegistrationNestedInput = {
    create?: XOR<InvoiceCreateWithoutTournamentRegistrationInput, InvoiceUncheckedCreateWithoutTournamentRegistrationInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTournamentRegistrationInput
    upsert?: InvoiceUpsertWithoutTournamentRegistrationInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTournamentRegistrationInput, InvoiceUpdateWithoutTournamentRegistrationInput>, InvoiceUncheckedUpdateWithoutTournamentRegistrationInput>
  }

  export type TournamentRegistrationCreateNestedOneWithoutMembersRefInput = {
    create?: XOR<TournamentRegistrationCreateWithoutMembersRefInput, TournamentRegistrationUncheckedCreateWithoutMembersRefInput>
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutMembersRefInput
    connect?: TournamentRegistrationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTournamentRegistrationMemberInput = {
    create?: XOR<UserCreateWithoutTournamentRegistrationMemberInput, UserUncheckedCreateWithoutTournamentRegistrationMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamentRegistrationMemberInput
    connect?: UserWhereUniqueInput
  }

  export type TournamentRegistrationUpdateOneRequiredWithoutMembersRefNestedInput = {
    create?: XOR<TournamentRegistrationCreateWithoutMembersRefInput, TournamentRegistrationUncheckedCreateWithoutMembersRefInput>
    connectOrCreate?: TournamentRegistrationCreateOrConnectWithoutMembersRefInput
    upsert?: TournamentRegistrationUpsertWithoutMembersRefInput
    connect?: TournamentRegistrationWhereUniqueInput
    update?: XOR<XOR<TournamentRegistrationUpdateToOneWithWhereWithoutMembersRefInput, TournamentRegistrationUpdateWithoutMembersRefInput>, TournamentRegistrationUncheckedUpdateWithoutMembersRefInput>
  }

  export type UserUpdateOneRequiredWithoutTournamentRegistrationMemberNestedInput = {
    create?: XOR<UserCreateWithoutTournamentRegistrationMemberInput, UserUncheckedCreateWithoutTournamentRegistrationMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamentRegistrationMemberInput
    upsert?: UserUpsertWithoutTournamentRegistrationMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTournamentRegistrationMemberInput, UserUpdateWithoutTournamentRegistrationMemberInput>, UserUncheckedUpdateWithoutTournamentRegistrationMemberInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPhoneVerificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneVerificationType | EnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PhoneVerificationType[] | ListEnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PhoneVerificationType[] | ListEnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPhoneVerificationTypeNullableFilter<$PrismaModel> | $Enums.PhoneVerificationType | null
  }

  export type NestedEnumPhoneVerificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneVerificationType | EnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PhoneVerificationType[] | ListEnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PhoneVerificationType[] | ListEnumPhoneVerificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPhoneVerificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PhoneVerificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPhoneVerificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPhoneVerificationTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumAuthTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthTokenType | EnumAuthTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthTokenType[] | ListEnumAuthTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthTokenType[] | ListEnumAuthTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTokenTypeFilter<$PrismaModel> | $Enums.AuthTokenType
  }

  export type NestedEnumAuthTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthTokenType | EnumAuthTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthTokenType[] | ListEnumAuthTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthTokenType[] | ListEnumAuthTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthTokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthTokenTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumClubVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubVisibility | EnumClubVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ClubVisibility[] | ListEnumClubVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClubVisibility[] | ListEnumClubVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumClubVisibilityFilter<$PrismaModel> | $Enums.ClubVisibility
  }

  export type NestedEnumClubVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClubVisibility | EnumClubVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ClubVisibility[] | ListEnumClubVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClubVisibility[] | ListEnumClubVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumClubVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ClubVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClubVisibilityFilter<$PrismaModel>
    _max?: NestedEnumClubVisibilityFilter<$PrismaModel>
  }

  export type AuthTokenCreateWithoutUserInput = {
    id?: string
    type?: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutAuthTokensInput
  }

  export type AuthTokenUncheckedCreateWithoutUserInput = {
    id?: string
    staffId?: string | null
    type?: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthTokenCreateOrConnectWithoutUserInput = {
    where: AuthTokenWhereUniqueInput
    create: XOR<AuthTokenCreateWithoutUserInput, AuthTokenUncheckedCreateWithoutUserInput>
  }

  export type AuthTokenCreateManyUserInputEnvelope = {
    data: AuthTokenCreateManyUserInput | AuthTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: BookingDetailCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: BookingDetailUncheckedCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryUncheckedCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyUncheckedCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MembershipUserCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    membership: MembershipCreateNestedOneWithoutMembershipUserInput
    invoice?: InvoiceCreateNestedOneWithoutMembershipUserInput
  }

  export type MembershipUserUncheckedCreateWithoutUserInput = {
    id?: string
    membershipId: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutMembershipUserInput
  }

  export type MembershipUserCreateOrConnectWithoutUserInput = {
    where: MembershipUserWhereUniqueInput
    create: XOR<MembershipUserCreateWithoutUserInput, MembershipUserUncheckedCreateWithoutUserInput>
  }

  export type MembershipUserCreateManyUserInputEnvelope = {
    data: MembershipUserCreateManyUserInput | MembershipUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClassBookingCreateWithoutUserInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    class: ClassCreateNestedOneWithoutClassBookingsInput
    details?: ClassBookingDetailCreateNestedManyWithoutClassBookingInput
    invoice?: InvoiceCreateNestedOneWithoutClassBookingInput
  }

  export type ClassBookingUncheckedCreateWithoutUserInput = {
    id?: string
    classId: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: ClassBookingDetailUncheckedCreateNestedManyWithoutClassBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutClassBookingInput
  }

  export type ClassBookingCreateOrConnectWithoutUserInput = {
    where: ClassBookingWhereUniqueInput
    create: XOR<ClassBookingCreateWithoutUserInput, ClassBookingUncheckedCreateWithoutUserInput>
  }

  export type ClassBookingCreateManyUserInputEnvelope = {
    data: ClassBookingCreateManyUserInput | ClassBookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClubCreateWithoutLeaderInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clubMember?: ClubMemberCreateNestedManyWithoutClubInput
    tournamentRegistration?: TournamentRegistrationCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutLeaderInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutClubInput
    tournamentRegistration?: TournamentRegistrationUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutLeaderInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutLeaderInput, ClubUncheckedCreateWithoutLeaderInput>
  }

  export type ClubCreateManyLeaderInputEnvelope = {
    data: ClubCreateManyLeaderInput | ClubCreateManyLeaderInput[]
    skipDuplicates?: boolean
  }

  export type ClubMemberCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    club: ClubCreateNestedOneWithoutClubMemberInput
  }

  export type ClubMemberUncheckedCreateWithoutUserInput = {
    id?: string
    clubId: string
    joinedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClubMemberCreateOrConnectWithoutUserInput = {
    where: ClubMemberWhereUniqueInput
    create: XOR<ClubMemberCreateWithoutUserInput, ClubMemberUncheckedCreateWithoutUserInput>
  }

  export type ClubMemberCreateManyUserInputEnvelope = {
    data: ClubMemberCreateManyUserInput | ClubMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TournamentRegistrationMemberCreateWithoutUserInput = {
    id?: string
    isHost?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentRegistration: TournamentRegistrationCreateNestedOneWithoutMembersRefInput
  }

  export type TournamentRegistrationMemberUncheckedCreateWithoutUserInput = {
    id?: string
    tournamentRegistrationId: string
    isHost?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentRegistrationMemberCreateOrConnectWithoutUserInput = {
    where: TournamentRegistrationMemberWhereUniqueInput
    create: XOR<TournamentRegistrationMemberCreateWithoutUserInput, TournamentRegistrationMemberUncheckedCreateWithoutUserInput>
  }

  export type TournamentRegistrationMemberCreateManyUserInputEnvelope = {
    data: TournamentRegistrationMemberCreateManyUserInput | TournamentRegistrationMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    number: string
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutInvoiceInput
    booking?: BookingCreateNestedOneWithoutInvoiceInput
    classBooking?: ClassBookingCreateNestedOneWithoutInvoiceInput
    membershipUser?: MembershipUserCreateNestedOneWithoutInvoiceInput
    tournamentRegistration?: TournamentRegistrationCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    bookingId?: string | null
    classBookingId?: string | null
    membershipUserId?: string | null
    tournamentRegistrationId?: string | null
    number: string
    paymentId?: string | null
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuthTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthTokenWhereUniqueInput
    update: XOR<AuthTokenUpdateWithoutUserInput, AuthTokenUncheckedUpdateWithoutUserInput>
    create: XOR<AuthTokenCreateWithoutUserInput, AuthTokenUncheckedCreateWithoutUserInput>
  }

  export type AuthTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthTokenWhereUniqueInput
    data: XOR<AuthTokenUpdateWithoutUserInput, AuthTokenUncheckedUpdateWithoutUserInput>
  }

  export type AuthTokenUpdateManyWithWhereWithoutUserInput = {
    where: AuthTokenScalarWhereInput
    data: XOR<AuthTokenUpdateManyMutationInput, AuthTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthTokenScalarWhereInput = {
    AND?: AuthTokenScalarWhereInput | AuthTokenScalarWhereInput[]
    OR?: AuthTokenScalarWhereInput[]
    NOT?: AuthTokenScalarWhereInput | AuthTokenScalarWhereInput[]
    id?: StringFilter<"AuthToken"> | string
    userId?: StringNullableFilter<"AuthToken"> | string | null
    staffId?: StringNullableFilter<"AuthToken"> | string | null
    type?: EnumAuthTokenTypeFilter<"AuthToken"> | $Enums.AuthTokenType
    refreshToken?: StringFilter<"AuthToken"> | string
    refreshExpiresAt?: DateTimeFilter<"AuthToken"> | Date | string
    createdAt?: DateTimeFilter<"AuthToken"> | Date | string
    updatedAt?: DateTimeFilter<"AuthToken"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    totalPrice?: IntFilter<"Booking"> | number
    processingFee?: IntFilter<"Booking"> | number
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    holdExpiresAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cancellationReason?: StringNullableFilter<"Booking"> | string | null
  }

  export type MembershipUserUpsertWithWhereUniqueWithoutUserInput = {
    where: MembershipUserWhereUniqueInput
    update: XOR<MembershipUserUpdateWithoutUserInput, MembershipUserUncheckedUpdateWithoutUserInput>
    create: XOR<MembershipUserCreateWithoutUserInput, MembershipUserUncheckedCreateWithoutUserInput>
  }

  export type MembershipUserUpdateWithWhereUniqueWithoutUserInput = {
    where: MembershipUserWhereUniqueInput
    data: XOR<MembershipUserUpdateWithoutUserInput, MembershipUserUncheckedUpdateWithoutUserInput>
  }

  export type MembershipUserUpdateManyWithWhereWithoutUserInput = {
    where: MembershipUserScalarWhereInput
    data: XOR<MembershipUserUpdateManyMutationInput, MembershipUserUncheckedUpdateManyWithoutUserInput>
  }

  export type MembershipUserScalarWhereInput = {
    AND?: MembershipUserScalarWhereInput | MembershipUserScalarWhereInput[]
    OR?: MembershipUserScalarWhereInput[]
    NOT?: MembershipUserScalarWhereInput | MembershipUserScalarWhereInput[]
    id?: StringFilter<"MembershipUser"> | string
    userId?: StringFilter<"MembershipUser"> | string
    membershipId?: StringFilter<"MembershipUser"> | string
    startDate?: DateTimeFilter<"MembershipUser"> | Date | string
    endDate?: DateTimeFilter<"MembershipUser"> | Date | string
    remainingSessions?: IntFilter<"MembershipUser"> | number
    remainingDuration?: IntFilter<"MembershipUser"> | number
    isExpired?: BoolFilter<"MembershipUser"> | boolean
    isSuspended?: BoolFilter<"MembershipUser"> | boolean
    suspensionReason?: StringNullableFilter<"MembershipUser"> | string | null
    suspensionEndDate?: DateTimeNullableFilter<"MembershipUser"> | Date | string | null
    createdAt?: DateTimeFilter<"MembershipUser"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipUser"> | Date | string
  }

  export type ClassBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: ClassBookingWhereUniqueInput
    update: XOR<ClassBookingUpdateWithoutUserInput, ClassBookingUncheckedUpdateWithoutUserInput>
    create: XOR<ClassBookingCreateWithoutUserInput, ClassBookingUncheckedCreateWithoutUserInput>
  }

  export type ClassBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: ClassBookingWhereUniqueInput
    data: XOR<ClassBookingUpdateWithoutUserInput, ClassBookingUncheckedUpdateWithoutUserInput>
  }

  export type ClassBookingUpdateManyWithWhereWithoutUserInput = {
    where: ClassBookingScalarWhereInput
    data: XOR<ClassBookingUpdateManyMutationInput, ClassBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type ClassBookingScalarWhereInput = {
    AND?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
    OR?: ClassBookingScalarWhereInput[]
    NOT?: ClassBookingScalarWhereInput | ClassBookingScalarWhereInput[]
    id?: StringFilter<"ClassBooking"> | string
    classId?: StringFilter<"ClassBooking"> | string
    userId?: StringFilter<"ClassBooking"> | string
    status?: EnumBookingStatusFilter<"ClassBooking"> | $Enums.BookingStatus
    totalPrice?: IntFilter<"ClassBooking"> | number
    processingFee?: IntFilter<"ClassBooking"> | number
    createdAt?: DateTimeFilter<"ClassBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ClassBooking"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"ClassBooking"> | Date | string | null
    cancellationReason?: StringNullableFilter<"ClassBooking"> | string | null
  }

  export type ClubUpsertWithWhereUniqueWithoutLeaderInput = {
    where: ClubWhereUniqueInput
    update: XOR<ClubUpdateWithoutLeaderInput, ClubUncheckedUpdateWithoutLeaderInput>
    create: XOR<ClubCreateWithoutLeaderInput, ClubUncheckedCreateWithoutLeaderInput>
  }

  export type ClubUpdateWithWhereUniqueWithoutLeaderInput = {
    where: ClubWhereUniqueInput
    data: XOR<ClubUpdateWithoutLeaderInput, ClubUncheckedUpdateWithoutLeaderInput>
  }

  export type ClubUpdateManyWithWhereWithoutLeaderInput = {
    where: ClubScalarWhereInput
    data: XOR<ClubUpdateManyMutationInput, ClubUncheckedUpdateManyWithoutLeaderInput>
  }

  export type ClubScalarWhereInput = {
    AND?: ClubScalarWhereInput | ClubScalarWhereInput[]
    OR?: ClubScalarWhereInput[]
    NOT?: ClubScalarWhereInput | ClubScalarWhereInput[]
    id?: StringFilter<"Club"> | string
    name?: StringFilter<"Club"> | string
    logo?: StringNullableFilter<"Club"> | string | null
    description?: StringNullableFilter<"Club"> | string | null
    rules?: StringNullableFilter<"Club"> | string | null
    leaderId?: StringFilter<"Club"> | string
    visibility?: EnumClubVisibilityFilter<"Club"> | $Enums.ClubVisibility
    isActive?: BoolFilter<"Club"> | boolean
    createdAt?: DateTimeFilter<"Club"> | Date | string
    updatedAt?: DateTimeFilter<"Club"> | Date | string
  }

  export type ClubMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ClubMemberWhereUniqueInput
    update: XOR<ClubMemberUpdateWithoutUserInput, ClubMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ClubMemberCreateWithoutUserInput, ClubMemberUncheckedCreateWithoutUserInput>
  }

  export type ClubMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ClubMemberWhereUniqueInput
    data: XOR<ClubMemberUpdateWithoutUserInput, ClubMemberUncheckedUpdateWithoutUserInput>
  }

  export type ClubMemberUpdateManyWithWhereWithoutUserInput = {
    where: ClubMemberScalarWhereInput
    data: XOR<ClubMemberUpdateManyMutationInput, ClubMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ClubMemberScalarWhereInput = {
    AND?: ClubMemberScalarWhereInput | ClubMemberScalarWhereInput[]
    OR?: ClubMemberScalarWhereInput[]
    NOT?: ClubMemberScalarWhereInput | ClubMemberScalarWhereInput[]
    id?: StringFilter<"ClubMember"> | string
    clubId?: StringFilter<"ClubMember"> | string
    userId?: StringFilter<"ClubMember"> | string
    joinedAt?: DateTimeFilter<"ClubMember"> | Date | string
    isActive?: BoolFilter<"ClubMember"> | boolean
    createdAt?: DateTimeFilter<"ClubMember"> | Date | string
    updatedAt?: DateTimeFilter<"ClubMember"> | Date | string
  }

  export type TournamentRegistrationMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TournamentRegistrationMemberWhereUniqueInput
    update: XOR<TournamentRegistrationMemberUpdateWithoutUserInput, TournamentRegistrationMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TournamentRegistrationMemberCreateWithoutUserInput, TournamentRegistrationMemberUncheckedCreateWithoutUserInput>
  }

  export type TournamentRegistrationMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TournamentRegistrationMemberWhereUniqueInput
    data: XOR<TournamentRegistrationMemberUpdateWithoutUserInput, TournamentRegistrationMemberUncheckedUpdateWithoutUserInput>
  }

  export type TournamentRegistrationMemberUpdateManyWithWhereWithoutUserInput = {
    where: TournamentRegistrationMemberScalarWhereInput
    data: XOR<TournamentRegistrationMemberUpdateManyMutationInput, TournamentRegistrationMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TournamentRegistrationMemberScalarWhereInput = {
    AND?: TournamentRegistrationMemberScalarWhereInput | TournamentRegistrationMemberScalarWhereInput[]
    OR?: TournamentRegistrationMemberScalarWhereInput[]
    NOT?: TournamentRegistrationMemberScalarWhereInput | TournamentRegistrationMemberScalarWhereInput[]
    id?: StringFilter<"TournamentRegistrationMember"> | string
    tournamentRegistrationId?: StringFilter<"TournamentRegistrationMember"> | string
    userId?: StringFilter<"TournamentRegistrationMember"> | string
    isHost?: BoolFilter<"TournamentRegistrationMember"> | boolean
    createdAt?: DateTimeFilter<"TournamentRegistrationMember"> | Date | string
    updatedAt?: DateTimeFilter<"TournamentRegistrationMember"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    bookingId?: StringNullableFilter<"Invoice"> | string | null
    classBookingId?: StringNullableFilter<"Invoice"> | string | null
    membershipUserId?: StringNullableFilter<"Invoice"> | string | null
    tournamentRegistrationId?: StringNullableFilter<"Invoice"> | string | null
    number?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    paymentId?: StringNullableFilter<"Invoice"> | string | null
    subtotal?: IntFilter<"Invoice"> | number
    processingFee?: IntFilter<"Invoice"> | number
    total?: IntFilter<"Invoice"> | number
    status?: EnumPaymentStatusFilter<"Invoice"> | $Enums.PaymentStatus
    issuedAt?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
  }

  export type AuthTokenCreateWithoutStaffInput = {
    id?: string
    type?: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAuthTokensInput
  }

  export type AuthTokenUncheckedCreateWithoutStaffInput = {
    id?: string
    userId?: string | null
    type?: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthTokenCreateOrConnectWithoutStaffInput = {
    where: AuthTokenWhereUniqueInput
    create: XOR<AuthTokenCreateWithoutStaffInput, AuthTokenUncheckedCreateWithoutStaffInput>
  }

  export type AuthTokenCreateManyStaffInputEnvelope = {
    data: AuthTokenCreateManyStaffInput | AuthTokenCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type SlotCreateWithoutStaffInput = {
    id?: string
    type: $Enums.SlotType
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    court?: CourtCreateNestedOneWithoutSlotInput
    bookingDetails?: BookingDetailCreateNestedManyWithoutSlotInput
    bookingCoaches?: BookingCoachCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyCreateNestedManyWithoutSlotInput
  }

  export type SlotUncheckedCreateWithoutStaffInput = {
    id?: string
    type: $Enums.SlotType
    courtId?: string | null
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingDetails?: BookingDetailUncheckedCreateNestedManyWithoutSlotInput
    bookingCoaches?: BookingCoachUncheckedCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyUncheckedCreateNestedManyWithoutSlotInput
  }

  export type SlotCreateOrConnectWithoutStaffInput = {
    where: SlotWhereUniqueInput
    create: XOR<SlotCreateWithoutStaffInput, SlotUncheckedCreateWithoutStaffInput>
  }

  export type SlotCreateManyStaffInputEnvelope = {
    data: SlotCreateManyStaffInput | SlotCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type CoachTypeStaffPriceCreateWithoutStaffInput = {
    id?: string
    basePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    coachType: BookingCoachTypeCreateNestedOneWithoutCoachTypeStaffPriceInput
  }

  export type CoachTypeStaffPriceUncheckedCreateWithoutStaffInput = {
    id?: string
    coachTypeId: string
    basePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachTypeStaffPriceCreateOrConnectWithoutStaffInput = {
    where: CoachTypeStaffPriceWhereUniqueInput
    create: XOR<CoachTypeStaffPriceCreateWithoutStaffInput, CoachTypeStaffPriceUncheckedCreateWithoutStaffInput>
  }

  export type CoachTypeStaffPriceCreateManyStaffInputEnvelope = {
    data: CoachTypeStaffPriceCreateManyStaffInput | CoachTypeStaffPriceCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type AuthTokenUpsertWithWhereUniqueWithoutStaffInput = {
    where: AuthTokenWhereUniqueInput
    update: XOR<AuthTokenUpdateWithoutStaffInput, AuthTokenUncheckedUpdateWithoutStaffInput>
    create: XOR<AuthTokenCreateWithoutStaffInput, AuthTokenUncheckedCreateWithoutStaffInput>
  }

  export type AuthTokenUpdateWithWhereUniqueWithoutStaffInput = {
    where: AuthTokenWhereUniqueInput
    data: XOR<AuthTokenUpdateWithoutStaffInput, AuthTokenUncheckedUpdateWithoutStaffInput>
  }

  export type AuthTokenUpdateManyWithWhereWithoutStaffInput = {
    where: AuthTokenScalarWhereInput
    data: XOR<AuthTokenUpdateManyMutationInput, AuthTokenUncheckedUpdateManyWithoutStaffInput>
  }

  export type SlotUpsertWithWhereUniqueWithoutStaffInput = {
    where: SlotWhereUniqueInput
    update: XOR<SlotUpdateWithoutStaffInput, SlotUncheckedUpdateWithoutStaffInput>
    create: XOR<SlotCreateWithoutStaffInput, SlotUncheckedCreateWithoutStaffInput>
  }

  export type SlotUpdateWithWhereUniqueWithoutStaffInput = {
    where: SlotWhereUniqueInput
    data: XOR<SlotUpdateWithoutStaffInput, SlotUncheckedUpdateWithoutStaffInput>
  }

  export type SlotUpdateManyWithWhereWithoutStaffInput = {
    where: SlotScalarWhereInput
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyWithoutStaffInput>
  }

  export type SlotScalarWhereInput = {
    AND?: SlotScalarWhereInput | SlotScalarWhereInput[]
    OR?: SlotScalarWhereInput[]
    NOT?: SlotScalarWhereInput | SlotScalarWhereInput[]
    id?: StringFilter<"Slot"> | string
    type?: EnumSlotTypeFilter<"Slot"> | $Enums.SlotType
    courtId?: StringNullableFilter<"Slot"> | string | null
    staffId?: StringNullableFilter<"Slot"> | string | null
    startAt?: DateTimeFilter<"Slot"> | Date | string
    endAt?: DateTimeFilter<"Slot"> | Date | string
    price?: IntFilter<"Slot"> | number
    isAvailable?: BoolFilter<"Slot"> | boolean
    createdAt?: DateTimeFilter<"Slot"> | Date | string
    updatedAt?: DateTimeFilter<"Slot"> | Date | string
  }

  export type CoachTypeStaffPriceUpsertWithWhereUniqueWithoutStaffInput = {
    where: CoachTypeStaffPriceWhereUniqueInput
    update: XOR<CoachTypeStaffPriceUpdateWithoutStaffInput, CoachTypeStaffPriceUncheckedUpdateWithoutStaffInput>
    create: XOR<CoachTypeStaffPriceCreateWithoutStaffInput, CoachTypeStaffPriceUncheckedCreateWithoutStaffInput>
  }

  export type CoachTypeStaffPriceUpdateWithWhereUniqueWithoutStaffInput = {
    where: CoachTypeStaffPriceWhereUniqueInput
    data: XOR<CoachTypeStaffPriceUpdateWithoutStaffInput, CoachTypeStaffPriceUncheckedUpdateWithoutStaffInput>
  }

  export type CoachTypeStaffPriceUpdateManyWithWhereWithoutStaffInput = {
    where: CoachTypeStaffPriceScalarWhereInput
    data: XOR<CoachTypeStaffPriceUpdateManyMutationInput, CoachTypeStaffPriceUncheckedUpdateManyWithoutStaffInput>
  }

  export type CoachTypeStaffPriceScalarWhereInput = {
    AND?: CoachTypeStaffPriceScalarWhereInput | CoachTypeStaffPriceScalarWhereInput[]
    OR?: CoachTypeStaffPriceScalarWhereInput[]
    NOT?: CoachTypeStaffPriceScalarWhereInput | CoachTypeStaffPriceScalarWhereInput[]
    id?: StringFilter<"CoachTypeStaffPrice"> | string
    staffId?: StringFilter<"CoachTypeStaffPrice"> | string
    coachTypeId?: StringFilter<"CoachTypeStaffPrice"> | string
    basePrice?: BigIntFilter<"CoachTypeStaffPrice"> | bigint | number
    createdAt?: DateTimeFilter<"CoachTypeStaffPrice"> | Date | string
    updatedAt?: DateTimeFilter<"CoachTypeStaffPrice"> | Date | string
  }

  export type UserCreateWithoutAuthTokensInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingCreateNestedManyWithoutUserInput
    clubsLed?: ClubCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberCreateNestedManyWithoutUserInput
    invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthTokensInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingUncheckedCreateNestedManyWithoutUserInput
    clubsLed?: ClubUncheckedCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutUserInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
  }

  export type StaffCreateWithoutAuthTokensInput = {
    id?: string
    image?: string | null
    name: string
    email: string
    phone?: string | null
    password: string
    isActive?: boolean
    joinedAt?: Date | string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    slot?: SlotCreateNestedManyWithoutStaffInput
    coachTypeStaffPrice?: CoachTypeStaffPriceCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutAuthTokensInput = {
    id?: string
    image?: string | null
    name: string
    email: string
    phone?: string | null
    password: string
    isActive?: boolean
    joinedAt?: Date | string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    slot?: SlotUncheckedCreateNestedManyWithoutStaffInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutAuthTokensInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutAuthTokensInput, StaffUncheckedCreateWithoutAuthTokensInput>
  }

  export type UserUpsertWithoutAuthTokensInput = {
    update: XOR<UserUpdateWithoutAuthTokensInput, UserUncheckedUpdateWithoutAuthTokensInput>
    create: XOR<UserCreateWithoutAuthTokensInput, UserUncheckedCreateWithoutAuthTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthTokensInput, UserUncheckedUpdateWithoutAuthTokensInput>
  }

  export type UserUpdateWithoutAuthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUncheckedUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUncheckedUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUncheckedUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StaffUpsertWithoutAuthTokensInput = {
    update: XOR<StaffUpdateWithoutAuthTokensInput, StaffUncheckedUpdateWithoutAuthTokensInput>
    create: XOR<StaffCreateWithoutAuthTokensInput, StaffUncheckedCreateWithoutAuthTokensInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutAuthTokensInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutAuthTokensInput, StaffUncheckedUpdateWithoutAuthTokensInput>
  }

  export type StaffUpdateWithoutAuthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: SlotUpdateManyWithoutStaffNestedInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutAuthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: SlotUncheckedUpdateManyWithoutStaffNestedInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type CourtCostScheduleCreateWithoutCourtInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    price: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourtCostScheduleUncheckedCreateWithoutCourtInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    price: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourtCostScheduleCreateOrConnectWithoutCourtInput = {
    where: CourtCostScheduleWhereUniqueInput
    create: XOR<CourtCostScheduleCreateWithoutCourtInput, CourtCostScheduleUncheckedCreateWithoutCourtInput>
  }

  export type CourtCostScheduleCreateManyCourtInputEnvelope = {
    data: CourtCostScheduleCreateManyCourtInput | CourtCostScheduleCreateManyCourtInput[]
    skipDuplicates?: boolean
  }

  export type BookingDetailCreateWithoutCourtInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutDetailsInput
    slot: SlotCreateNestedOneWithoutBookingDetailsInput
  }

  export type BookingDetailUncheckedCreateWithoutCourtInput = {
    id?: string
    bookingId: string
    slotId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingDetailCreateOrConnectWithoutCourtInput = {
    where: BookingDetailWhereUniqueInput
    create: XOR<BookingDetailCreateWithoutCourtInput, BookingDetailUncheckedCreateWithoutCourtInput>
  }

  export type BookingDetailCreateManyCourtInputEnvelope = {
    data: BookingDetailCreateManyCourtInput | BookingDetailCreateManyCourtInput[]
    skipDuplicates?: boolean
  }

  export type SlotCreateWithoutCourtInput = {
    id?: string
    type: $Enums.SlotType
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutSlotInput
    bookingDetails?: BookingDetailCreateNestedManyWithoutSlotInput
    bookingCoaches?: BookingCoachCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyCreateNestedManyWithoutSlotInput
  }

  export type SlotUncheckedCreateWithoutCourtInput = {
    id?: string
    type: $Enums.SlotType
    staffId?: string | null
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingDetails?: BookingDetailUncheckedCreateNestedManyWithoutSlotInput
    bookingCoaches?: BookingCoachUncheckedCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyUncheckedCreateNestedManyWithoutSlotInput
  }

  export type SlotCreateOrConnectWithoutCourtInput = {
    where: SlotWhereUniqueInput
    create: XOR<SlotCreateWithoutCourtInput, SlotUncheckedCreateWithoutCourtInput>
  }

  export type SlotCreateManyCourtInputEnvelope = {
    data: SlotCreateManyCourtInput | SlotCreateManyCourtInput[]
    skipDuplicates?: boolean
  }

  export type CourtCostScheduleUpsertWithWhereUniqueWithoutCourtInput = {
    where: CourtCostScheduleWhereUniqueInput
    update: XOR<CourtCostScheduleUpdateWithoutCourtInput, CourtCostScheduleUncheckedUpdateWithoutCourtInput>
    create: XOR<CourtCostScheduleCreateWithoutCourtInput, CourtCostScheduleUncheckedCreateWithoutCourtInput>
  }

  export type CourtCostScheduleUpdateWithWhereUniqueWithoutCourtInput = {
    where: CourtCostScheduleWhereUniqueInput
    data: XOR<CourtCostScheduleUpdateWithoutCourtInput, CourtCostScheduleUncheckedUpdateWithoutCourtInput>
  }

  export type CourtCostScheduleUpdateManyWithWhereWithoutCourtInput = {
    where: CourtCostScheduleScalarWhereInput
    data: XOR<CourtCostScheduleUpdateManyMutationInput, CourtCostScheduleUncheckedUpdateManyWithoutCourtInput>
  }

  export type CourtCostScheduleScalarWhereInput = {
    AND?: CourtCostScheduleScalarWhereInput | CourtCostScheduleScalarWhereInput[]
    OR?: CourtCostScheduleScalarWhereInput[]
    NOT?: CourtCostScheduleScalarWhereInput | CourtCostScheduleScalarWhereInput[]
    id?: StringFilter<"CourtCostSchedule"> | string
    courtId?: StringFilter<"CourtCostSchedule"> | string
    startAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    endAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    price?: IntFilter<"CourtCostSchedule"> | number
    isAvailable?: BoolFilter<"CourtCostSchedule"> | boolean
    createdAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CourtCostSchedule"> | Date | string
  }

  export type BookingDetailUpsertWithWhereUniqueWithoutCourtInput = {
    where: BookingDetailWhereUniqueInput
    update: XOR<BookingDetailUpdateWithoutCourtInput, BookingDetailUncheckedUpdateWithoutCourtInput>
    create: XOR<BookingDetailCreateWithoutCourtInput, BookingDetailUncheckedCreateWithoutCourtInput>
  }

  export type BookingDetailUpdateWithWhereUniqueWithoutCourtInput = {
    where: BookingDetailWhereUniqueInput
    data: XOR<BookingDetailUpdateWithoutCourtInput, BookingDetailUncheckedUpdateWithoutCourtInput>
  }

  export type BookingDetailUpdateManyWithWhereWithoutCourtInput = {
    where: BookingDetailScalarWhereInput
    data: XOR<BookingDetailUpdateManyMutationInput, BookingDetailUncheckedUpdateManyWithoutCourtInput>
  }

  export type BookingDetailScalarWhereInput = {
    AND?: BookingDetailScalarWhereInput | BookingDetailScalarWhereInput[]
    OR?: BookingDetailScalarWhereInput[]
    NOT?: BookingDetailScalarWhereInput | BookingDetailScalarWhereInput[]
    id?: StringFilter<"BookingDetail"> | string
    bookingId?: StringFilter<"BookingDetail"> | string
    slotId?: StringFilter<"BookingDetail"> | string
    price?: IntFilter<"BookingDetail"> | number
    createdAt?: DateTimeFilter<"BookingDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BookingDetail"> | Date | string
    courtId?: StringNullableFilter<"BookingDetail"> | string | null
  }

  export type SlotUpsertWithWhereUniqueWithoutCourtInput = {
    where: SlotWhereUniqueInput
    update: XOR<SlotUpdateWithoutCourtInput, SlotUncheckedUpdateWithoutCourtInput>
    create: XOR<SlotCreateWithoutCourtInput, SlotUncheckedCreateWithoutCourtInput>
  }

  export type SlotUpdateWithWhereUniqueWithoutCourtInput = {
    where: SlotWhereUniqueInput
    data: XOR<SlotUpdateWithoutCourtInput, SlotUncheckedUpdateWithoutCourtInput>
  }

  export type SlotUpdateManyWithWhereWithoutCourtInput = {
    where: SlotScalarWhereInput
    data: XOR<SlotUpdateManyMutationInput, SlotUncheckedUpdateManyWithoutCourtInput>
  }

  export type BookingInventoryCreateWithoutInventoryInput = {
    id?: string
    quantity?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutInventoriesInput
  }

  export type BookingInventoryUncheckedCreateWithoutInventoryInput = {
    id?: string
    bookingId: string
    quantity?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingInventoryCreateOrConnectWithoutInventoryInput = {
    where: BookingInventoryWhereUniqueInput
    create: XOR<BookingInventoryCreateWithoutInventoryInput, BookingInventoryUncheckedCreateWithoutInventoryInput>
  }

  export type BookingInventoryCreateManyInventoryInputEnvelope = {
    data: BookingInventoryCreateManyInventoryInput | BookingInventoryCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type BookingInventoryUpsertWithWhereUniqueWithoutInventoryInput = {
    where: BookingInventoryWhereUniqueInput
    update: XOR<BookingInventoryUpdateWithoutInventoryInput, BookingInventoryUncheckedUpdateWithoutInventoryInput>
    create: XOR<BookingInventoryCreateWithoutInventoryInput, BookingInventoryUncheckedCreateWithoutInventoryInput>
  }

  export type BookingInventoryUpdateWithWhereUniqueWithoutInventoryInput = {
    where: BookingInventoryWhereUniqueInput
    data: XOR<BookingInventoryUpdateWithoutInventoryInput, BookingInventoryUncheckedUpdateWithoutInventoryInput>
  }

  export type BookingInventoryUpdateManyWithWhereWithoutInventoryInput = {
    where: BookingInventoryScalarWhereInput
    data: XOR<BookingInventoryUpdateManyMutationInput, BookingInventoryUncheckedUpdateManyWithoutInventoryInput>
  }

  export type BookingInventoryScalarWhereInput = {
    AND?: BookingInventoryScalarWhereInput | BookingInventoryScalarWhereInput[]
    OR?: BookingInventoryScalarWhereInput[]
    NOT?: BookingInventoryScalarWhereInput | BookingInventoryScalarWhereInput[]
    id?: StringFilter<"BookingInventory"> | string
    bookingId?: StringFilter<"BookingInventory"> | string
    inventoryId?: StringFilter<"BookingInventory"> | string
    quantity?: IntFilter<"BookingInventory"> | number
    price?: IntFilter<"BookingInventory"> | number
    createdAt?: DateTimeFilter<"BookingInventory"> | Date | string
    updatedAt?: DateTimeFilter<"BookingInventory"> | Date | string
  }

  export type CourtCreateWithoutSlotInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    costSchedules?: CourtCostScheduleCreateNestedManyWithoutCourtInput
    bookingDetail?: BookingDetailCreateNestedManyWithoutCourtInput
  }

  export type CourtUncheckedCreateWithoutSlotInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    costSchedules?: CourtCostScheduleUncheckedCreateNestedManyWithoutCourtInput
    bookingDetail?: BookingDetailUncheckedCreateNestedManyWithoutCourtInput
  }

  export type CourtCreateOrConnectWithoutSlotInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutSlotInput, CourtUncheckedCreateWithoutSlotInput>
  }

  export type StaffCreateWithoutSlotInput = {
    id?: string
    image?: string | null
    name: string
    email: string
    phone?: string | null
    password: string
    isActive?: boolean
    joinedAt?: Date | string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutStaffInput
    coachTypeStaffPrice?: CoachTypeStaffPriceCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutSlotInput = {
    id?: string
    image?: string | null
    name: string
    email: string
    phone?: string | null
    password: string
    isActive?: boolean
    joinedAt?: Date | string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutStaffInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutSlotInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutSlotInput, StaffUncheckedCreateWithoutSlotInput>
  }

  export type BookingDetailCreateWithoutSlotInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutDetailsInput
    court?: CourtCreateNestedOneWithoutBookingDetailInput
  }

  export type BookingDetailUncheckedCreateWithoutSlotInput = {
    id?: string
    bookingId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courtId?: string | null
  }

  export type BookingDetailCreateOrConnectWithoutSlotInput = {
    where: BookingDetailWhereUniqueInput
    create: XOR<BookingDetailCreateWithoutSlotInput, BookingDetailUncheckedCreateWithoutSlotInput>
  }

  export type BookingDetailCreateManySlotInputEnvelope = {
    data: BookingDetailCreateManySlotInput | BookingDetailCreateManySlotInput[]
    skipDuplicates?: boolean
  }

  export type BookingCoachCreateWithoutSlotInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCoachesInput
    bookingCoachType: BookingCoachTypeCreateNestedOneWithoutBookingCoachInput
  }

  export type BookingCoachUncheckedCreateWithoutSlotInput = {
    id?: string
    bookingId: string
    bookingCoachTypeId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCoachCreateOrConnectWithoutSlotInput = {
    where: BookingCoachWhereUniqueInput
    create: XOR<BookingCoachCreateWithoutSlotInput, BookingCoachUncheckedCreateWithoutSlotInput>
  }

  export type BookingCoachCreateManySlotInputEnvelope = {
    data: BookingCoachCreateManySlotInput | BookingCoachCreateManySlotInput[]
    skipDuplicates?: boolean
  }

  export type BookingBallboyCreateWithoutSlotInput = {
    id?: string
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutBallboysInput
  }

  export type BookingBallboyUncheckedCreateWithoutSlotInput = {
    id?: string
    bookingId: string
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingBallboyCreateOrConnectWithoutSlotInput = {
    where: BookingBallboyWhereUniqueInput
    create: XOR<BookingBallboyCreateWithoutSlotInput, BookingBallboyUncheckedCreateWithoutSlotInput>
  }

  export type BookingBallboyCreateManySlotInputEnvelope = {
    data: BookingBallboyCreateManySlotInput | BookingBallboyCreateManySlotInput[]
    skipDuplicates?: boolean
  }

  export type CourtUpsertWithoutSlotInput = {
    update: XOR<CourtUpdateWithoutSlotInput, CourtUncheckedUpdateWithoutSlotInput>
    create: XOR<CourtCreateWithoutSlotInput, CourtUncheckedCreateWithoutSlotInput>
    where?: CourtWhereInput
  }

  export type CourtUpdateToOneWithWhereWithoutSlotInput = {
    where?: CourtWhereInput
    data: XOR<CourtUpdateWithoutSlotInput, CourtUncheckedUpdateWithoutSlotInput>
  }

  export type CourtUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costSchedules?: CourtCostScheduleUpdateManyWithoutCourtNestedInput
    bookingDetail?: BookingDetailUpdateManyWithoutCourtNestedInput
  }

  export type CourtUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costSchedules?: CourtCostScheduleUncheckedUpdateManyWithoutCourtNestedInput
    bookingDetail?: BookingDetailUncheckedUpdateManyWithoutCourtNestedInput
  }

  export type StaffUpsertWithoutSlotInput = {
    update: XOR<StaffUpdateWithoutSlotInput, StaffUncheckedUpdateWithoutSlotInput>
    create: XOR<StaffCreateWithoutSlotInput, StaffUncheckedCreateWithoutSlotInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutSlotInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutSlotInput, StaffUncheckedUpdateWithoutSlotInput>
  }

  export type StaffUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutStaffNestedInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutStaffNestedInput
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type BookingDetailUpsertWithWhereUniqueWithoutSlotInput = {
    where: BookingDetailWhereUniqueInput
    update: XOR<BookingDetailUpdateWithoutSlotInput, BookingDetailUncheckedUpdateWithoutSlotInput>
    create: XOR<BookingDetailCreateWithoutSlotInput, BookingDetailUncheckedCreateWithoutSlotInput>
  }

  export type BookingDetailUpdateWithWhereUniqueWithoutSlotInput = {
    where: BookingDetailWhereUniqueInput
    data: XOR<BookingDetailUpdateWithoutSlotInput, BookingDetailUncheckedUpdateWithoutSlotInput>
  }

  export type BookingDetailUpdateManyWithWhereWithoutSlotInput = {
    where: BookingDetailScalarWhereInput
    data: XOR<BookingDetailUpdateManyMutationInput, BookingDetailUncheckedUpdateManyWithoutSlotInput>
  }

  export type BookingCoachUpsertWithWhereUniqueWithoutSlotInput = {
    where: BookingCoachWhereUniqueInput
    update: XOR<BookingCoachUpdateWithoutSlotInput, BookingCoachUncheckedUpdateWithoutSlotInput>
    create: XOR<BookingCoachCreateWithoutSlotInput, BookingCoachUncheckedCreateWithoutSlotInput>
  }

  export type BookingCoachUpdateWithWhereUniqueWithoutSlotInput = {
    where: BookingCoachWhereUniqueInput
    data: XOR<BookingCoachUpdateWithoutSlotInput, BookingCoachUncheckedUpdateWithoutSlotInput>
  }

  export type BookingCoachUpdateManyWithWhereWithoutSlotInput = {
    where: BookingCoachScalarWhereInput
    data: XOR<BookingCoachUpdateManyMutationInput, BookingCoachUncheckedUpdateManyWithoutSlotInput>
  }

  export type BookingCoachScalarWhereInput = {
    AND?: BookingCoachScalarWhereInput | BookingCoachScalarWhereInput[]
    OR?: BookingCoachScalarWhereInput[]
    NOT?: BookingCoachScalarWhereInput | BookingCoachScalarWhereInput[]
    id?: StringFilter<"BookingCoach"> | string
    bookingId?: StringFilter<"BookingCoach"> | string
    slotId?: StringFilter<"BookingCoach"> | string
    bookingCoachTypeId?: StringFilter<"BookingCoach"> | string
    price?: IntFilter<"BookingCoach"> | number
    createdAt?: DateTimeFilter<"BookingCoach"> | Date | string
    updatedAt?: DateTimeFilter<"BookingCoach"> | Date | string
  }

  export type BookingBallboyUpsertWithWhereUniqueWithoutSlotInput = {
    where: BookingBallboyWhereUniqueInput
    update: XOR<BookingBallboyUpdateWithoutSlotInput, BookingBallboyUncheckedUpdateWithoutSlotInput>
    create: XOR<BookingBallboyCreateWithoutSlotInput, BookingBallboyUncheckedCreateWithoutSlotInput>
  }

  export type BookingBallboyUpdateWithWhereUniqueWithoutSlotInput = {
    where: BookingBallboyWhereUniqueInput
    data: XOR<BookingBallboyUpdateWithoutSlotInput, BookingBallboyUncheckedUpdateWithoutSlotInput>
  }

  export type BookingBallboyUpdateManyWithWhereWithoutSlotInput = {
    where: BookingBallboyScalarWhereInput
    data: XOR<BookingBallboyUpdateManyMutationInput, BookingBallboyUncheckedUpdateManyWithoutSlotInput>
  }

  export type BookingBallboyScalarWhereInput = {
    AND?: BookingBallboyScalarWhereInput | BookingBallboyScalarWhereInput[]
    OR?: BookingBallboyScalarWhereInput[]
    NOT?: BookingBallboyScalarWhereInput | BookingBallboyScalarWhereInput[]
    id?: StringFilter<"BookingBallboy"> | string
    bookingId?: StringFilter<"BookingBallboy"> | string
    slotId?: StringFilter<"BookingBallboy"> | string
    price?: IntFilter<"BookingBallboy"> | number
    createdAt?: DateTimeFilter<"BookingBallboy"> | Date | string
    updatedAt?: DateTimeFilter<"BookingBallboy"> | Date | string
  }

  export type CourtCreateWithoutCostSchedulesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingDetail?: BookingDetailCreateNestedManyWithoutCourtInput
    slot?: SlotCreateNestedManyWithoutCourtInput
  }

  export type CourtUncheckedCreateWithoutCostSchedulesInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingDetail?: BookingDetailUncheckedCreateNestedManyWithoutCourtInput
    slot?: SlotUncheckedCreateNestedManyWithoutCourtInput
  }

  export type CourtCreateOrConnectWithoutCostSchedulesInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutCostSchedulesInput, CourtUncheckedCreateWithoutCostSchedulesInput>
  }

  export type CourtUpsertWithoutCostSchedulesInput = {
    update: XOR<CourtUpdateWithoutCostSchedulesInput, CourtUncheckedUpdateWithoutCostSchedulesInput>
    create: XOR<CourtCreateWithoutCostSchedulesInput, CourtUncheckedCreateWithoutCostSchedulesInput>
    where?: CourtWhereInput
  }

  export type CourtUpdateToOneWithWhereWithoutCostSchedulesInput = {
    where?: CourtWhereInput
    data: XOR<CourtUpdateWithoutCostSchedulesInput, CourtUncheckedUpdateWithoutCostSchedulesInput>
  }

  export type CourtUpdateWithoutCostSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingDetail?: BookingDetailUpdateManyWithoutCourtNestedInput
    slot?: SlotUpdateManyWithoutCourtNestedInput
  }

  export type CourtUncheckedUpdateWithoutCostSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingDetail?: BookingDetailUncheckedUpdateManyWithoutCourtNestedInput
    slot?: SlotUncheckedUpdateManyWithoutCourtNestedInput
  }

  export type PaymentCreateWithoutMethodInput = {
    id?: string
    status?: $Enums.PaymentStatus
    amount: number
    fees?: number
    externalRef?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutMethodInput = {
    id?: string
    status?: $Enums.PaymentStatus
    amount: number
    fees?: number
    externalRef?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutMethodInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutMethodInput, PaymentUncheckedCreateWithoutMethodInput>
  }

  export type PaymentCreateManyMethodInputEnvelope = {
    data: PaymentCreateManyMethodInput | PaymentCreateManyMethodInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithWhereUniqueWithoutMethodInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutMethodInput, PaymentUncheckedUpdateWithoutMethodInput>
    create: XOR<PaymentCreateWithoutMethodInput, PaymentUncheckedCreateWithoutMethodInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutMethodInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutMethodInput, PaymentUncheckedUpdateWithoutMethodInput>
  }

  export type PaymentUpdateManyWithWhereWithoutMethodInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutMethodInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    paymentMethodId?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    amount?: IntFilter<"Payment"> | number
    fees?: IntFilter<"Payment"> | number
    externalRef?: StringNullableFilter<"Payment"> | string | null
    meta?: JsonNullableFilter<"Payment">
    dueDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PaymentMethodCreateWithoutPaymentsInput = {
    id?: string
    name: string
    logo?: string | null
    fees?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    logo?: string | null
    fees?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodCreateOrConnectWithoutPaymentsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutPaymentInput = {
    id?: string
    number: string
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    user: UserCreateNestedOneWithoutInvoiceInput
    booking?: BookingCreateNestedOneWithoutInvoiceInput
    classBooking?: ClassBookingCreateNestedOneWithoutInvoiceInput
    membershipUser?: MembershipUserCreateNestedOneWithoutInvoiceInput
    tournamentRegistration?: TournamentRegistrationCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentInput = {
    id?: string
    bookingId?: string | null
    classBookingId?: string | null
    membershipUserId?: string | null
    tournamentRegistrationId?: string | null
    number: string
    userId: string
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutPaymentInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentMethodUpsertWithoutPaymentsInput = {
    update: XOR<PaymentMethodUpdateWithoutPaymentsInput, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutPaymentsInput, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentMethodUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithoutPaymentInput = {
    update: XOR<InvoiceUpdateWithoutPaymentInput, InvoiceUncheckedUpdateWithoutPaymentInput>
    create: XOR<InvoiceCreateWithoutPaymentInput, InvoiceUncheckedCreateWithoutPaymentInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentInput, InvoiceUncheckedUpdateWithoutPaymentInput>
  }

  export type InvoiceUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    booking?: BookingUpdateOneWithoutInvoiceNestedInput
    classBooking?: ClassBookingUpdateOneWithoutInvoiceNestedInput
    membershipUser?: MembershipUserUpdateOneWithoutInvoiceNestedInput
    tournamentRegistration?: TournamentRegistrationUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    classBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutInvoiceInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingCreateNestedManyWithoutUserInput
    clubsLed?: ClubCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoiceInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingUncheckedCreateNestedManyWithoutUserInput
    clubsLed?: ClubUncheckedCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoiceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    status?: $Enums.PaymentStatus
    amount: number
    fees?: number
    externalRef?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    method: PaymentMethodCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    paymentMethodId: string
    status?: $Enums.PaymentStatus
    amount: number
    fees?: number
    externalRef?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type BookingCreateWithoutInvoiceInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    user: UserCreateNestedOneWithoutBookingsInput
    details?: BookingDetailCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutInvoiceInput = {
    id?: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: BookingDetailUncheckedCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryUncheckedCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyUncheckedCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutInvoiceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutInvoiceInput, BookingUncheckedCreateWithoutInvoiceInput>
  }

  export type ClassBookingCreateWithoutInvoiceInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    class: ClassCreateNestedOneWithoutClassBookingsInput
    user: UserCreateNestedOneWithoutClassBookingsInput
    details?: ClassBookingDetailCreateNestedManyWithoutClassBookingInput
  }

  export type ClassBookingUncheckedCreateWithoutInvoiceInput = {
    id?: string
    classId: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: ClassBookingDetailUncheckedCreateNestedManyWithoutClassBookingInput
  }

  export type ClassBookingCreateOrConnectWithoutInvoiceInput = {
    where: ClassBookingWhereUniqueInput
    create: XOR<ClassBookingCreateWithoutInvoiceInput, ClassBookingUncheckedCreateWithoutInvoiceInput>
  }

  export type MembershipUserCreateWithoutInvoiceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipUserInput
    membership: MembershipCreateNestedOneWithoutMembershipUserInput
  }

  export type MembershipUserUncheckedCreateWithoutInvoiceInput = {
    id?: string
    userId: string
    membershipId: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUserCreateOrConnectWithoutInvoiceInput = {
    where: MembershipUserWhereUniqueInput
    create: XOR<MembershipUserCreateWithoutInvoiceInput, MembershipUserUncheckedCreateWithoutInvoiceInput>
  }

  export type TournamentRegistrationCreateWithoutInvoiceInput = {
    id?: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    tournament: TournamentCreateNestedOneWithoutTournamentRegistrationInput
    club: ClubCreateNestedOneWithoutTournamentRegistrationInput
    membersRef?: TournamentRegistrationMemberCreateNestedManyWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationUncheckedCreateWithoutInvoiceInput = {
    id?: string
    tournamentId: string
    clubId: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    membersRef?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationCreateOrConnectWithoutInvoiceInput = {
    where: TournamentRegistrationWhereUniqueInput
    create: XOR<TournamentRegistrationCreateWithoutInvoiceInput, TournamentRegistrationUncheckedCreateWithoutInvoiceInput>
  }

  export type UserUpsertWithoutInvoiceInput = {
    update: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
    create: XOR<UserCreateWithoutInvoiceInput, UserUncheckedCreateWithoutInvoiceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoiceInput, UserUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUncheckedUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUncheckedUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUncheckedUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithoutInvoiceInput = {
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: IntFieldUpdateOperationsInput | number
    fees?: IntFieldUpdateOperationsInput | number
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    method?: PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: IntFieldUpdateOperationsInput | number
    fees?: IntFieldUpdateOperationsInput | number
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpsertWithoutInvoiceInput = {
    update: XOR<BookingUpdateWithoutInvoiceInput, BookingUncheckedUpdateWithoutInvoiceInput>
    create: XOR<BookingCreateWithoutInvoiceInput, BookingUncheckedCreateWithoutInvoiceInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutInvoiceInput, BookingUncheckedUpdateWithoutInvoiceInput>
  }

  export type BookingUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    details?: BookingDetailUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: BookingDetailUncheckedUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUncheckedUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUncheckedUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ClassBookingUpsertWithoutInvoiceInput = {
    update: XOR<ClassBookingUpdateWithoutInvoiceInput, ClassBookingUncheckedUpdateWithoutInvoiceInput>
    create: XOR<ClassBookingCreateWithoutInvoiceInput, ClassBookingUncheckedCreateWithoutInvoiceInput>
    where?: ClassBookingWhereInput
  }

  export type ClassBookingUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: ClassBookingWhereInput
    data: XOR<ClassBookingUpdateWithoutInvoiceInput, ClassBookingUncheckedUpdateWithoutInvoiceInput>
  }

  export type ClassBookingUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutClassBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutClassBookingsNestedInput
    details?: ClassBookingDetailUpdateManyWithoutClassBookingNestedInput
  }

  export type ClassBookingUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: ClassBookingDetailUncheckedUpdateManyWithoutClassBookingNestedInput
  }

  export type MembershipUserUpsertWithoutInvoiceInput = {
    update: XOR<MembershipUserUpdateWithoutInvoiceInput, MembershipUserUncheckedUpdateWithoutInvoiceInput>
    create: XOR<MembershipUserCreateWithoutInvoiceInput, MembershipUserUncheckedCreateWithoutInvoiceInput>
    where?: MembershipUserWhereInput
  }

  export type MembershipUserUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: MembershipUserWhereInput
    data: XOR<MembershipUserUpdateWithoutInvoiceInput, MembershipUserUncheckedUpdateWithoutInvoiceInput>
  }

  export type MembershipUserUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipUserNestedInput
    membership?: MembershipUpdateOneRequiredWithoutMembershipUserNestedInput
  }

  export type MembershipUserUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentRegistrationUpsertWithoutInvoiceInput = {
    update: XOR<TournamentRegistrationUpdateWithoutInvoiceInput, TournamentRegistrationUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TournamentRegistrationCreateWithoutInvoiceInput, TournamentRegistrationUncheckedCreateWithoutInvoiceInput>
    where?: TournamentRegistrationWhereInput
  }

  export type TournamentRegistrationUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: TournamentRegistrationWhereInput
    data: XOR<TournamentRegistrationUpdateWithoutInvoiceInput, TournamentRegistrationUncheckedUpdateWithoutInvoiceInput>
  }

  export type TournamentRegistrationUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    tournament?: TournamentUpdateOneRequiredWithoutTournamentRegistrationNestedInput
    club?: ClubUpdateOneRequiredWithoutTournamentRegistrationNestedInput
    membersRef?: TournamentRegistrationMemberUpdateManyWithoutTournamentRegistrationNestedInput
  }

  export type TournamentRegistrationUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    membersRef?: TournamentRegistrationMemberUncheckedUpdateManyWithoutTournamentRegistrationNestedInput
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingCreateNestedManyWithoutUserInput
    clubsLed?: ClubCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberCreateNestedManyWithoutUserInput
    invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingUncheckedCreateNestedManyWithoutUserInput
    clubsLed?: ClubUncheckedCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutUserInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type BookingDetailCreateWithoutBookingInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slot: SlotCreateNestedOneWithoutBookingDetailsInput
    court?: CourtCreateNestedOneWithoutBookingDetailInput
  }

  export type BookingDetailUncheckedCreateWithoutBookingInput = {
    id?: string
    slotId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courtId?: string | null
  }

  export type BookingDetailCreateOrConnectWithoutBookingInput = {
    where: BookingDetailWhereUniqueInput
    create: XOR<BookingDetailCreateWithoutBookingInput, BookingDetailUncheckedCreateWithoutBookingInput>
  }

  export type BookingDetailCreateManyBookingInputEnvelope = {
    data: BookingDetailCreateManyBookingInput | BookingDetailCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingInventoryCreateWithoutBookingInput = {
    id?: string
    quantity?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory: InventoryCreateNestedOneWithoutBookingInventoryInput
  }

  export type BookingInventoryUncheckedCreateWithoutBookingInput = {
    id?: string
    inventoryId: string
    quantity?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingInventoryCreateOrConnectWithoutBookingInput = {
    where: BookingInventoryWhereUniqueInput
    create: XOR<BookingInventoryCreateWithoutBookingInput, BookingInventoryUncheckedCreateWithoutBookingInput>
  }

  export type BookingInventoryCreateManyBookingInputEnvelope = {
    data: BookingInventoryCreateManyBookingInput | BookingInventoryCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingBallboyCreateWithoutBookingInput = {
    id?: string
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slot: SlotCreateNestedOneWithoutBookingBallboysInput
  }

  export type BookingBallboyUncheckedCreateWithoutBookingInput = {
    id?: string
    slotId: string
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingBallboyCreateOrConnectWithoutBookingInput = {
    where: BookingBallboyWhereUniqueInput
    create: XOR<BookingBallboyCreateWithoutBookingInput, BookingBallboyUncheckedCreateWithoutBookingInput>
  }

  export type BookingBallboyCreateManyBookingInputEnvelope = {
    data: BookingBallboyCreateManyBookingInput | BookingBallboyCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingCoachCreateWithoutBookingInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    slot: SlotCreateNestedOneWithoutBookingCoachesInput
    bookingCoachType: BookingCoachTypeCreateNestedOneWithoutBookingCoachInput
  }

  export type BookingCoachUncheckedCreateWithoutBookingInput = {
    id?: string
    slotId: string
    bookingCoachTypeId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCoachCreateOrConnectWithoutBookingInput = {
    where: BookingCoachWhereUniqueInput
    create: XOR<BookingCoachCreateWithoutBookingInput, BookingCoachUncheckedCreateWithoutBookingInput>
  }

  export type BookingCoachCreateManyBookingInputEnvelope = {
    data: BookingCoachCreateManyBookingInput | BookingCoachCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutBookingInput = {
    id?: string
    number: string
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    user: UserCreateNestedOneWithoutInvoiceInput
    payment?: PaymentCreateNestedOneWithoutInvoiceInput
    classBooking?: ClassBookingCreateNestedOneWithoutInvoiceInput
    membershipUser?: MembershipUserCreateNestedOneWithoutInvoiceInput
    tournamentRegistration?: TournamentRegistrationCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutBookingInput = {
    id?: string
    classBookingId?: string | null
    membershipUserId?: string | null
    tournamentRegistrationId?: string | null
    number: string
    userId: string
    paymentId?: string | null
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutBookingInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUncheckedUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUncheckedUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUncheckedUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingDetailUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingDetailWhereUniqueInput
    update: XOR<BookingDetailUpdateWithoutBookingInput, BookingDetailUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingDetailCreateWithoutBookingInput, BookingDetailUncheckedCreateWithoutBookingInput>
  }

  export type BookingDetailUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingDetailWhereUniqueInput
    data: XOR<BookingDetailUpdateWithoutBookingInput, BookingDetailUncheckedUpdateWithoutBookingInput>
  }

  export type BookingDetailUpdateManyWithWhereWithoutBookingInput = {
    where: BookingDetailScalarWhereInput
    data: XOR<BookingDetailUpdateManyMutationInput, BookingDetailUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingInventoryUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingInventoryWhereUniqueInput
    update: XOR<BookingInventoryUpdateWithoutBookingInput, BookingInventoryUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingInventoryCreateWithoutBookingInput, BookingInventoryUncheckedCreateWithoutBookingInput>
  }

  export type BookingInventoryUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingInventoryWhereUniqueInput
    data: XOR<BookingInventoryUpdateWithoutBookingInput, BookingInventoryUncheckedUpdateWithoutBookingInput>
  }

  export type BookingInventoryUpdateManyWithWhereWithoutBookingInput = {
    where: BookingInventoryScalarWhereInput
    data: XOR<BookingInventoryUpdateManyMutationInput, BookingInventoryUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingBallboyUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingBallboyWhereUniqueInput
    update: XOR<BookingBallboyUpdateWithoutBookingInput, BookingBallboyUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingBallboyCreateWithoutBookingInput, BookingBallboyUncheckedCreateWithoutBookingInput>
  }

  export type BookingBallboyUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingBallboyWhereUniqueInput
    data: XOR<BookingBallboyUpdateWithoutBookingInput, BookingBallboyUncheckedUpdateWithoutBookingInput>
  }

  export type BookingBallboyUpdateManyWithWhereWithoutBookingInput = {
    where: BookingBallboyScalarWhereInput
    data: XOR<BookingBallboyUpdateManyMutationInput, BookingBallboyUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingCoachUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingCoachWhereUniqueInput
    update: XOR<BookingCoachUpdateWithoutBookingInput, BookingCoachUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingCoachCreateWithoutBookingInput, BookingCoachUncheckedCreateWithoutBookingInput>
  }

  export type BookingCoachUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingCoachWhereUniqueInput
    data: XOR<BookingCoachUpdateWithoutBookingInput, BookingCoachUncheckedUpdateWithoutBookingInput>
  }

  export type BookingCoachUpdateManyWithWhereWithoutBookingInput = {
    where: BookingCoachScalarWhereInput
    data: XOR<BookingCoachUpdateManyMutationInput, BookingCoachUncheckedUpdateManyWithoutBookingInput>
  }

  export type InvoiceUpsertWithoutBookingInput = {
    update: XOR<InvoiceUpdateWithoutBookingInput, InvoiceUncheckedUpdateWithoutBookingInput>
    create: XOR<InvoiceCreateWithoutBookingInput, InvoiceUncheckedCreateWithoutBookingInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutBookingInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutBookingInput, InvoiceUncheckedUpdateWithoutBookingInput>
  }

  export type InvoiceUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    payment?: PaymentUpdateOneWithoutInvoiceNestedInput
    classBooking?: ClassBookingUpdateOneWithoutInvoiceNestedInput
    membershipUser?: MembershipUserUpdateOneWithoutInvoiceNestedInput
    tournamentRegistration?: TournamentRegistrationUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    classBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingCreateWithoutDetailsInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    user: UserCreateNestedOneWithoutBookingsInput
    inventories?: BookingInventoryCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutDetailsInput = {
    id?: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    inventories?: BookingInventoryUncheckedCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyUncheckedCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutDetailsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutDetailsInput, BookingUncheckedCreateWithoutDetailsInput>
  }

  export type SlotCreateWithoutBookingDetailsInput = {
    id?: string
    type: $Enums.SlotType
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    court?: CourtCreateNestedOneWithoutSlotInput
    staff?: StaffCreateNestedOneWithoutSlotInput
    bookingCoaches?: BookingCoachCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyCreateNestedManyWithoutSlotInput
  }

  export type SlotUncheckedCreateWithoutBookingDetailsInput = {
    id?: string
    type: $Enums.SlotType
    courtId?: string | null
    staffId?: string | null
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingCoaches?: BookingCoachUncheckedCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyUncheckedCreateNestedManyWithoutSlotInput
  }

  export type SlotCreateOrConnectWithoutBookingDetailsInput = {
    where: SlotWhereUniqueInput
    create: XOR<SlotCreateWithoutBookingDetailsInput, SlotUncheckedCreateWithoutBookingDetailsInput>
  }

  export type CourtCreateWithoutBookingDetailInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    costSchedules?: CourtCostScheduleCreateNestedManyWithoutCourtInput
    slot?: SlotCreateNestedManyWithoutCourtInput
  }

  export type CourtUncheckedCreateWithoutBookingDetailInput = {
    id?: string
    name: string
    description?: string | null
    image?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    costSchedules?: CourtCostScheduleUncheckedCreateNestedManyWithoutCourtInput
    slot?: SlotUncheckedCreateNestedManyWithoutCourtInput
  }

  export type CourtCreateOrConnectWithoutBookingDetailInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutBookingDetailInput, CourtUncheckedCreateWithoutBookingDetailInput>
  }

  export type BookingUpsertWithoutDetailsInput = {
    update: XOR<BookingUpdateWithoutDetailsInput, BookingUncheckedUpdateWithoutDetailsInput>
    create: XOR<BookingCreateWithoutDetailsInput, BookingUncheckedCreateWithoutDetailsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutDetailsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutDetailsInput, BookingUncheckedUpdateWithoutDetailsInput>
  }

  export type BookingUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    inventories?: BookingInventoryUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    inventories?: BookingInventoryUncheckedUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUncheckedUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type SlotUpsertWithoutBookingDetailsInput = {
    update: XOR<SlotUpdateWithoutBookingDetailsInput, SlotUncheckedUpdateWithoutBookingDetailsInput>
    create: XOR<SlotCreateWithoutBookingDetailsInput, SlotUncheckedCreateWithoutBookingDetailsInput>
    where?: SlotWhereInput
  }

  export type SlotUpdateToOneWithWhereWithoutBookingDetailsInput = {
    where?: SlotWhereInput
    data: XOR<SlotUpdateWithoutBookingDetailsInput, SlotUncheckedUpdateWithoutBookingDetailsInput>
  }

  export type SlotUpdateWithoutBookingDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    court?: CourtUpdateOneWithoutSlotNestedInput
    staff?: StaffUpdateOneWithoutSlotNestedInput
    bookingCoaches?: BookingCoachUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUpdateManyWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateWithoutBookingDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingCoaches?: BookingCoachUncheckedUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type CourtUpsertWithoutBookingDetailInput = {
    update: XOR<CourtUpdateWithoutBookingDetailInput, CourtUncheckedUpdateWithoutBookingDetailInput>
    create: XOR<CourtCreateWithoutBookingDetailInput, CourtUncheckedCreateWithoutBookingDetailInput>
    where?: CourtWhereInput
  }

  export type CourtUpdateToOneWithWhereWithoutBookingDetailInput = {
    where?: CourtWhereInput
    data: XOR<CourtUpdateWithoutBookingDetailInput, CourtUncheckedUpdateWithoutBookingDetailInput>
  }

  export type CourtUpdateWithoutBookingDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costSchedules?: CourtCostScheduleUpdateManyWithoutCourtNestedInput
    slot?: SlotUpdateManyWithoutCourtNestedInput
  }

  export type CourtUncheckedUpdateWithoutBookingDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costSchedules?: CourtCostScheduleUncheckedUpdateManyWithoutCourtNestedInput
    slot?: SlotUncheckedUpdateManyWithoutCourtNestedInput
  }

  export type BookingCreateWithoutInventoriesInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    user: UserCreateNestedOneWithoutBookingsInput
    details?: BookingDetailCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutInventoriesInput = {
    id?: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: BookingDetailUncheckedCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyUncheckedCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutInventoriesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutInventoriesInput, BookingUncheckedCreateWithoutInventoriesInput>
  }

  export type InventoryCreateWithoutBookingInventoryInput = {
    id?: string
    name: string
    description?: string | null
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUncheckedCreateWithoutBookingInventoryInput = {
    id?: string
    name: string
    description?: string | null
    quantity?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateOrConnectWithoutBookingInventoryInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutBookingInventoryInput, InventoryUncheckedCreateWithoutBookingInventoryInput>
  }

  export type BookingUpsertWithoutInventoriesInput = {
    update: XOR<BookingUpdateWithoutInventoriesInput, BookingUncheckedUpdateWithoutInventoriesInput>
    create: XOR<BookingCreateWithoutInventoriesInput, BookingUncheckedCreateWithoutInventoriesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutInventoriesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutInventoriesInput, BookingUncheckedUpdateWithoutInventoriesInput>
  }

  export type BookingUpdateWithoutInventoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    details?: BookingDetailUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutInventoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: BookingDetailUncheckedUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUncheckedUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type InventoryUpsertWithoutBookingInventoryInput = {
    update: XOR<InventoryUpdateWithoutBookingInventoryInput, InventoryUncheckedUpdateWithoutBookingInventoryInput>
    create: XOR<InventoryCreateWithoutBookingInventoryInput, InventoryUncheckedCreateWithoutBookingInventoryInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutBookingInventoryInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutBookingInventoryInput, InventoryUncheckedUpdateWithoutBookingInventoryInput>
  }

  export type InventoryUpdateWithoutBookingInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateWithoutBookingInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateWithoutBallboysInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    user: UserCreateNestedOneWithoutBookingsInput
    details?: BookingDetailCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBallboysInput = {
    id?: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: BookingDetailUncheckedCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryUncheckedCreateNestedManyWithoutBookingInput
    coaches?: BookingCoachUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBallboysInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBallboysInput, BookingUncheckedCreateWithoutBallboysInput>
  }

  export type SlotCreateWithoutBookingBallboysInput = {
    id?: string
    type: $Enums.SlotType
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    court?: CourtCreateNestedOneWithoutSlotInput
    staff?: StaffCreateNestedOneWithoutSlotInput
    bookingDetails?: BookingDetailCreateNestedManyWithoutSlotInput
    bookingCoaches?: BookingCoachCreateNestedManyWithoutSlotInput
  }

  export type SlotUncheckedCreateWithoutBookingBallboysInput = {
    id?: string
    type: $Enums.SlotType
    courtId?: string | null
    staffId?: string | null
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingDetails?: BookingDetailUncheckedCreateNestedManyWithoutSlotInput
    bookingCoaches?: BookingCoachUncheckedCreateNestedManyWithoutSlotInput
  }

  export type SlotCreateOrConnectWithoutBookingBallboysInput = {
    where: SlotWhereUniqueInput
    create: XOR<SlotCreateWithoutBookingBallboysInput, SlotUncheckedCreateWithoutBookingBallboysInput>
  }

  export type BookingUpsertWithoutBallboysInput = {
    update: XOR<BookingUpdateWithoutBallboysInput, BookingUncheckedUpdateWithoutBallboysInput>
    create: XOR<BookingCreateWithoutBallboysInput, BookingUncheckedCreateWithoutBallboysInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutBallboysInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutBallboysInput, BookingUncheckedUpdateWithoutBallboysInput>
  }

  export type BookingUpdateWithoutBallboysInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    details?: BookingDetailUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBallboysInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: BookingDetailUncheckedUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUncheckedUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type SlotUpsertWithoutBookingBallboysInput = {
    update: XOR<SlotUpdateWithoutBookingBallboysInput, SlotUncheckedUpdateWithoutBookingBallboysInput>
    create: XOR<SlotCreateWithoutBookingBallboysInput, SlotUncheckedCreateWithoutBookingBallboysInput>
    where?: SlotWhereInput
  }

  export type SlotUpdateToOneWithWhereWithoutBookingBallboysInput = {
    where?: SlotWhereInput
    data: XOR<SlotUpdateWithoutBookingBallboysInput, SlotUncheckedUpdateWithoutBookingBallboysInput>
  }

  export type SlotUpdateWithoutBookingBallboysInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    court?: CourtUpdateOneWithoutSlotNestedInput
    staff?: StaffUpdateOneWithoutSlotNestedInput
    bookingDetails?: BookingDetailUpdateManyWithoutSlotNestedInput
    bookingCoaches?: BookingCoachUpdateManyWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateWithoutBookingBallboysInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingDetails?: BookingDetailUncheckedUpdateManyWithoutSlotNestedInput
    bookingCoaches?: BookingCoachUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type BookingCoachCreateWithoutBookingCoachTypeInput = {
    id?: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCoachesInput
    slot: SlotCreateNestedOneWithoutBookingCoachesInput
  }

  export type BookingCoachUncheckedCreateWithoutBookingCoachTypeInput = {
    id?: string
    bookingId: string
    slotId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCoachCreateOrConnectWithoutBookingCoachTypeInput = {
    where: BookingCoachWhereUniqueInput
    create: XOR<BookingCoachCreateWithoutBookingCoachTypeInput, BookingCoachUncheckedCreateWithoutBookingCoachTypeInput>
  }

  export type BookingCoachCreateManyBookingCoachTypeInputEnvelope = {
    data: BookingCoachCreateManyBookingCoachTypeInput | BookingCoachCreateManyBookingCoachTypeInput[]
    skipDuplicates?: boolean
  }

  export type CoachTypeStaffPriceCreateWithoutCoachTypeInput = {
    id?: string
    basePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutCoachTypeStaffPriceInput
  }

  export type CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput = {
    id?: string
    staffId: string
    basePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachTypeStaffPriceCreateOrConnectWithoutCoachTypeInput = {
    where: CoachTypeStaffPriceWhereUniqueInput
    create: XOR<CoachTypeStaffPriceCreateWithoutCoachTypeInput, CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput>
  }

  export type CoachTypeStaffPriceCreateManyCoachTypeInputEnvelope = {
    data: CoachTypeStaffPriceCreateManyCoachTypeInput | CoachTypeStaffPriceCreateManyCoachTypeInput[]
    skipDuplicates?: boolean
  }

  export type BookingCoachUpsertWithWhereUniqueWithoutBookingCoachTypeInput = {
    where: BookingCoachWhereUniqueInput
    update: XOR<BookingCoachUpdateWithoutBookingCoachTypeInput, BookingCoachUncheckedUpdateWithoutBookingCoachTypeInput>
    create: XOR<BookingCoachCreateWithoutBookingCoachTypeInput, BookingCoachUncheckedCreateWithoutBookingCoachTypeInput>
  }

  export type BookingCoachUpdateWithWhereUniqueWithoutBookingCoachTypeInput = {
    where: BookingCoachWhereUniqueInput
    data: XOR<BookingCoachUpdateWithoutBookingCoachTypeInput, BookingCoachUncheckedUpdateWithoutBookingCoachTypeInput>
  }

  export type BookingCoachUpdateManyWithWhereWithoutBookingCoachTypeInput = {
    where: BookingCoachScalarWhereInput
    data: XOR<BookingCoachUpdateManyMutationInput, BookingCoachUncheckedUpdateManyWithoutBookingCoachTypeInput>
  }

  export type CoachTypeStaffPriceUpsertWithWhereUniqueWithoutCoachTypeInput = {
    where: CoachTypeStaffPriceWhereUniqueInput
    update: XOR<CoachTypeStaffPriceUpdateWithoutCoachTypeInput, CoachTypeStaffPriceUncheckedUpdateWithoutCoachTypeInput>
    create: XOR<CoachTypeStaffPriceCreateWithoutCoachTypeInput, CoachTypeStaffPriceUncheckedCreateWithoutCoachTypeInput>
  }

  export type CoachTypeStaffPriceUpdateWithWhereUniqueWithoutCoachTypeInput = {
    where: CoachTypeStaffPriceWhereUniqueInput
    data: XOR<CoachTypeStaffPriceUpdateWithoutCoachTypeInput, CoachTypeStaffPriceUncheckedUpdateWithoutCoachTypeInput>
  }

  export type CoachTypeStaffPriceUpdateManyWithWhereWithoutCoachTypeInput = {
    where: CoachTypeStaffPriceScalarWhereInput
    data: XOR<CoachTypeStaffPriceUpdateManyMutationInput, CoachTypeStaffPriceUncheckedUpdateManyWithoutCoachTypeInput>
  }

  export type StaffCreateWithoutCoachTypeStaffPriceInput = {
    id?: string
    image?: string | null
    name: string
    email: string
    phone?: string | null
    password: string
    isActive?: boolean
    joinedAt?: Date | string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutStaffInput
    slot?: SlotCreateNestedManyWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutCoachTypeStaffPriceInput = {
    id?: string
    image?: string | null
    name: string
    email: string
    phone?: string | null
    password: string
    isActive?: boolean
    joinedAt?: Date | string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutStaffInput
    slot?: SlotUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutCoachTypeStaffPriceInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutCoachTypeStaffPriceInput, StaffUncheckedCreateWithoutCoachTypeStaffPriceInput>
  }

  export type BookingCoachTypeCreateWithoutCoachTypeStaffPriceInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingCoach?: BookingCoachCreateNestedManyWithoutBookingCoachTypeInput
  }

  export type BookingCoachTypeUncheckedCreateWithoutCoachTypeStaffPriceInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingCoach?: BookingCoachUncheckedCreateNestedManyWithoutBookingCoachTypeInput
  }

  export type BookingCoachTypeCreateOrConnectWithoutCoachTypeStaffPriceInput = {
    where: BookingCoachTypeWhereUniqueInput
    create: XOR<BookingCoachTypeCreateWithoutCoachTypeStaffPriceInput, BookingCoachTypeUncheckedCreateWithoutCoachTypeStaffPriceInput>
  }

  export type StaffUpsertWithoutCoachTypeStaffPriceInput = {
    update: XOR<StaffUpdateWithoutCoachTypeStaffPriceInput, StaffUncheckedUpdateWithoutCoachTypeStaffPriceInput>
    create: XOR<StaffCreateWithoutCoachTypeStaffPriceInput, StaffUncheckedCreateWithoutCoachTypeStaffPriceInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutCoachTypeStaffPriceInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutCoachTypeStaffPriceInput, StaffUncheckedUpdateWithoutCoachTypeStaffPriceInput>
  }

  export type StaffUpdateWithoutCoachTypeStaffPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutStaffNestedInput
    slot?: SlotUpdateManyWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutCoachTypeStaffPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutStaffNestedInput
    slot?: SlotUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type BookingCoachTypeUpsertWithoutCoachTypeStaffPriceInput = {
    update: XOR<BookingCoachTypeUpdateWithoutCoachTypeStaffPriceInput, BookingCoachTypeUncheckedUpdateWithoutCoachTypeStaffPriceInput>
    create: XOR<BookingCoachTypeCreateWithoutCoachTypeStaffPriceInput, BookingCoachTypeUncheckedCreateWithoutCoachTypeStaffPriceInput>
    where?: BookingCoachTypeWhereInput
  }

  export type BookingCoachTypeUpdateToOneWithWhereWithoutCoachTypeStaffPriceInput = {
    where?: BookingCoachTypeWhereInput
    data: XOR<BookingCoachTypeUpdateWithoutCoachTypeStaffPriceInput, BookingCoachTypeUncheckedUpdateWithoutCoachTypeStaffPriceInput>
  }

  export type BookingCoachTypeUpdateWithoutCoachTypeStaffPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingCoach?: BookingCoachUpdateManyWithoutBookingCoachTypeNestedInput
  }

  export type BookingCoachTypeUncheckedUpdateWithoutCoachTypeStaffPriceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingCoach?: BookingCoachUncheckedUpdateManyWithoutBookingCoachTypeNestedInput
  }

  export type BookingCreateWithoutCoachesInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    user: UserCreateNestedOneWithoutBookingsInput
    details?: BookingDetailCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyCreateNestedManyWithoutBookingInput
    invoice?: InvoiceCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCoachesInput = {
    id?: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: BookingDetailUncheckedCreateNestedManyWithoutBookingInput
    inventories?: BookingInventoryUncheckedCreateNestedManyWithoutBookingInput
    ballboys?: BookingBallboyUncheckedCreateNestedManyWithoutBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCoachesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCoachesInput, BookingUncheckedCreateWithoutCoachesInput>
  }

  export type SlotCreateWithoutBookingCoachesInput = {
    id?: string
    type: $Enums.SlotType
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    court?: CourtCreateNestedOneWithoutSlotInput
    staff?: StaffCreateNestedOneWithoutSlotInput
    bookingDetails?: BookingDetailCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyCreateNestedManyWithoutSlotInput
  }

  export type SlotUncheckedCreateWithoutBookingCoachesInput = {
    id?: string
    type: $Enums.SlotType
    courtId?: string | null
    staffId?: string | null
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingDetails?: BookingDetailUncheckedCreateNestedManyWithoutSlotInput
    bookingBallboys?: BookingBallboyUncheckedCreateNestedManyWithoutSlotInput
  }

  export type SlotCreateOrConnectWithoutBookingCoachesInput = {
    where: SlotWhereUniqueInput
    create: XOR<SlotCreateWithoutBookingCoachesInput, SlotUncheckedCreateWithoutBookingCoachesInput>
  }

  export type BookingCoachTypeCreateWithoutBookingCoachInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coachTypeStaffPrice?: CoachTypeStaffPriceCreateNestedManyWithoutCoachTypeInput
  }

  export type BookingCoachTypeUncheckedCreateWithoutBookingCoachInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedCreateNestedManyWithoutCoachTypeInput
  }

  export type BookingCoachTypeCreateOrConnectWithoutBookingCoachInput = {
    where: BookingCoachTypeWhereUniqueInput
    create: XOR<BookingCoachTypeCreateWithoutBookingCoachInput, BookingCoachTypeUncheckedCreateWithoutBookingCoachInput>
  }

  export type BookingUpsertWithoutCoachesInput = {
    update: XOR<BookingUpdateWithoutCoachesInput, BookingUncheckedUpdateWithoutCoachesInput>
    create: XOR<BookingCreateWithoutCoachesInput, BookingUncheckedCreateWithoutCoachesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCoachesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCoachesInput, BookingUncheckedUpdateWithoutCoachesInput>
  }

  export type BookingUpdateWithoutCoachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    details?: BookingDetailUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCoachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: BookingDetailUncheckedUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUncheckedUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type SlotUpsertWithoutBookingCoachesInput = {
    update: XOR<SlotUpdateWithoutBookingCoachesInput, SlotUncheckedUpdateWithoutBookingCoachesInput>
    create: XOR<SlotCreateWithoutBookingCoachesInput, SlotUncheckedCreateWithoutBookingCoachesInput>
    where?: SlotWhereInput
  }

  export type SlotUpdateToOneWithWhereWithoutBookingCoachesInput = {
    where?: SlotWhereInput
    data: XOR<SlotUpdateWithoutBookingCoachesInput, SlotUncheckedUpdateWithoutBookingCoachesInput>
  }

  export type SlotUpdateWithoutBookingCoachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    court?: CourtUpdateOneWithoutSlotNestedInput
    staff?: StaffUpdateOneWithoutSlotNestedInput
    bookingDetails?: BookingDetailUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUpdateManyWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateWithoutBookingCoachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingDetails?: BookingDetailUncheckedUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type BookingCoachTypeUpsertWithoutBookingCoachInput = {
    update: XOR<BookingCoachTypeUpdateWithoutBookingCoachInput, BookingCoachTypeUncheckedUpdateWithoutBookingCoachInput>
    create: XOR<BookingCoachTypeCreateWithoutBookingCoachInput, BookingCoachTypeUncheckedCreateWithoutBookingCoachInput>
    where?: BookingCoachTypeWhereInput
  }

  export type BookingCoachTypeUpdateToOneWithWhereWithoutBookingCoachInput = {
    where?: BookingCoachTypeWhereInput
    data: XOR<BookingCoachTypeUpdateWithoutBookingCoachInput, BookingCoachTypeUncheckedUpdateWithoutBookingCoachInput>
  }

  export type BookingCoachTypeUpdateWithoutBookingCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachTypeStaffPrice?: CoachTypeStaffPriceUpdateManyWithoutCoachTypeNestedInput
  }

  export type BookingCoachTypeUncheckedUpdateWithoutBookingCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachTypeStaffPrice?: CoachTypeStaffPriceUncheckedUpdateManyWithoutCoachTypeNestedInput
  }

  export type MembershipBenefitCreateWithoutMembershipInput = {
    id?: string
    benefit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipBenefitUncheckedCreateWithoutMembershipInput = {
    id?: string
    benefit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipBenefitCreateOrConnectWithoutMembershipInput = {
    where: MembershipBenefitWhereUniqueInput
    create: XOR<MembershipBenefitCreateWithoutMembershipInput, MembershipBenefitUncheckedCreateWithoutMembershipInput>
  }

  export type MembershipBenefitCreateManyMembershipInputEnvelope = {
    data: MembershipBenefitCreateManyMembershipInput | MembershipBenefitCreateManyMembershipInput[]
    skipDuplicates?: boolean
  }

  export type MembershipUserCreateWithoutMembershipInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipUserInput
    invoice?: InvoiceCreateNestedOneWithoutMembershipUserInput
  }

  export type MembershipUserUncheckedCreateWithoutMembershipInput = {
    id?: string
    userId: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutMembershipUserInput
  }

  export type MembershipUserCreateOrConnectWithoutMembershipInput = {
    where: MembershipUserWhereUniqueInput
    create: XOR<MembershipUserCreateWithoutMembershipInput, MembershipUserUncheckedCreateWithoutMembershipInput>
  }

  export type MembershipUserCreateManyMembershipInputEnvelope = {
    data: MembershipUserCreateManyMembershipInput | MembershipUserCreateManyMembershipInput[]
    skipDuplicates?: boolean
  }

  export type MembershipBenefitUpsertWithWhereUniqueWithoutMembershipInput = {
    where: MembershipBenefitWhereUniqueInput
    update: XOR<MembershipBenefitUpdateWithoutMembershipInput, MembershipBenefitUncheckedUpdateWithoutMembershipInput>
    create: XOR<MembershipBenefitCreateWithoutMembershipInput, MembershipBenefitUncheckedCreateWithoutMembershipInput>
  }

  export type MembershipBenefitUpdateWithWhereUniqueWithoutMembershipInput = {
    where: MembershipBenefitWhereUniqueInput
    data: XOR<MembershipBenefitUpdateWithoutMembershipInput, MembershipBenefitUncheckedUpdateWithoutMembershipInput>
  }

  export type MembershipBenefitUpdateManyWithWhereWithoutMembershipInput = {
    where: MembershipBenefitScalarWhereInput
    data: XOR<MembershipBenefitUpdateManyMutationInput, MembershipBenefitUncheckedUpdateManyWithoutMembershipInput>
  }

  export type MembershipBenefitScalarWhereInput = {
    AND?: MembershipBenefitScalarWhereInput | MembershipBenefitScalarWhereInput[]
    OR?: MembershipBenefitScalarWhereInput[]
    NOT?: MembershipBenefitScalarWhereInput | MembershipBenefitScalarWhereInput[]
    id?: StringFilter<"MembershipBenefit"> | string
    membershipId?: StringFilter<"MembershipBenefit"> | string
    benefit?: StringFilter<"MembershipBenefit"> | string
    createdAt?: DateTimeFilter<"MembershipBenefit"> | Date | string
    updatedAt?: DateTimeFilter<"MembershipBenefit"> | Date | string
  }

  export type MembershipUserUpsertWithWhereUniqueWithoutMembershipInput = {
    where: MembershipUserWhereUniqueInput
    update: XOR<MembershipUserUpdateWithoutMembershipInput, MembershipUserUncheckedUpdateWithoutMembershipInput>
    create: XOR<MembershipUserCreateWithoutMembershipInput, MembershipUserUncheckedCreateWithoutMembershipInput>
  }

  export type MembershipUserUpdateWithWhereUniqueWithoutMembershipInput = {
    where: MembershipUserWhereUniqueInput
    data: XOR<MembershipUserUpdateWithoutMembershipInput, MembershipUserUncheckedUpdateWithoutMembershipInput>
  }

  export type MembershipUserUpdateManyWithWhereWithoutMembershipInput = {
    where: MembershipUserScalarWhereInput
    data: XOR<MembershipUserUpdateManyMutationInput, MembershipUserUncheckedUpdateManyWithoutMembershipInput>
  }

  export type MembershipCreateWithoutBenefitsInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    price: number
    sessions: number
    duration: number
    sequence?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    membershipUser?: MembershipUserCreateNestedManyWithoutMembershipInput
  }

  export type MembershipUncheckedCreateWithoutBenefitsInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    price: number
    sessions: number
    duration: number
    sequence?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutMembershipInput
  }

  export type MembershipCreateOrConnectWithoutBenefitsInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutBenefitsInput, MembershipUncheckedCreateWithoutBenefitsInput>
  }

  export type MembershipUpsertWithoutBenefitsInput = {
    update: XOR<MembershipUpdateWithoutBenefitsInput, MembershipUncheckedUpdateWithoutBenefitsInput>
    create: XOR<MembershipCreateWithoutBenefitsInput, MembershipUncheckedCreateWithoutBenefitsInput>
    where?: MembershipWhereInput
  }

  export type MembershipUpdateToOneWithWhereWithoutBenefitsInput = {
    where?: MembershipWhereInput
    data: XOR<MembershipUpdateWithoutBenefitsInput, MembershipUncheckedUpdateWithoutBenefitsInput>
  }

  export type MembershipUpdateWithoutBenefitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membershipUser?: MembershipUserUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipUncheckedUpdateWithoutBenefitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutMembershipNestedInput
  }

  export type UserCreateWithoutMembershipUserInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingCreateNestedManyWithoutUserInput
    clubsLed?: ClubCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberCreateNestedManyWithoutUserInput
    invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipUserInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingUncheckedCreateNestedManyWithoutUserInput
    clubsLed?: ClubUncheckedCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutUserInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipUserInput, UserUncheckedCreateWithoutMembershipUserInput>
  }

  export type MembershipCreateWithoutMembershipUserInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    price: number
    sessions: number
    duration: number
    sequence?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    benefits?: MembershipBenefitCreateNestedManyWithoutMembershipInput
  }

  export type MembershipUncheckedCreateWithoutMembershipUserInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    price: number
    sessions: number
    duration: number
    sequence?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    benefits?: MembershipBenefitUncheckedCreateNestedManyWithoutMembershipInput
  }

  export type MembershipCreateOrConnectWithoutMembershipUserInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutMembershipUserInput, MembershipUncheckedCreateWithoutMembershipUserInput>
  }

  export type InvoiceCreateWithoutMembershipUserInput = {
    id?: string
    number: string
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    user: UserCreateNestedOneWithoutInvoiceInput
    payment?: PaymentCreateNestedOneWithoutInvoiceInput
    booking?: BookingCreateNestedOneWithoutInvoiceInput
    classBooking?: ClassBookingCreateNestedOneWithoutInvoiceInput
    tournamentRegistration?: TournamentRegistrationCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutMembershipUserInput = {
    id?: string
    bookingId?: string | null
    classBookingId?: string | null
    tournamentRegistrationId?: string | null
    number: string
    userId: string
    paymentId?: string | null
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutMembershipUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutMembershipUserInput, InvoiceUncheckedCreateWithoutMembershipUserInput>
  }

  export type UserUpsertWithoutMembershipUserInput = {
    update: XOR<UserUpdateWithoutMembershipUserInput, UserUncheckedUpdateWithoutMembershipUserInput>
    create: XOR<UserCreateWithoutMembershipUserInput, UserUncheckedCreateWithoutMembershipUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipUserInput, UserUncheckedUpdateWithoutMembershipUserInput>
  }

  export type UserUpdateWithoutMembershipUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUncheckedUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUncheckedUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUncheckedUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MembershipUpsertWithoutMembershipUserInput = {
    update: XOR<MembershipUpdateWithoutMembershipUserInput, MembershipUncheckedUpdateWithoutMembershipUserInput>
    create: XOR<MembershipCreateWithoutMembershipUserInput, MembershipUncheckedCreateWithoutMembershipUserInput>
    where?: MembershipWhereInput
  }

  export type MembershipUpdateToOneWithWhereWithoutMembershipUserInput = {
    where?: MembershipWhereInput
    data: XOR<MembershipUpdateWithoutMembershipUserInput, MembershipUncheckedUpdateWithoutMembershipUserInput>
  }

  export type MembershipUpdateWithoutMembershipUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: MembershipBenefitUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipUncheckedUpdateWithoutMembershipUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    sequence?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    benefits?: MembershipBenefitUncheckedUpdateManyWithoutMembershipNestedInput
  }

  export type InvoiceUpsertWithoutMembershipUserInput = {
    update: XOR<InvoiceUpdateWithoutMembershipUserInput, InvoiceUncheckedUpdateWithoutMembershipUserInput>
    create: XOR<InvoiceCreateWithoutMembershipUserInput, InvoiceUncheckedCreateWithoutMembershipUserInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutMembershipUserInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutMembershipUserInput, InvoiceUncheckedUpdateWithoutMembershipUserInput>
  }

  export type InvoiceUpdateWithoutMembershipUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    payment?: PaymentUpdateOneWithoutInvoiceNestedInput
    booking?: BookingUpdateOneWithoutInvoiceNestedInput
    classBooking?: ClassBookingUpdateOneWithoutInvoiceNestedInput
    tournamentRegistration?: TournamentRegistrationUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutMembershipUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    classBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassBookingCreateWithoutClassInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    user: UserCreateNestedOneWithoutClassBookingsInput
    details?: ClassBookingDetailCreateNestedManyWithoutClassBookingInput
    invoice?: InvoiceCreateNestedOneWithoutClassBookingInput
  }

  export type ClassBookingUncheckedCreateWithoutClassInput = {
    id?: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    details?: ClassBookingDetailUncheckedCreateNestedManyWithoutClassBookingInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutClassBookingInput
  }

  export type ClassBookingCreateOrConnectWithoutClassInput = {
    where: ClassBookingWhereUniqueInput
    create: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput>
  }

  export type ClassBookingCreateManyClassInputEnvelope = {
    data: ClassBookingCreateManyClassInput | ClassBookingCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassBookingUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassBookingWhereUniqueInput
    update: XOR<ClassBookingUpdateWithoutClassInput, ClassBookingUncheckedUpdateWithoutClassInput>
    create: XOR<ClassBookingCreateWithoutClassInput, ClassBookingUncheckedCreateWithoutClassInput>
  }

  export type ClassBookingUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassBookingWhereUniqueInput
    data: XOR<ClassBookingUpdateWithoutClassInput, ClassBookingUncheckedUpdateWithoutClassInput>
  }

  export type ClassBookingUpdateManyWithWhereWithoutClassInput = {
    where: ClassBookingScalarWhereInput
    data: XOR<ClassBookingUpdateManyMutationInput, ClassBookingUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassCreateWithoutClassBookingsInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    organizerName?: string | null
    speakerName?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    price: number
    sessions: number
    capacity: number
    remaining: number
    maxBookingPax?: number
    gender?: $Enums.Gender
    ageMin: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUncheckedCreateWithoutClassBookingsInput = {
    id?: string
    name: string
    description?: string | null
    content?: string | null
    organizerName?: string | null
    speakerName?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    price: number
    sessions: number
    capacity: number
    remaining: number
    maxBookingPax?: number
    gender?: $Enums.Gender
    ageMin: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateOrConnectWithoutClassBookingsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutClassBookingsInput, ClassUncheckedCreateWithoutClassBookingsInput>
  }

  export type UserCreateWithoutClassBookingsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserCreateNestedManyWithoutUserInput
    clubsLed?: ClubCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberCreateNestedManyWithoutUserInput
    invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClassBookingsInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutUserInput
    clubsLed?: ClubUncheckedCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutUserInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClassBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassBookingsInput, UserUncheckedCreateWithoutClassBookingsInput>
  }

  export type ClassBookingDetailCreateWithoutClassBookingInput = {
    id?: string
    date: Date | string
    time: string
    price: number
    attendance?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassBookingDetailUncheckedCreateWithoutClassBookingInput = {
    id?: string
    date: Date | string
    time: string
    price: number
    attendance?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassBookingDetailCreateOrConnectWithoutClassBookingInput = {
    where: ClassBookingDetailWhereUniqueInput
    create: XOR<ClassBookingDetailCreateWithoutClassBookingInput, ClassBookingDetailUncheckedCreateWithoutClassBookingInput>
  }

  export type ClassBookingDetailCreateManyClassBookingInputEnvelope = {
    data: ClassBookingDetailCreateManyClassBookingInput | ClassBookingDetailCreateManyClassBookingInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutClassBookingInput = {
    id?: string
    number: string
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    user: UserCreateNestedOneWithoutInvoiceInput
    payment?: PaymentCreateNestedOneWithoutInvoiceInput
    booking?: BookingCreateNestedOneWithoutInvoiceInput
    membershipUser?: MembershipUserCreateNestedOneWithoutInvoiceInput
    tournamentRegistration?: TournamentRegistrationCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutClassBookingInput = {
    id?: string
    bookingId?: string | null
    membershipUserId?: string | null
    tournamentRegistrationId?: string | null
    number: string
    userId: string
    paymentId?: string | null
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutClassBookingInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClassBookingInput, InvoiceUncheckedCreateWithoutClassBookingInput>
  }

  export type ClassUpsertWithoutClassBookingsInput = {
    update: XOR<ClassUpdateWithoutClassBookingsInput, ClassUncheckedUpdateWithoutClassBookingsInput>
    create: XOR<ClassCreateWithoutClassBookingsInput, ClassUncheckedCreateWithoutClassBookingsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutClassBookingsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutClassBookingsInput, ClassUncheckedUpdateWithoutClassBookingsInput>
  }

  export type ClassUpdateWithoutClassBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    organizerName?: NullableStringFieldUpdateOperationsInput | string | null
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    remaining?: IntFieldUpdateOperationsInput | number
    maxBookingPax?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    ageMin?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateWithoutClassBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    organizerName?: NullableStringFieldUpdateOperationsInput | string | null
    speakerName?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    sessions?: IntFieldUpdateOperationsInput | number
    capacity?: IntFieldUpdateOperationsInput | number
    remaining?: IntFieldUpdateOperationsInput | number
    maxBookingPax?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    ageMin?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutClassBookingsInput = {
    update: XOR<UserUpdateWithoutClassBookingsInput, UserUncheckedUpdateWithoutClassBookingsInput>
    create: XOR<UserCreateWithoutClassBookingsInput, UserUncheckedCreateWithoutClassBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassBookingsInput, UserUncheckedUpdateWithoutClassBookingsInput>
  }

  export type UserUpdateWithoutClassBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClassBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUncheckedUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUncheckedUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassBookingDetailUpsertWithWhereUniqueWithoutClassBookingInput = {
    where: ClassBookingDetailWhereUniqueInput
    update: XOR<ClassBookingDetailUpdateWithoutClassBookingInput, ClassBookingDetailUncheckedUpdateWithoutClassBookingInput>
    create: XOR<ClassBookingDetailCreateWithoutClassBookingInput, ClassBookingDetailUncheckedCreateWithoutClassBookingInput>
  }

  export type ClassBookingDetailUpdateWithWhereUniqueWithoutClassBookingInput = {
    where: ClassBookingDetailWhereUniqueInput
    data: XOR<ClassBookingDetailUpdateWithoutClassBookingInput, ClassBookingDetailUncheckedUpdateWithoutClassBookingInput>
  }

  export type ClassBookingDetailUpdateManyWithWhereWithoutClassBookingInput = {
    where: ClassBookingDetailScalarWhereInput
    data: XOR<ClassBookingDetailUpdateManyMutationInput, ClassBookingDetailUncheckedUpdateManyWithoutClassBookingInput>
  }

  export type ClassBookingDetailScalarWhereInput = {
    AND?: ClassBookingDetailScalarWhereInput | ClassBookingDetailScalarWhereInput[]
    OR?: ClassBookingDetailScalarWhereInput[]
    NOT?: ClassBookingDetailScalarWhereInput | ClassBookingDetailScalarWhereInput[]
    id?: StringFilter<"ClassBookingDetail"> | string
    classBookingId?: StringFilter<"ClassBookingDetail"> | string
    date?: DateTimeFilter<"ClassBookingDetail"> | Date | string
    time?: StringFilter<"ClassBookingDetail"> | string
    price?: IntFilter<"ClassBookingDetail"> | number
    attendance?: BoolFilter<"ClassBookingDetail"> | boolean
    createdAt?: DateTimeFilter<"ClassBookingDetail"> | Date | string
    updatedAt?: DateTimeFilter<"ClassBookingDetail"> | Date | string
  }

  export type InvoiceUpsertWithoutClassBookingInput = {
    update: XOR<InvoiceUpdateWithoutClassBookingInput, InvoiceUncheckedUpdateWithoutClassBookingInput>
    create: XOR<InvoiceCreateWithoutClassBookingInput, InvoiceUncheckedCreateWithoutClassBookingInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutClassBookingInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutClassBookingInput, InvoiceUncheckedUpdateWithoutClassBookingInput>
  }

  export type InvoiceUpdateWithoutClassBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    payment?: PaymentUpdateOneWithoutInvoiceNestedInput
    booking?: BookingUpdateOneWithoutInvoiceNestedInput
    membershipUser?: MembershipUserUpdateOneWithoutInvoiceNestedInput
    tournamentRegistration?: TournamentRegistrationUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClassBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassBookingCreateWithoutDetailsInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    class: ClassCreateNestedOneWithoutClassBookingsInput
    user: UserCreateNestedOneWithoutClassBookingsInput
    invoice?: InvoiceCreateNestedOneWithoutClassBookingInput
  }

  export type ClassBookingUncheckedCreateWithoutDetailsInput = {
    id?: string
    classId: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutClassBookingInput
  }

  export type ClassBookingCreateOrConnectWithoutDetailsInput = {
    where: ClassBookingWhereUniqueInput
    create: XOR<ClassBookingCreateWithoutDetailsInput, ClassBookingUncheckedCreateWithoutDetailsInput>
  }

  export type ClassBookingUpsertWithoutDetailsInput = {
    update: XOR<ClassBookingUpdateWithoutDetailsInput, ClassBookingUncheckedUpdateWithoutDetailsInput>
    create: XOR<ClassBookingCreateWithoutDetailsInput, ClassBookingUncheckedCreateWithoutDetailsInput>
    where?: ClassBookingWhereInput
  }

  export type ClassBookingUpdateToOneWithWhereWithoutDetailsInput = {
    where?: ClassBookingWhereInput
    data: XOR<ClassBookingUpdateWithoutDetailsInput, ClassBookingUncheckedUpdateWithoutDetailsInput>
  }

  export type ClassBookingUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutClassBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutClassBookingsNestedInput
    invoice?: InvoiceUpdateOneWithoutClassBookingNestedInput
  }

  export type ClassBookingUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutClassBookingNestedInput
  }

  export type UserCreateWithoutClubsLedInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingCreateNestedManyWithoutUserInput
    clubMember?: ClubMemberCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberCreateNestedManyWithoutUserInput
    invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClubsLedInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingUncheckedCreateNestedManyWithoutUserInput
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutUserInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutUserInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClubsLedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClubsLedInput, UserUncheckedCreateWithoutClubsLedInput>
  }

  export type ClubMemberCreateWithoutClubInput = {
    id?: string
    joinedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClubMemberInput
  }

  export type ClubMemberUncheckedCreateWithoutClubInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClubMemberCreateOrConnectWithoutClubInput = {
    where: ClubMemberWhereUniqueInput
    create: XOR<ClubMemberCreateWithoutClubInput, ClubMemberUncheckedCreateWithoutClubInput>
  }

  export type ClubMemberCreateManyClubInputEnvelope = {
    data: ClubMemberCreateManyClubInput | ClubMemberCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type TournamentRegistrationCreateWithoutClubInput = {
    id?: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    tournament: TournamentCreateNestedOneWithoutTournamentRegistrationInput
    membersRef?: TournamentRegistrationMemberCreateNestedManyWithoutTournamentRegistrationInput
    invoice?: InvoiceCreateNestedOneWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationUncheckedCreateWithoutClubInput = {
    id?: string
    tournamentId: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    membersRef?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutTournamentRegistrationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationCreateOrConnectWithoutClubInput = {
    where: TournamentRegistrationWhereUniqueInput
    create: XOR<TournamentRegistrationCreateWithoutClubInput, TournamentRegistrationUncheckedCreateWithoutClubInput>
  }

  export type TournamentRegistrationCreateManyClubInputEnvelope = {
    data: TournamentRegistrationCreateManyClubInput | TournamentRegistrationCreateManyClubInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClubsLedInput = {
    update: XOR<UserUpdateWithoutClubsLedInput, UserUncheckedUpdateWithoutClubsLedInput>
    create: XOR<UserCreateWithoutClubsLedInput, UserUncheckedCreateWithoutClubsLedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClubsLedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClubsLedInput, UserUncheckedUpdateWithoutClubsLedInput>
  }

  export type UserUpdateWithoutClubsLedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUpdateManyWithoutUserNestedInput
    clubMember?: ClubMemberUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClubsLedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUncheckedUpdateManyWithoutUserNestedInput
    clubMember?: ClubMemberUncheckedUpdateManyWithoutUserNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClubMemberUpsertWithWhereUniqueWithoutClubInput = {
    where: ClubMemberWhereUniqueInput
    update: XOR<ClubMemberUpdateWithoutClubInput, ClubMemberUncheckedUpdateWithoutClubInput>
    create: XOR<ClubMemberCreateWithoutClubInput, ClubMemberUncheckedCreateWithoutClubInput>
  }

  export type ClubMemberUpdateWithWhereUniqueWithoutClubInput = {
    where: ClubMemberWhereUniqueInput
    data: XOR<ClubMemberUpdateWithoutClubInput, ClubMemberUncheckedUpdateWithoutClubInput>
  }

  export type ClubMemberUpdateManyWithWhereWithoutClubInput = {
    where: ClubMemberScalarWhereInput
    data: XOR<ClubMemberUpdateManyMutationInput, ClubMemberUncheckedUpdateManyWithoutClubInput>
  }

  export type TournamentRegistrationUpsertWithWhereUniqueWithoutClubInput = {
    where: TournamentRegistrationWhereUniqueInput
    update: XOR<TournamentRegistrationUpdateWithoutClubInput, TournamentRegistrationUncheckedUpdateWithoutClubInput>
    create: XOR<TournamentRegistrationCreateWithoutClubInput, TournamentRegistrationUncheckedCreateWithoutClubInput>
  }

  export type TournamentRegistrationUpdateWithWhereUniqueWithoutClubInput = {
    where: TournamentRegistrationWhereUniqueInput
    data: XOR<TournamentRegistrationUpdateWithoutClubInput, TournamentRegistrationUncheckedUpdateWithoutClubInput>
  }

  export type TournamentRegistrationUpdateManyWithWhereWithoutClubInput = {
    where: TournamentRegistrationScalarWhereInput
    data: XOR<TournamentRegistrationUpdateManyMutationInput, TournamentRegistrationUncheckedUpdateManyWithoutClubInput>
  }

  export type TournamentRegistrationScalarWhereInput = {
    AND?: TournamentRegistrationScalarWhereInput | TournamentRegistrationScalarWhereInput[]
    OR?: TournamentRegistrationScalarWhereInput[]
    NOT?: TournamentRegistrationScalarWhereInput | TournamentRegistrationScalarWhereInput[]
    id?: StringFilter<"TournamentRegistration"> | string
    tournamentId?: StringFilter<"TournamentRegistration"> | string
    clubId?: StringFilter<"TournamentRegistration"> | string
    members?: IntFilter<"TournamentRegistration"> | number
    totalFee?: IntFilter<"TournamentRegistration"> | number
    status?: EnumBookingStatusFilter<"TournamentRegistration"> | $Enums.BookingStatus
    createdAt?: DateTimeFilter<"TournamentRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"TournamentRegistration"> | Date | string
    paymentLockedUntil?: DateTimeNullableFilter<"TournamentRegistration"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"TournamentRegistration"> | Date | string | null
    cancellationReason?: StringNullableFilter<"TournamentRegistration"> | string | null
  }

  export type ClubCreateWithoutClubMemberInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutClubsLedInput
    tournamentRegistration?: TournamentRegistrationCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutClubMemberInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    leaderId: string
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentRegistration?: TournamentRegistrationUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutClubMemberInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutClubMemberInput, ClubUncheckedCreateWithoutClubMemberInput>
  }

  export type UserCreateWithoutClubMemberInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingCreateNestedManyWithoutUserInput
    clubsLed?: ClubCreateNestedManyWithoutLeaderInput
    tournamentRegistrationMember?: TournamentRegistrationMemberCreateNestedManyWithoutUserInput
    invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClubMemberInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingUncheckedCreateNestedManyWithoutUserInput
    clubsLed?: ClubUncheckedCreateNestedManyWithoutLeaderInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutUserInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClubMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClubMemberInput, UserUncheckedCreateWithoutClubMemberInput>
  }

  export type ClubUpsertWithoutClubMemberInput = {
    update: XOR<ClubUpdateWithoutClubMemberInput, ClubUncheckedUpdateWithoutClubMemberInput>
    create: XOR<ClubCreateWithoutClubMemberInput, ClubUncheckedCreateWithoutClubMemberInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutClubMemberInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutClubMemberInput, ClubUncheckedUpdateWithoutClubMemberInput>
  }

  export type ClubUpdateWithoutClubMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutClubsLedNestedInput
    tournamentRegistration?: TournamentRegistrationUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutClubMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentRegistration?: TournamentRegistrationUncheckedUpdateManyWithoutClubNestedInput
  }

  export type UserUpsertWithoutClubMemberInput = {
    update: XOR<UserUpdateWithoutClubMemberInput, UserUncheckedUpdateWithoutClubMemberInput>
    create: XOR<UserCreateWithoutClubMemberInput, UserUncheckedCreateWithoutClubMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClubMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClubMemberInput, UserUncheckedUpdateWithoutClubMemberInput>
  }

  export type UserUpdateWithoutClubMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUpdateManyWithoutLeaderNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClubMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUncheckedUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUncheckedUpdateManyWithoutLeaderNestedInput
    tournamentRegistrationMember?: TournamentRegistrationMemberUncheckedUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TournamentRegistrationCreateWithoutTournamentInput = {
    id?: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    club: ClubCreateNestedOneWithoutTournamentRegistrationInput
    membersRef?: TournamentRegistrationMemberCreateNestedManyWithoutTournamentRegistrationInput
    invoice?: InvoiceCreateNestedOneWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationUncheckedCreateWithoutTournamentInput = {
    id?: string
    clubId: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    membersRef?: TournamentRegistrationMemberUncheckedCreateNestedManyWithoutTournamentRegistrationInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationCreateOrConnectWithoutTournamentInput = {
    where: TournamentRegistrationWhereUniqueInput
    create: XOR<TournamentRegistrationCreateWithoutTournamentInput, TournamentRegistrationUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentRegistrationCreateManyTournamentInputEnvelope = {
    data: TournamentRegistrationCreateManyTournamentInput | TournamentRegistrationCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type TournamentRegistrationUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentRegistrationWhereUniqueInput
    update: XOR<TournamentRegistrationUpdateWithoutTournamentInput, TournamentRegistrationUncheckedUpdateWithoutTournamentInput>
    create: XOR<TournamentRegistrationCreateWithoutTournamentInput, TournamentRegistrationUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentRegistrationUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentRegistrationWhereUniqueInput
    data: XOR<TournamentRegistrationUpdateWithoutTournamentInput, TournamentRegistrationUncheckedUpdateWithoutTournamentInput>
  }

  export type TournamentRegistrationUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentRegistrationScalarWhereInput
    data: XOR<TournamentRegistrationUpdateManyMutationInput, TournamentRegistrationUncheckedUpdateManyWithoutTournamentInput>
  }

  export type TournamentCreateWithoutTournamentRegistrationInput = {
    id?: string
    name: string
    description?: string | null
    rules?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    maxTeams: number
    teamSize: number
    entryFee: number
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentUncheckedCreateWithoutTournamentRegistrationInput = {
    id?: string
    name: string
    description?: string | null
    rules?: string | null
    image?: string | null
    startDate: Date | string
    endDate: Date | string
    startTime: string
    endTime: string
    maxTeams: number
    teamSize: number
    entryFee: number
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentCreateOrConnectWithoutTournamentRegistrationInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutTournamentRegistrationInput, TournamentUncheckedCreateWithoutTournamentRegistrationInput>
  }

  export type ClubCreateWithoutTournamentRegistrationInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutClubsLedInput
    clubMember?: ClubMemberCreateNestedManyWithoutClubInput
  }

  export type ClubUncheckedCreateWithoutTournamentRegistrationInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    leaderId: string
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutClubInput
  }

  export type ClubCreateOrConnectWithoutTournamentRegistrationInput = {
    where: ClubWhereUniqueInput
    create: XOR<ClubCreateWithoutTournamentRegistrationInput, ClubUncheckedCreateWithoutTournamentRegistrationInput>
  }

  export type TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput = {
    id?: string
    isHost?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTournamentRegistrationMemberInput
  }

  export type TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput = {
    id?: string
    userId: string
    isHost?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentRegistrationMemberCreateOrConnectWithoutTournamentRegistrationInput = {
    where: TournamentRegistrationMemberWhereUniqueInput
    create: XOR<TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput, TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput>
  }

  export type TournamentRegistrationMemberCreateManyTournamentRegistrationInputEnvelope = {
    data: TournamentRegistrationMemberCreateManyTournamentRegistrationInput | TournamentRegistrationMemberCreateManyTournamentRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTournamentRegistrationInput = {
    id?: string
    number: string
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    user: UserCreateNestedOneWithoutInvoiceInput
    payment?: PaymentCreateNestedOneWithoutInvoiceInput
    booking?: BookingCreateNestedOneWithoutInvoiceInput
    classBooking?: ClassBookingCreateNestedOneWithoutInvoiceInput
    membershipUser?: MembershipUserCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTournamentRegistrationInput = {
    id?: string
    bookingId?: string | null
    classBookingId?: string | null
    membershipUserId?: string | null
    number: string
    userId: string
    paymentId?: string | null
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutTournamentRegistrationInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTournamentRegistrationInput, InvoiceUncheckedCreateWithoutTournamentRegistrationInput>
  }

  export type TournamentUpsertWithoutTournamentRegistrationInput = {
    update: XOR<TournamentUpdateWithoutTournamentRegistrationInput, TournamentUncheckedUpdateWithoutTournamentRegistrationInput>
    create: XOR<TournamentCreateWithoutTournamentRegistrationInput, TournamentUncheckedCreateWithoutTournamentRegistrationInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutTournamentRegistrationInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutTournamentRegistrationInput, TournamentUncheckedUpdateWithoutTournamentRegistrationInput>
  }

  export type TournamentUpdateWithoutTournamentRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentUncheckedUpdateWithoutTournamentRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxTeams?: IntFieldUpdateOperationsInput | number
    teamSize?: IntFieldUpdateOperationsInput | number
    entryFee?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubUpsertWithoutTournamentRegistrationInput = {
    update: XOR<ClubUpdateWithoutTournamentRegistrationInput, ClubUncheckedUpdateWithoutTournamentRegistrationInput>
    create: XOR<ClubCreateWithoutTournamentRegistrationInput, ClubUncheckedCreateWithoutTournamentRegistrationInput>
    where?: ClubWhereInput
  }

  export type ClubUpdateToOneWithWhereWithoutTournamentRegistrationInput = {
    where?: ClubWhereInput
    data: XOR<ClubUpdateWithoutTournamentRegistrationInput, ClubUncheckedUpdateWithoutTournamentRegistrationInput>
  }

  export type ClubUpdateWithoutTournamentRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutClubsLedNestedInput
    clubMember?: ClubMemberUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutTournamentRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubMember?: ClubMemberUncheckedUpdateManyWithoutClubNestedInput
  }

  export type TournamentRegistrationMemberUpsertWithWhereUniqueWithoutTournamentRegistrationInput = {
    where: TournamentRegistrationMemberWhereUniqueInput
    update: XOR<TournamentRegistrationMemberUpdateWithoutTournamentRegistrationInput, TournamentRegistrationMemberUncheckedUpdateWithoutTournamentRegistrationInput>
    create: XOR<TournamentRegistrationMemberCreateWithoutTournamentRegistrationInput, TournamentRegistrationMemberUncheckedCreateWithoutTournamentRegistrationInput>
  }

  export type TournamentRegistrationMemberUpdateWithWhereUniqueWithoutTournamentRegistrationInput = {
    where: TournamentRegistrationMemberWhereUniqueInput
    data: XOR<TournamentRegistrationMemberUpdateWithoutTournamentRegistrationInput, TournamentRegistrationMemberUncheckedUpdateWithoutTournamentRegistrationInput>
  }

  export type TournamentRegistrationMemberUpdateManyWithWhereWithoutTournamentRegistrationInput = {
    where: TournamentRegistrationMemberScalarWhereInput
    data: XOR<TournamentRegistrationMemberUpdateManyMutationInput, TournamentRegistrationMemberUncheckedUpdateManyWithoutTournamentRegistrationInput>
  }

  export type InvoiceUpsertWithoutTournamentRegistrationInput = {
    update: XOR<InvoiceUpdateWithoutTournamentRegistrationInput, InvoiceUncheckedUpdateWithoutTournamentRegistrationInput>
    create: XOR<InvoiceCreateWithoutTournamentRegistrationInput, InvoiceUncheckedCreateWithoutTournamentRegistrationInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTournamentRegistrationInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTournamentRegistrationInput, InvoiceUncheckedUpdateWithoutTournamentRegistrationInput>
  }

  export type InvoiceUpdateWithoutTournamentRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInvoiceNestedInput
    payment?: PaymentUpdateOneWithoutInvoiceNestedInput
    booking?: BookingUpdateOneWithoutInvoiceNestedInput
    classBooking?: ClassBookingUpdateOneWithoutInvoiceNestedInput
    membershipUser?: MembershipUserUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTournamentRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    classBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipUserId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TournamentRegistrationCreateWithoutMembersRefInput = {
    id?: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    tournament: TournamentCreateNestedOneWithoutTournamentRegistrationInput
    club: ClubCreateNestedOneWithoutTournamentRegistrationInput
    invoice?: InvoiceCreateNestedOneWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationUncheckedCreateWithoutMembersRefInput = {
    id?: string
    tournamentId: string
    clubId: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
    invoice?: InvoiceUncheckedCreateNestedOneWithoutTournamentRegistrationInput
  }

  export type TournamentRegistrationCreateOrConnectWithoutMembersRefInput = {
    where: TournamentRegistrationWhereUniqueInput
    create: XOR<TournamentRegistrationCreateWithoutMembersRefInput, TournamentRegistrationUncheckedCreateWithoutMembersRefInput>
  }

  export type UserCreateWithoutTournamentRegistrationMemberInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenCreateNestedManyWithoutUserInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingCreateNestedManyWithoutUserInput
    clubsLed?: ClubCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberCreateNestedManyWithoutUserInput
    invoice?: InvoiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTournamentRegistrationMemberInput = {
    id?: string
    name: string
    email?: string | null
    emailVerified?: boolean
    password?: string | null
    image?: string | null
    googleId?: string | null
    phone: string
    phoneVerified?: boolean
    banned?: boolean
    banReason?: string | null
    banExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authTokens?: AuthTokenUncheckedCreateNestedManyWithoutUserInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    membershipUser?: MembershipUserUncheckedCreateNestedManyWithoutUserInput
    classBookings?: ClassBookingUncheckedCreateNestedManyWithoutUserInput
    clubsLed?: ClubUncheckedCreateNestedManyWithoutLeaderInput
    clubMember?: ClubMemberUncheckedCreateNestedManyWithoutUserInput
    invoice?: InvoiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTournamentRegistrationMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTournamentRegistrationMemberInput, UserUncheckedCreateWithoutTournamentRegistrationMemberInput>
  }

  export type TournamentRegistrationUpsertWithoutMembersRefInput = {
    update: XOR<TournamentRegistrationUpdateWithoutMembersRefInput, TournamentRegistrationUncheckedUpdateWithoutMembersRefInput>
    create: XOR<TournamentRegistrationCreateWithoutMembersRefInput, TournamentRegistrationUncheckedCreateWithoutMembersRefInput>
    where?: TournamentRegistrationWhereInput
  }

  export type TournamentRegistrationUpdateToOneWithWhereWithoutMembersRefInput = {
    where?: TournamentRegistrationWhereInput
    data: XOR<TournamentRegistrationUpdateWithoutMembersRefInput, TournamentRegistrationUncheckedUpdateWithoutMembersRefInput>
  }

  export type TournamentRegistrationUpdateWithoutMembersRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    tournament?: TournamentUpdateOneRequiredWithoutTournamentRegistrationNestedInput
    club?: ClubUpdateOneRequiredWithoutTournamentRegistrationNestedInput
    invoice?: InvoiceUpdateOneWithoutTournamentRegistrationNestedInput
  }

  export type TournamentRegistrationUncheckedUpdateWithoutMembersRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: InvoiceUncheckedUpdateOneWithoutTournamentRegistrationNestedInput
  }

  export type UserUpsertWithoutTournamentRegistrationMemberInput = {
    update: XOR<UserUpdateWithoutTournamentRegistrationMemberInput, UserUncheckedUpdateWithoutTournamentRegistrationMemberInput>
    create: XOR<UserCreateWithoutTournamentRegistrationMemberInput, UserUncheckedCreateWithoutTournamentRegistrationMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTournamentRegistrationMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTournamentRegistrationMemberInput, UserUncheckedUpdateWithoutTournamentRegistrationMemberInput>
  }

  export type UserUpdateWithoutTournamentRegistrationMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUpdateManyWithoutUserNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTournamentRegistrationMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    banned?: BoolFieldUpdateOperationsInput | boolean
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authTokens?: AuthTokenUncheckedUpdateManyWithoutUserNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    membershipUser?: MembershipUserUncheckedUpdateManyWithoutUserNestedInput
    classBookings?: ClassBookingUncheckedUpdateManyWithoutUserNestedInput
    clubsLed?: ClubUncheckedUpdateManyWithoutLeaderNestedInput
    clubMember?: ClubMemberUncheckedUpdateManyWithoutUserNestedInput
    invoice?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuthTokenCreateManyUserInput = {
    id?: string
    staffId?: string | null
    type?: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyUserInput = {
    id?: string
    status?: $Enums.BookingStatus
    totalPrice?: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    holdExpiresAt?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
  }

  export type MembershipUserCreateManyUserInput = {
    id?: string
    membershipId: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassBookingCreateManyUserInput = {
    id?: string
    classId: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
  }

  export type ClubCreateManyLeaderInput = {
    id?: string
    name: string
    logo?: string | null
    description?: string | null
    rules?: string | null
    visibility?: $Enums.ClubVisibility
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClubMemberCreateManyUserInput = {
    id?: string
    clubId: string
    joinedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentRegistrationMemberCreateManyUserInput = {
    id?: string
    tournamentRegistrationId: string
    isHost?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    bookingId?: string | null
    classBookingId?: string | null
    membershipUserId?: string | null
    tournamentRegistrationId?: string | null
    number: string
    paymentId?: string | null
    subtotal: number
    processingFee?: number
    total: number
    status?: $Enums.PaymentStatus
    issuedAt?: Date | string
    dueDate: Date | string
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type AuthTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutAuthTokensNestedInput
  }

  export type AuthTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: BookingDetailUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: BookingDetailUncheckedUpdateManyWithoutBookingNestedInput
    inventories?: BookingInventoryUncheckedUpdateManyWithoutBookingNestedInput
    ballboys?: BookingBallboyUncheckedUpdateManyWithoutBookingNestedInput
    coaches?: BookingCoachUncheckedUpdateManyWithoutBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    holdExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MembershipUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    membership?: MembershipUpdateOneRequiredWithoutMembershipUserNestedInput
    invoice?: InvoiceUpdateOneWithoutMembershipUserNestedInput
  }

  export type MembershipUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutMembershipUserNestedInput
  }

  export type MembershipUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    membershipId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutClassBookingsNestedInput
    details?: ClassBookingDetailUpdateManyWithoutClassBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutClassBookingNestedInput
  }

  export type ClassBookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: ClassBookingDetailUncheckedUpdateManyWithoutClassBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutClassBookingNestedInput
  }

  export type ClassBookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClubUpdateWithoutLeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubMember?: ClubMemberUpdateManyWithoutClubNestedInput
    tournamentRegistration?: TournamentRegistrationUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateWithoutLeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clubMember?: ClubMemberUncheckedUpdateManyWithoutClubNestedInput
    tournamentRegistration?: TournamentRegistrationUncheckedUpdateManyWithoutClubNestedInput
  }

  export type ClubUncheckedUpdateManyWithoutLeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumClubVisibilityFieldUpdateOperationsInput | $Enums.ClubVisibility
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    club?: ClubUpdateOneRequiredWithoutClubMemberNestedInput
  }

  export type ClubMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentRegistrationMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentRegistration?: TournamentRegistrationUpdateOneRequiredWithoutMembersRefNestedInput
  }

  export type TournamentRegistrationMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentRegistrationId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentRegistrationMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentRegistrationId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutInvoiceNestedInput
    booking?: BookingUpdateOneWithoutInvoiceNestedInput
    classBooking?: ClassBookingUpdateOneWithoutInvoiceNestedInput
    membershipUser?: MembershipUserUpdateOneWithoutInvoiceNestedInput
    tournamentRegistration?: TournamentRegistrationUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    classBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    classBookingId?: NullableStringFieldUpdateOperationsInput | string | null
    membershipUserId?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentRegistrationId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuthTokenCreateManyStaffInput = {
    id?: string
    userId?: string | null
    type?: $Enums.AuthTokenType
    refreshToken: string
    refreshExpiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlotCreateManyStaffInput = {
    id?: string
    type: $Enums.SlotType
    courtId?: string | null
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachTypeStaffPriceCreateManyStaffInput = {
    id?: string
    coachTypeId: string
    basePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthTokenUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuthTokensNestedInput
  }

  export type AuthTokenUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthTokenUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAuthTokenTypeFieldUpdateOperationsInput | $Enums.AuthTokenType
    refreshToken?: StringFieldUpdateOperationsInput | string
    refreshExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    court?: CourtUpdateOneWithoutSlotNestedInput
    bookingDetails?: BookingDetailUpdateManyWithoutSlotNestedInput
    bookingCoaches?: BookingCoachUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUpdateManyWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingDetails?: BookingDetailUncheckedUpdateManyWithoutSlotNestedInput
    bookingCoaches?: BookingCoachUncheckedUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachTypeStaffPriceUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachType?: BookingCoachTypeUpdateOneRequiredWithoutCoachTypeStaffPriceNestedInput
  }

  export type CoachTypeStaffPriceUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachTypeId?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachTypeStaffPriceUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachTypeId?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCostScheduleCreateManyCourtInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    price: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingDetailCreateManyCourtInput = {
    id?: string
    bookingId: string
    slotId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlotCreateManyCourtInput = {
    id?: string
    type: $Enums.SlotType
    staffId?: string | null
    startAt: Date | string
    endAt: Date | string
    price?: number
    isAvailable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourtCostScheduleUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCostScheduleUncheckedUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCostScheduleUncheckedUpdateManyWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingDetailUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutDetailsNestedInput
    slot?: SlotUpdateOneRequiredWithoutBookingDetailsNestedInput
  }

  export type BookingDetailUncheckedUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingDetailUncheckedUpdateManyWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlotUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutSlotNestedInput
    bookingDetails?: BookingDetailUpdateManyWithoutSlotNestedInput
    bookingCoaches?: BookingCoachUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUpdateManyWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingDetails?: BookingDetailUncheckedUpdateManyWithoutSlotNestedInput
    bookingCoaches?: BookingCoachUncheckedUpdateManyWithoutSlotNestedInput
    bookingBallboys?: BookingBallboyUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type SlotUncheckedUpdateManyWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingInventoryCreateManyInventoryInput = {
    id?: string
    bookingId: string
    quantity?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingInventoryUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutInventoriesNestedInput
  }

  export type BookingInventoryUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingInventoryUncheckedUpdateManyWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingDetailCreateManySlotInput = {
    id?: string
    bookingId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courtId?: string | null
  }

  export type BookingCoachCreateManySlotInput = {
    id?: string
    bookingId: string
    bookingCoachTypeId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingBallboyCreateManySlotInput = {
    id?: string
    bookingId: string
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingDetailUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutDetailsNestedInput
    court?: CourtUpdateOneWithoutBookingDetailNestedInput
  }

  export type BookingDetailUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingDetailUncheckedUpdateManyWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingCoachUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCoachesNestedInput
    bookingCoachType?: BookingCoachTypeUpdateOneRequiredWithoutBookingCoachNestedInput
  }

  export type BookingCoachUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingCoachTypeId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachUncheckedUpdateManyWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    bookingCoachTypeId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingBallboyUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutBallboysNestedInput
  }

  export type BookingBallboyUncheckedUpdateWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingBallboyUncheckedUpdateManyWithoutSlotInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyMethodInput = {
    id?: string
    status?: $Enums.PaymentStatus
    amount: number
    fees?: number
    externalRef?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: Date | string | null
    paidAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: IntFieldUpdateOperationsInput | number
    fees?: IntFieldUpdateOperationsInput | number
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: IntFieldUpdateOperationsInput | number
    fees?: IntFieldUpdateOperationsInput | number
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    amount?: IntFieldUpdateOperationsInput | number
    fees?: IntFieldUpdateOperationsInput | number
    externalRef?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingDetailCreateManyBookingInput = {
    id?: string
    slotId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courtId?: string | null
  }

  export type BookingInventoryCreateManyBookingInput = {
    id?: string
    inventoryId: string
    quantity?: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingBallboyCreateManyBookingInput = {
    id?: string
    slotId: string
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCoachCreateManyBookingInput = {
    id?: string
    slotId: string
    bookingCoachTypeId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingDetailUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: SlotUpdateOneRequiredWithoutBookingDetailsNestedInput
    court?: CourtUpdateOneWithoutBookingDetailNestedInput
  }

  export type BookingDetailUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingDetailUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingInventoryUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUpdateOneRequiredWithoutBookingInventoryNestedInput
  }

  export type BookingInventoryUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingInventoryUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventoryId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingBallboyUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: SlotUpdateOneRequiredWithoutBookingBallboysNestedInput
  }

  export type BookingBallboyUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingBallboyUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: SlotUpdateOneRequiredWithoutBookingCoachesNestedInput
    bookingCoachType?: BookingCoachTypeUpdateOneRequiredWithoutBookingCoachNestedInput
  }

  export type BookingCoachUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    bookingCoachTypeId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    bookingCoachTypeId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachCreateManyBookingCoachTypeInput = {
    id?: string
    bookingId: string
    slotId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachTypeStaffPriceCreateManyCoachTypeInput = {
    id?: string
    staffId: string
    basePrice: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCoachUpdateWithoutBookingCoachTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCoachesNestedInput
    slot?: SlotUpdateOneRequiredWithoutBookingCoachesNestedInput
  }

  export type BookingCoachUncheckedUpdateWithoutBookingCoachTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCoachUncheckedUpdateManyWithoutBookingCoachTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    slotId?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachTypeStaffPriceUpdateWithoutCoachTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutCoachTypeStaffPriceNestedInput
  }

  export type CoachTypeStaffPriceUncheckedUpdateWithoutCoachTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachTypeStaffPriceUncheckedUpdateManyWithoutCoachTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    basePrice?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipBenefitCreateManyMembershipInput = {
    id?: string
    benefit: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUserCreateManyMembershipInput = {
    id?: string
    userId: string
    startDate: Date | string
    endDate: Date | string
    remainingSessions: number
    remainingDuration: number
    isExpired?: boolean
    isSuspended?: boolean
    suspensionReason?: string | null
    suspensionEndDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipBenefitUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    benefit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipBenefitUncheckedUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    benefit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipBenefitUncheckedUpdateManyWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    benefit?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUserUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipUserNestedInput
    invoice?: InvoiceUpdateOneWithoutMembershipUserNestedInput
  }

  export type MembershipUserUncheckedUpdateWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutMembershipUserNestedInput
  }

  export type MembershipUserUncheckedUpdateManyWithoutMembershipInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    remainingSessions?: IntFieldUpdateOperationsInput | number
    remainingDuration?: IntFieldUpdateOperationsInput | number
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    suspensionReason?: NullableStringFieldUpdateOperationsInput | string | null
    suspensionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingCreateManyClassInput = {
    id?: string
    userId: string
    status?: $Enums.BookingStatus
    totalPrice: number
    processingFee?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
  }

  export type ClassBookingUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutClassBookingsNestedInput
    details?: ClassBookingDetailUpdateManyWithoutClassBookingNestedInput
    invoice?: InvoiceUpdateOneWithoutClassBookingNestedInput
  }

  export type ClassBookingUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    details?: ClassBookingDetailUncheckedUpdateManyWithoutClassBookingNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutClassBookingNestedInput
  }

  export type ClassBookingUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalPrice?: IntFieldUpdateOperationsInput | number
    processingFee?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassBookingDetailCreateManyClassBookingInput = {
    id?: string
    date: Date | string
    time: string
    price: number
    attendance?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassBookingDetailUpdateWithoutClassBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    attendance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingDetailUncheckedUpdateWithoutClassBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    attendance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassBookingDetailUncheckedUpdateManyWithoutClassBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    attendance?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubMemberCreateManyClubInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentRegistrationCreateManyClubInput = {
    id?: string
    tournamentId: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
  }

  export type ClubMemberUpdateWithoutClubInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClubMemberNestedInput
  }

  export type ClubMemberUncheckedUpdateWithoutClubInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClubMemberUncheckedUpdateManyWithoutClubInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentRegistrationUpdateWithoutClubInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    tournament?: TournamentUpdateOneRequiredWithoutTournamentRegistrationNestedInput
    membersRef?: TournamentRegistrationMemberUpdateManyWithoutTournamentRegistrationNestedInput
    invoice?: InvoiceUpdateOneWithoutTournamentRegistrationNestedInput
  }

  export type TournamentRegistrationUncheckedUpdateWithoutClubInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    membersRef?: TournamentRegistrationMemberUncheckedUpdateManyWithoutTournamentRegistrationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTournamentRegistrationNestedInput
  }

  export type TournamentRegistrationUncheckedUpdateManyWithoutClubInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TournamentRegistrationCreateManyTournamentInput = {
    id?: string
    clubId: string
    members: number
    totalFee: number
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentLockedUntil?: Date | string | null
    cancelledAt?: Date | string | null
    cancellationReason?: string | null
  }

  export type TournamentRegistrationUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    club?: ClubUpdateOneRequiredWithoutTournamentRegistrationNestedInput
    membersRef?: TournamentRegistrationMemberUpdateManyWithoutTournamentRegistrationNestedInput
    invoice?: InvoiceUpdateOneWithoutTournamentRegistrationNestedInput
  }

  export type TournamentRegistrationUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    membersRef?: TournamentRegistrationMemberUncheckedUpdateManyWithoutTournamentRegistrationNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutTournamentRegistrationNestedInput
  }

  export type TournamentRegistrationUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clubId?: StringFieldUpdateOperationsInput | string
    members?: IntFieldUpdateOperationsInput | number
    totalFee?: IntFieldUpdateOperationsInput | number
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentLockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TournamentRegistrationMemberCreateManyTournamentRegistrationInput = {
    id?: string
    userId: string
    isHost?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TournamentRegistrationMemberUpdateWithoutTournamentRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTournamentRegistrationMemberNestedInput
  }

  export type TournamentRegistrationMemberUncheckedUpdateWithoutTournamentRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentRegistrationMemberUncheckedUpdateManyWithoutTournamentRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isHost?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}