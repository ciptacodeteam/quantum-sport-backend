// ------------------------------
// Prisma Generators & Datasource
// ------------------------------
generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ------------------------------
// Common Enums
// ------------------------------
enum Role {
  ADMIN
  BALLBOY
  COACH
}

enum PhoneVerificationType {
  LOGIN
  REGISTER
  FORGOT_PASSWORD
  VERIFY_PHONE
  CHANGE_PHONE
}

enum AuthTokenType {
  STAFF
  USER
}

enum PaymentStatus {
  PENDING
  AWAITING_CONFIRMATION // created but not paid (e.g., VA issued)
  PAID // paid & captured/settled by gateway
  CANCELLED
  EXPIRED
  REFUNDED
}

enum BookingStatus {
  DRAFT // cart-like pre-checkout
  HOLD // temporary hold on slots before payment (expiry)
  CONFIRMED // paid; slots locked
  CANCELLED
}

enum SlotType {
  COURT
  COACH
  BALLBOY
}

enum Gender {
  MALE
  FEMALE
  ALL
}

enum ClubVisibility {
  PRIVATE
  PUBLIC
}

// ------------------------------
// Users & Auth
// ------------------------------
model User {
  id            String  @id @default(cuid())
  name          String
  email         String? @unique
  emailVerified Boolean @default(false)
  password      String?
  image         String?
  googleId      String? @unique

  phone         String  @unique
  phoneVerified Boolean @default(false)

  banned     Boolean   @default(false)
  banReason  String?
  banExpires DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  authTokens                   AuthToken[]
  bookings                     Booking[]
  membershipUser               MembershipUser[]
  classBookings                ClassBooking[]
  clubsLed                     Club[]                         @relation("ClubLeader")
  clubMember                   ClubMember[]
  tournamentRegistrationMember TournamentRegistrationMember[]
  invoice                      Invoice[]

  @@map("user")
}

model PhoneVerification {
  id        String                 @id @default(cuid())
  phone     String                 @unique
  type      PhoneVerificationType?
  code      String
  expiresAt DateTime
  requestId String
  isUsed    Boolean                @default(false)
  createdAt DateTime               @default(now())
  updatedAt DateTime               @default(now()) @updatedAt

  @@map("phone_verification")
}

model Staff {
  id        String   @id @default(cuid())
  image     String?
  name      String
  email     String   @unique
  phone     String?  @unique
  password  String
  isActive  Boolean  @default(true)
  joinedAt  DateTime @default(now()) @db.Date
  role      Role     @default(ADMIN)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  authTokens          AuthToken[]
  // Derived schedules now use Slot (see below) instead of separate tables
  slot                Slot[]
  coachTypeStaffPrice CoachTypeStaffPrice[]

  @@map("staff")
}

model AuthToken {
  id               String        @id @default(cuid())
  userId           String?
  staffId          String?
  type             AuthTokenType @default(USER)
  refreshToken     String        @unique
  refreshExpiresAt DateTime
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @default(now()) @updatedAt

  user  User?  @relation(fields: [userId], references: [id], onDelete: Cascade)
  staff Staff? @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@map("auth_token")
}

// ------------------------------
// Catalogs / Content
// ------------------------------
model Banner {
  id        String    @id @default(cuid())
  image     String
  link      String?
  isActive  Boolean   @default(true)
  startAt   DateTime?
  endAt     DateTime?
  sequence  Int       @default(0)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt

  @@index([isActive, startAt, endAt, sequence])
  @@map("banners")
}

model Court {
  id          String   @id @default(cuid())
  name        String
  description String?
  image       String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  costSchedules CourtCostSchedule[]
  bookingDetail BookingDetail[]
  slot          Slot[]

  @@unique([name])
  @@index([isActive])
  @@map("courts")
}

model Inventory {
  id          String   @id @default(cuid())
  name        String
  description String?
  quantity    Int      @default(0) // stock on hand
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  bookingInventory BookingInventory[]

  @@unique([name])
  @@index([isActive])
  @@map("inventories")
}

// ------------------------------
// Scheduling (Unified Slot model)
// ------------------------------
// All “time grids” (court / coach / ballboy) are modeled as Slots with start/end times.
// Non-overlap is enforced via unique constraints per resource.

model Slot {
  id          String   @id @default(cuid())
  type        SlotType
  // Resource pointers (exactly one must be set depending on type)
  courtId     String?
  staffId     String? // for COACH or BALLBOY
  // The actual time window (timestamptz)
  startAt     DateTime
  endAt       DateTime
  price       Int      @default(0) @db.Integer // in rupiah, 0 for free/ballboy if bundled
  isAvailable Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  court Court? @relation(fields: [courtId], references: [id])
  staff Staff? @relation(fields: [staffId], references: [id])

  bookingDetails  BookingDetail[] // court slots
  bookingCoaches  BookingCoach[] // coach slots
  bookingBallboys BookingBallboy[] // ballboy slots

  // Prevent overlaps per resource+time window:
  // (Postgres cannot enforce “no overlap” via Prisma directly; we simulate with unique composite on (resource, startAt))
  @@unique([courtId, startAt], map: "uq_court_slot_start") // for COURT
  @@unique([staffId, startAt], map: "uq_staff_slot_start") // for COACH/BALLBOY
  @@index([type, startAt, endAt, isAvailable])
  @@map("slots")
}

// Legacy CourtCostSchedule kept as a published price table (optional)
// Often still useful for “price calendar” UIs and batch slot generation.
model CourtCostSchedule {
  id          String   @id @default(cuid())
  courtId     String
  // For a whole-day price grid (e.g., 08:00-09:00), store range:
  startAt     DateTime
  endAt       DateTime
  price       Int      @db.Integer
  isAvailable Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  court Court @relation(fields: [courtId], references: [id])

  @@unique([courtId, startAt], map: "uq_court_cost_start")
  @@index([courtId, startAt, endAt, isAvailable])
  @@map("court_cost_schedules")
}

// ------------------------------
// Payments & Invoices
// ------------------------------
model PaymentMethod {
  id        String   @id @default(cuid())
  name      String
  logo      String?
  fees      Int      @default(0) @db.Integer // fixed fee (rupiah)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  payments Payment[]

  @@unique([name])
  @@index([isActive])
  @@map("payment_methods")
}

model Payment {
  id              String        @id @default(cuid())
  paymentMethodId String
  status          PaymentStatus @default(PENDING)
  amount          Int           @db.Integer // total amount requested
  fees            Int           @default(0) @db.Integer // gateway/admin fees recorded
  externalRef     String?       @unique // gateway transaction id / VA number, etc.
  meta            Json? // raw payloads or gateway-specific fields
  dueDate         DateTime?
  paidAt          DateTime?
  cancelledAt     DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @default(now()) @updatedAt

  method  PaymentMethod @relation(fields: [paymentMethodId], references: [id])
  invoice Invoice?

  @@index([status, dueDate])
  @@map("payments")
}

model Invoice {
  id                       String  @id @default(cuid())
  // Polymorphic linkage via nullable FKs (exactly one must be set)
  bookingId                String? @unique
  classBookingId           String? @unique
  membershipUserId         String? @unique
  tournamentRegistrationId String? @unique

  number        String        @unique // human-readable invoice no
  userId        String
  paymentId     String?       @unique
  subtotal      Int           @db.Integer
  processingFee Int           @default(0) @db.Integer
  total         Int           @db.Integer
  status        PaymentStatus @default(PENDING)

  issuedAt    DateTime  @default(now())
  dueDate     DateTime
  paidAt      DateTime?
  cancelledAt DateTime?

  user                   User                    @relation(fields: [userId], references: [id])
  payment                Payment?                @relation(fields: [paymentId], references: [id])
  booking                Booking?                @relation(fields: [bookingId], references: [id])
  classBooking           ClassBooking?           @relation(fields: [classBookingId], references: [id])
  membershipUser         MembershipUser?         @relation(fields: [membershipUserId], references: [id])
  tournamentRegistration TournamentRegistration? @relation(fields: [tournamentRegistrationId], references: [id])

  @@index([status, dueDate])
  @@map("invoices")
}

// ------------------------------
// Booking (Courts + optional add-ons)
// ------------------------------
model Booking {
  id                 String        @id @default(cuid())
  userId             String
  status             BookingStatus @default(DRAFT)
  totalPrice         Int           @default(0) @db.Integer
  processingFee      Int           @default(0) @db.Integer
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @default(now()) @updatedAt
  holdExpiresAt      DateTime? // for HOLD; auto-release slots when passed
  cancelledAt        DateTime?
  cancellationReason String?

  user        User               @relation(fields: [userId], references: [id])
  details     BookingDetail[]
  inventories BookingInventory[]
  ballboys    BookingBallboy[]
  coaches     BookingCoach[]
  invoice     Invoice?

  @@index([userId, status, createdAt])
  @@map("bookings")
}

model BookingDetail {
  id        String @id @default(cuid())
  bookingId String
  slotId    String // COURT slot
  price     Int    @db.Integer

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  slot    Slot    @relation(fields: [slotId], references: [id])
  court   Court?  @relation(fields: [courtId], references: [id])
  courtId String?

  // Ensure a court slot is not double-booked:
  @@unique([slotId], map: "uq_bookingdetail_slot")
  @@map("booking_details")
}

model BookingInventory {
  id          String   @id @default(cuid())
  bookingId   String
  inventoryId String
  quantity    Int      @default(1)
  price       Int      @default(0) @db.Integer // unit price captured at checkout
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  booking   Booking   @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  inventory Inventory @relation(fields: [inventoryId], references: [id])

  @@index([bookingId])
  @@map("booking_inventories")
}

model BookingBallboy {
  id        String   @id @default(cuid())
  bookingId String
  slotId    String // BALLBOY slot
  price     Int      @default(0) @db.Integer
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  slot    Slot    @relation(fields: [slotId], references: [id])

  @@unique([slotId], map: "uq_bookingballboy_slot")
  @@map("booking_ballboys")
}

model BookingCoachType {
  id          String   @id @default(cuid())
  name        String // e.g., "guided match" or "personal training"
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  bookingCoach        BookingCoach[]
  coachTypeStaffPrice CoachTypeStaffPrice[]

  @@unique([name])
  @@index([isActive])
  @@map("coach_types")
}

model CoachTypeStaffPrice {
  id          String   @id @default(cuid())
  staffId     String
  coachTypeId String
  basePrice   BigInt
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  staff     Staff            @relation(fields: [staffId], references: [id], onDelete: Cascade)
  coachType BookingCoachType @relation(fields: [coachTypeId], references: [id], onDelete: Cascade)

  @@unique([staffId, coachTypeId], map: "uq_staff_coachtype_price")
  @@map("coach_type_staff_prices")
}

model BookingCoach {
  id                 String   @id @default(cuid())
  bookingId          String
  slotId             String // COACH slot
  bookingCoachTypeId String
  price              Int      @db.Integer
  createdAt          DateTime @default(now())
  updatedAt          DateTime @default(now()) @updatedAt

  booking          Booking          @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  slot             Slot             @relation(fields: [slotId], references: [id])
  bookingCoachType BookingCoachType @relation(fields: [bookingCoachTypeId], references: [id])

  @@unique([slotId], map: "uq_bookingcoach_slot")
  @@map("booking_coaches")
}

// ------------------------------
// Membership
// ------------------------------
model Membership {
  id          String   @id @default(cuid())
  name        String
  description String?
  content     String?
  price       Int      @db.Integer
  sessions    Int
  duration    Int // days
  sequence    Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  benefits       MembershipBenefit[]
  membershipUser MembershipUser[]

  @@unique([name])
  @@index([isActive, sequence])
  @@map("memberships")
}

model MembershipBenefit {
  id           String   @id @default(cuid())
  membershipId String
  benefit      String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt

  membership Membership @relation(fields: [membershipId], references: [id], onDelete: Cascade)

  @@map("membership_benefits")
}

model MembershipUser {
  id                String    @id @default(cuid())
  userId            String
  membershipId      String
  startDate         DateTime
  endDate           DateTime
  remainingSessions Int
  remainingDuration Int
  isExpired         Boolean   @default(false)
  isSuspended       Boolean   @default(false)
  suspensionReason  String?
  suspensionEndDate DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @default(now()) @updatedAt

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  membership Membership @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  invoice    Invoice?

  @@index([userId, isExpired, isSuspended])
  @@map("membership_users")
}

// ------------------------------
// Class
// ------------------------------
model Class {
  id            String   @id @default(cuid())
  name          String
  description   String?
  content       String?
  organizerName String?
  speakerName   String?
  image         String?
  startDate     DateTime @db.Date
  endDate       DateTime @db.Date
  startTime     String
  endTime       String
  price         Int      @db.Integer
  sessions      Int
  capacity      Int
  remaining     Int
  maxBookingPax Int      @default(0)
  gender        Gender   @default(ALL)
  ageMin        Int
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @default(now()) @updatedAt

  classBookings ClassBooking[]

  @@index([isActive, startDate, endDate])
  @@map("classes")
}

model ClassBooking {
  id                 String        @id @default(cuid())
  classId            String
  userId             String
  status             BookingStatus @default(DRAFT)
  totalPrice         Int           @db.Integer
  processingFee      Int           @default(0) @db.Integer
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @default(now()) @updatedAt
  cancelledAt        DateTime?
  cancellationReason String?

  class   Class                @relation(fields: [classId], references: [id])
  user    User                 @relation(fields: [userId], references: [id])
  details ClassBookingDetail[]
  invoice Invoice?

  @@index([userId, status, createdAt])
  @@map("class_bookings")
}

model ClassBookingDetail {
  id             String   @id @default(cuid())
  classBookingId String
  date           DateTime @db.Date
  time           String
  price          Int      @db.Integer
  attendance     Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @default(now()) @updatedAt

  classBooking ClassBooking @relation(fields: [classBookingId], references: [id], onDelete: Cascade)

  @@map("class_booking_details")
}

// ------------------------------
// Club & Tournament
// ------------------------------
model Club {
  id          String         @id @default(cuid())
  name        String
  logo        String?
  description String?
  rules       String?
  leaderId    String
  visibility  ClubVisibility @default(PUBLIC)
  isActive    Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @default(now()) @updatedAt

  leader                 User                     @relation("ClubLeader", fields: [leaderId], references: [id])
  clubMember             ClubMember[]
  tournamentRegistration TournamentRegistration[]

  @@unique([name])
  @@index([visibility, isActive])
  @@map("clubs")
}

model ClubMember {
  id        String   @id @default(cuid())
  clubId    String
  userId    String
  joinedAt  DateTime @default(now())
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  club Club @relation(fields: [clubId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([clubId, userId])
  @@map("club_members")
}

model Tournament {
  id                     String                   @id @default(cuid())
  name                   String
  description            String?
  rules                  String?
  image                  String?
  startDate              DateTime                 @db.Date
  endDate                DateTime                 @db.Date
  startTime              String
  endTime                String
  maxTeams               Int
  teamSize               Int
  entryFee               Int                      @db.Integer
  location               String
  isActive               Boolean                  @default(true)
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @default(now()) @updatedAt
  tournamentRegistration TournamentRegistration[]

  @@index([isActive, startDate, endDate])
  @@map("tournaments")
}

model TournamentRegistration {
  id                 String        @id @default(cuid())
  tournamentId       String
  clubId             String
  members            Int
  totalFee           Int           @db.Integer
  status             BookingStatus @default(DRAFT)
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @default(now()) @updatedAt
  paymentLockedUntil DateTime? // soft hold for payment window
  cancelledAt        DateTime?
  cancellationReason String?

  tournament Tournament                     @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  club       Club                           @relation(fields: [clubId], references: [id], onDelete: Cascade)
  membersRef TournamentRegistrationMember[]
  invoice    Invoice?

  @@index([clubId, status, createdAt])
  @@map("tournament_registrations")
}

model TournamentRegistrationMember {
  id                       String   @id @default(cuid())
  tournamentRegistrationId String
  userId                   String
  isHost                   Boolean  @default(false)
  createdAt                DateTime @default(now())
  updatedAt                DateTime @default(now()) @updatedAt

  tournamentRegistration TournamentRegistration @relation(fields: [tournamentRegistrationId], references: [id], onDelete: Cascade)
  user                   User                   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tournamentRegistrationId, userId])
  @@map("tournament_registration_members")
}
